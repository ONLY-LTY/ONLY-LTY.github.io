<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring bean（三）</title>
    <url>/2016/11/24/Spring-bean-three/</url>
    <content><![CDATA[<p>Spring bean 实例化</p>
<p>&emsp;&emsp;小洋前面的已经看到了Spring bean的解析了。可是聪明的小洋发现那时候的bean并没有实例化。抱着不到黄河不死心的想法，小洋又开始了艰难的旅程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractApplicationContext.refresh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">        <span class="comment">//解析bean</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">        <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">            <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">            <span class="keyword">this</span>.onRefresh();</span><br><span class="line">            <span class="keyword">this</span>.registerListeners();</span><br><span class="line">            <span class="comment">//预实例化bean，本文主要方法</span></span><br><span class="line">            <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, var5);</span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.cancelRefresh(var5);</span><br><span class="line">            <span class="keyword">throw</span> var5;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;小洋又回到了开始Spring初始化的时候，获取beanFactory之后还有好多个方法，根据名称其实已经能看出来都干什么的，小洋主要看了finishBeanFactoryInitialization这个方法，是做预实例化bean的，为什么叫预实例化呢。经过小洋一番研究，发现Spring在初始化的时候将配置的bean或者扫描的bean解析成BeanDefinition数据对象，之后并不是将所有解析出来的bean在Spring初始化的就实例化。只有特定条件的bean才会在Spring初始化的时候实例化。什么条件呢？容小洋娓娓道来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractApplicationContext.finishBeanFactoryInitialization</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(beanFactory.containsBean(<span class="string">"conversionService"</span>) &amp;&amp; beanFactory.isTypeMatch(<span class="string">"conversionService"</span>, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        beanFactory.setConversionService((ConversionService)beanFactory.getBean(<span class="string">"conversionService"</span>, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    String[] var3 = weaverAwareNames;</span><br><span class="line">    <span class="keyword">int</span> var4 = weaverAwareNames.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        String weaverAwareName = var3[var5];</span><br><span class="line">        <span class="keyword">this</span>.getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    beanFactory.setTempClassLoader((ClassLoader)<span class="keyword">null</span>);</span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line">    <span class="comment">//实例化bean，看这个东东，前面就是一些其他的处理，不关注。</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultListableBeanFactory.preInstantiateSingletons</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里构造了一List，this.beanDefinitionNames是前面解析bean的时候，将所有bean的名字</span></span><br><span class="line">        <span class="comment">//放入一个list</span></span><br><span class="line">        ArrayList beanNames = <span class="keyword">new</span> ArrayList(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">        Iterator var2 = beanNames.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                String beanName;</span><br><span class="line">                RootBeanDefinition singletonInstance;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span>(!var2.hasNext()) &#123;</span><br><span class="line">                                var2 = beanNames.iterator();</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">while</span>(var2.hasNext()) &#123;</span><br><span class="line">                                    beanName = (String)var2.next();</span><br><span class="line">                                    Object singletonInstance1 = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">                                    <span class="keyword">if</span>(singletonInstance1 <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">                                        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton1 = (SmartInitializingSingleton)singletonInstance1;</span><br><span class="line">                                        <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                                                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                                    smartSingleton1.afterSingletonsInstantiated();</span><br><span class="line">                                                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            smartSingleton1.afterSingletonsInstantiated();</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            beanName = (String)var2.next();</span><br><span class="line">                            <span class="comment">//getMergedLocalBeanDefinition这个方法就是根据beanName去获取BeanDefinition.</span></span><br><span class="line">                            <span class="comment">//其实就是从前面解析bean的时候构造的map里面获取。</span></span><br><span class="line">                            singletonInstance = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                            <span class="comment">//上面的处理无关紧要，主要是几个while的条件。满足这几条件就会一直while循环，直到里面return</span></span><br><span class="line">                        &#125; <span class="keyword">while</span>(singletonInstance.isAbstract());</span><br><span class="line">                        <span class="comment">//不是单例的</span></span><br><span class="line">                    &#125; <span class="keyword">while</span>(!singletonInstance.isSingleton());</span><br><span class="line">                    <span class="comment">//是懒加载的</span></span><br><span class="line">                &#125; <span class="keyword">while</span>(singletonInstance.isLazyInit());</span><br><span class="line">                <span class="comment">//上面可以看到，只有bean是 单例的并且不是懒加载的 才会执行下面的方法。</span></span><br><span class="line">                <span class="comment">//判断是不是FactoryBean,我们配置的bean会返回false。直接走else</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.isFactoryBean(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> FactoryBean smartSingleton = (FactoryBean)<span class="keyword">this</span>.getBean(<span class="string">"&amp;"</span> + beanName);</span><br><span class="line">                    <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                    <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; smartSingleton <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                        isEagerInit = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> Boolean.valueOf(((SmartFactoryBean)smartSingleton).isEagerInit());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;, <span class="keyword">this</span>.getAccessControlContext())).booleanValue();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        isEagerInit = smartSingleton <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp; ((SmartFactoryBean)smartSingleton).isEagerInit();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(isEagerInit) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//核心方法，获取bean实例。</span></span><br><span class="line">                    <span class="keyword">this</span>.getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;小洋发现在只有是单例模式的并且不是懒加载的bean才会在Spring初始化的实例化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractBeanFactory.doGetBean</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(String name, Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line">        <span class="comment">//AbstractBeanFactory的父类FactoryBeanRegistrySupport有个成员属性singletonObjects</span></span><br><span class="line">        <span class="comment">//private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap(64);</span></span><br><span class="line">        <span class="comment">//我们实例化的单利模式的bean都会放入到这个集合中，Spring初始化的时候肯定没有，返回的是null，</span></span><br><span class="line">        Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName);</span><br><span class="line">        Object bean;</span><br><span class="line">        <span class="keyword">if</span>(sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean \'"</span> + beanName + <span class="string">"\' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.debug(<span class="string">"Returning cached instance of singleton bean \'"</span> + beanName + <span class="string">"\'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, (RootBeanDefinition)<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有父BeanFactory则交给父BeanFactory去处理，和Java的类加载机制很像。</span></span><br><span class="line">            <span class="comment">//我们这里DefaultListableBeanFactory没有父BeanFactory所以这里的条件满足不了</span></span><br><span class="line">            BeanFactory ex = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">            <span class="keyword">if</span>(ex != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">                String var24 = <span class="keyword">this</span>.originalBeanName(name);</span><br><span class="line">                <span class="keyword">if</span>(args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ex.getBean(var24, args);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ex.getBean(var24, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!typeCheckOnly) &#123;</span><br><span class="line">                <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//现根据beanName获取BeanDefinition</span></span><br><span class="line">                <span class="keyword">final</span> RootBeanDefinition ex1 = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                <span class="keyword">this</span>.checkMergedBeanDefinition(ex1, beanName, args);</span><br><span class="line">                <span class="comment">//获取bean的依赖</span></span><br><span class="line">                String[] dependsOn = ex1.getDependsOn();</span><br><span class="line">                String[] scopeName;</span><br><span class="line">                <span class="keyword">if</span>(dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    scopeName = dependsOn;</span><br><span class="line">                    <span class="keyword">int</span> scope = dependsOn.length;</span><br><span class="line">                    <span class="comment">//循环初始化bean的依赖</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ex2 = <span class="number">0</span>; ex2 &lt; scope; ++ex2) &#123;</span><br><span class="line">                        String dependsOnBean = scopeName[ex2];</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.isDependent(beanName, dependsOnBean)) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(ex1.getResourceDescription(), beanName, <span class="string">"Circular depends-on relationship between \'"</span> + beanName + <span class="string">"\' and \'"</span> + dependsOnBean + <span class="string">"\'"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.registerDependentBean(dependsOnBean, beanName);</span><br><span class="line">                        <span class="keyword">this</span>.getBean(dependsOnBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//bean如果是单利模式的</span></span><br><span class="line">                <span class="keyword">if</span>(ex1.isSingleton()) &#123;</span><br><span class="line">                    sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//创建bean核心方法</span></span><br><span class="line">                                <span class="keyword">return</span> AbstractBeanFactory.<span class="keyword">this</span>.createBean(beanName, ex1, args);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (BeansException var2) &#123;</span><br><span class="line">                                AbstractBeanFactory.<span class="keyword">this</span>.destroySingleton(beanName);</span><br><span class="line">                                <span class="keyword">throw</span> var2;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, ex1);</span><br><span class="line">                    <span class="comment">//如果是Prototype类型的</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ex1.isPrototype()) &#123;</span><br><span class="line">                    scopeName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    Object var25;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="comment">//创建bean</span></span><br><span class="line">                        var25 = <span class="keyword">this</span>.createBean(beanName, ex1, args);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(var25, name, beanName, ex1);</span><br><span class="line">                  <span class="comment">//其他类型的</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String var26 = ex1.getScope();</span><br><span class="line">                    Scope var27 = (Scope)<span class="keyword">this</span>.scopes.get(var26);</span><br><span class="line">                    <span class="keyword">if</span>(var27 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope \'"</span> + var26 + <span class="string">"\'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Object var28 = var27.get(beanName, <span class="keyword">new</span> ObjectFactory() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                                AbstractBeanFactory.<span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line"></span><br><span class="line">                                Object var1;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    <span class="comment">//创建bean</span></span><br><span class="line">                                    var1 = AbstractBeanFactory.<span class="keyword">this</span>.createBean(beanName, ex1, args);</span><br><span class="line">                                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                    AbstractBeanFactory.<span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> var1;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                        bean = <span class="keyword">this</span>.getObjectForBeanInstance(var28, name, beanName, ex1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalStateException var21) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope \'"</span> + var26 + <span class="string">"\' is not active for the current thread; "</span> + <span class="string">"consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, var21);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var23) &#123;</span><br><span class="line">                <span class="keyword">this</span>.cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">                <span class="keyword">throw</span> var23;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......省略一部分代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;创建bean调用的核心方法都一样，只是区分了isSingleton或isPrototype或者其他的。对于singleton的会放在缓存里面，下次直接获取。而prototype则没有放入缓存。下面看创建bean的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory.doCreateBean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建一个bean的包装类</span></span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(mbd.isSingleton()) &#123;</span><br><span class="line">            instanceWrapper = (BeanWrapper)<span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化的时候肯定为空</span></span><br><span class="line">        <span class="keyword">if</span>(instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//创建bean的实例</span></span><br><span class="line">            instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object bean = instanceWrapper != <span class="keyword">null</span>?instanceWrapper.getWrappedInstance():<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//......省略部分代码</span></span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里核心 bean实例的属性注入</span></span><br><span class="line">            <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="keyword">if</span>(exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var17 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var17).getBeanName())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (BeanCreationException)var17;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, var17);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面还有部分代码 不重要不看了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory.createBeanInstance</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据反射创建class对象，mbd里面包含了我们解析出来bean的一些属性，这里其实就是根据class属性，通过Class.forName</span></span><br><span class="line">        Class beanClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span>(beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Bean class isn\'t public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(args == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object ctors = mbd.constructorArgumentLock;</span><br><span class="line">                <span class="keyword">synchronized</span>(mbd.constructorArgumentLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        resolved = <span class="keyword">true</span>;</span><br><span class="line">                        autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(resolved) &#123;</span><br><span class="line">                <span class="keyword">return</span> autowireNecessary?<span class="keyword">this</span>.autowireConstructor(beanName, mbd, (Constructor[])<span class="keyword">null</span>, (Object[])<span class="keyword">null</span>):<span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//得到bean的class对象后，会执行到这个分支，对于无参构造函数，instantiateBean就是创建bean的实例。</span></span><br><span class="line">                <span class="comment">//对于配置了构造函数参数的，autowireConstructor进行实例化。其实底层都是通过反射。只是多了参数处理</span></span><br><span class="line">                Constructor[] ctors1 = <span class="keyword">this</span>.determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">                <span class="keyword">return</span> ctors1 == <span class="keyword">null</span> &amp;&amp; mbd.getResolvedAutowireMode() != <span class="number">3</span> &amp;&amp; !mbd.hasConstructorArgumentValues() &amp;&amp; ObjectUtils.isEmpty(args)?<span class="keyword">this</span>.instantiateBean(beanName, mbd):<span class="keyword">this</span>.autowireConstructor(beanName, mbd, ctors1, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractBeanDefinition.resolveBeanClass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; resolveBeanClass(ClassLoader classLoader) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        String className = <span class="keyword">this</span>.getBeanClassName();</span><br><span class="line">        <span class="keyword">if</span>(className == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里就是通过forName去获取Class对象。</span></span><br><span class="line">            Class resolvedClass = ClassUtils.forName(className, classLoader);</span><br><span class="line">            <span class="comment">//将得到的Class对象赋值给beanClass给后面实例化的用。</span></span><br><span class="line">            <span class="keyword">this</span>.beanClass = resolvedClass;</span><br><span class="line">            <span class="keyword">return</span> resolvedClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SimpleInstantiationStrategy.instantiate 这里的实例化是无参构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">            Object var5 = bd.constructorArgumentLock;</span><br><span class="line">            Constructor constructorToUse;</span><br><span class="line">            <span class="keyword">synchronized</span>(bd.constructorArgumentLock) &#123;</span><br><span class="line">                constructorToUse = (Constructor)bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">                <span class="keyword">if</span>(constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//获取到上一步创建的bean的Class对象</span></span><br><span class="line">                    <span class="keyword">final</span> Class clazz = bd.getBeanClass();</span><br><span class="line">                    <span class="comment">//判断一下，不能是接口</span></span><br><span class="line">                    <span class="keyword">if</span>(clazz.isInterface()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span>(System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            constructorToUse = (Constructor)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction() &#123;</span><br><span class="line">                                <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                   <span class="comment">//获取默认的构造方法</span></span><br><span class="line">                                    <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[])<span class="keyword">null</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            constructorToUse = clazz.getDeclaredConstructor((Class[])<span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将获取到的构造方法设置到BeanDefinition里面</span></span><br><span class="line">                        bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, var9);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//反射实例化bean 可以看到参数是Object[0]</span></span><br><span class="line">            <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//这里是CGLIB实例化，不关注</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">        Assert.notNull(ctor, <span class="string">"Constructor must not be null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//小洋发现其实看了那么多，其实核心就这一句</span></span><br><span class="line">            ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">            <span class="keyword">return</span> ctor.newInstance(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor.getDeclaringClass(), <span class="string">"Is it an abstract class?"</span>, var3);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor.getDeclaringClass(), <span class="string">"Is the constructor accessible?"</span>, var4);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor.getDeclaringClass(), <span class="string">"Illegal arguments for constructor"</span>, var5);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(ctor.getDeclaringClass(), <span class="string">"Constructor threw exception"</span>, var6.getTargetException());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;看到这里已经看到了bean的实例化了。其实就是通过反射获取构造方法然后执行newInstance来实例化的。实例化就该干什么呢，属性注入了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">        BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(mbd.isSingleton()) &#123;</span><br><span class="line">            instanceWrapper = (BeanWrapper)<span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//上面这里就返回了bean的实例对象了。然后接着往下看</span></span><br><span class="line">            instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Object bean = instanceWrapper != <span class="keyword">null</span>?instanceWrapper.getWrappedInstance():<span class="keyword">null</span>;</span><br><span class="line">        Class beanType = instanceWrapper != <span class="keyword">null</span>?instanceWrapper.getWrappedClass():<span class="keyword">null</span>;</span><br><span class="line">        Object earlySingletonExposure = mbd.postProcessingLock;</span><br><span class="line">        <span class="keyword">synchronized</span>(mbd.postProcessingLock) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!mbd.postProcessed) &#123;</span><br><span class="line">                <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">                mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Object exposedObject = bean;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里是具体的对实例对象进行属性注入了。小洋进去看看</span></span><br><span class="line">            <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">            <span class="keyword">if</span>(exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">                exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">            <span class="keyword">if</span>(var17 <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException)var17).getBeanName())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (BeanCreationException)var17;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, var17);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractAutowireCapableBeanFactory.populateBean</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//首先获取解析出来的需要注入的属性，小洋叮嘱 这里只是我们xml文件配置bean的property。</span></span><br><span class="line">       Object pvs = mbd.getPropertyValues();</span><br><span class="line">       <span class="keyword">if</span>(bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span>(!((PropertyValues)pvs).isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//....... 省略部分代码</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">boolean</span> hasInstAwareBpps2 = <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">               <span class="keyword">boolean</span> needsDepCheck1 = mbd.getDependencyCheck() != <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span>(hasInstAwareBpps2 || needsDepCheck1) &#123;</span><br><span class="line">                   PropertyDescriptor[] filteredPds1 = <span class="keyword">this</span>.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">                   <span class="keyword">if</span>(hasInstAwareBpps2) &#123;</span><br><span class="line">                       <span class="comment">//这里获取BeanPostProcessors去处理属性注入。Spring会每个都去尝试</span></span><br><span class="line">                       Iterator var9 = <span class="keyword">this</span>.getBeanPostProcessors().iterator();</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">while</span>(var9.hasNext()) &#123;</span><br><span class="line">                           BeanPostProcessor bp = (BeanPostProcessor)var9.next();</span><br><span class="line">                           <span class="comment">//判断是不是用来处理自动注入的bean，也就是InstantiationAwareBeanPostProcessor</span></span><br><span class="line">                           <span class="keyword">if</span>(bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor)bp;</span><br><span class="line">                               <span class="comment">//这里调用方法去注入属性，这里有好多个具体的实现。</span></span><br><span class="line">                               <span class="comment">//比如AutowiredAnnotationBeanPostProcessor 专门处理 Autowired注解的</span></span><br><span class="line">                               <span class="comment">//比如CommonAnnotationBeanPostProcessor 专门处理Resource注解的</span></span><br><span class="line">                               <span class="comment">//这里小洋看了下Autowired的 因为平时用的多嘛，小洋叮嘱，这里只注入我们加了注解的，像在xml文件配置的bean属性注入，是不在这里处理的</span></span><br><span class="line">                               pvs = ibp.postProcessPropertyValues((PropertyValues)pvs, filteredPds1, bw.getWrappedInstance(), beanName);</span><br><span class="line">                               <span class="keyword">if</span>(pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                   <span class="keyword">return</span>;</span><br><span class="line">                               &#125;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span>(needsDepCheck1) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.checkDependencies(beanName, mbd, filteredPds1, (PropertyValues)pvs);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//处理xml文件配置的bean属性注入</span></span><br><span class="line">               <span class="keyword">this</span>.applyPropertyValues(beanName, mbd, bw, (PropertyValues)pvs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">//找到加了Autowired注解的信息。这个InjectionMetadata对象封装了这个bean里面所有加Autowired注解的元素信息</span></span><br><span class="line">        InjectionMetadata metadata = <span class="keyword">this</span>.findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//然后注入，这个方法会循环每一个InjectedElement，然后执行具体的inject方法</span></span><br><span class="line">            <span class="comment">//循环我们就不看了 我们直接看InjectionMetadata.InjectedElement.inject</span></span><br><span class="line">            metadata.inject(bean, beanName, pvs);</span><br><span class="line">            <span class="keyword">return</span> pvs;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var7) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Injection of autowired dependencies failed"</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InjectionMetadata.InjectedElement.inject</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, String requestingBeanName, PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">        <span class="comment">//注解加在成员变量上面，反射设置属性值</span></span><br><span class="line">        Field ex = (Field)<span class="keyword">this</span>.member;</span><br><span class="line">        ReflectionUtils.makeAccessible(ex);</span><br><span class="line">        ex.set(target, <span class="keyword">this</span>.getResourceToInject(target, requestingBeanName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//注解加在方法上面，反射调用方法</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.checkPropertySkipping(pvs)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method ex1 = (Method)<span class="keyword">this</span>.member;</span><br><span class="line">            ReflectionUtils.makeAccessible(ex1);</span><br><span class="line">            <span class="comment">//核心也就这么一句代码</span></span><br><span class="line">            ex1.invoke(target, <span class="keyword">new</span> Object[]&#123;<span class="keyword">this</span>.getResourceToInject(target, requestingBeanName)&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var5.getTargetException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面我们看了AutowiredAnnotationBeanPostProcessor的处理属性注入，其实其他的BeanPostProcessor处理都一样，都首先找到自己处理的注解的信息，构造成InjectionMetadata对象去处理。不同的地方就是查找注解的地方。注解的属性注入处理完了，对于xml文件配置bean属性的注入，小洋大概看了下，最后也是通过反射执行set方法初始化的。而且只有反射执行方法，所以xml配置的bean属性注入，必须有对应的set方法。不然会报错的。</p>
<p>&emsp;&emsp;小洋的这一番折腾，大概了解了Spring初始化的时候对bean的解析、实例化、属性注入等流程。虽然不是特别的详细，但是具体的流程还是走通的，期间收获不小。</p>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring bean（二）</title>
    <url>/2016/11/24/Spring-bean-two/</url>
    <content><![CDATA[<p>Spring bean 扫描注解初始化</p>
<p>&emsp;&emsp;天和日丽，阳光明媚，小洋接着看Spring bean。上篇文章我们说了，Spring初始化bean的时候有两种方式，一个是在xml里面配置<bean>相关内容。一个是用注解扫描。</bean></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultBeanDefinitionDocumentReader.parseBeanDefinitions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                    Element ele = (Element)node;</span><br><span class="line">                    <span class="keyword">if</span>(delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上次小洋看到这里的时候，进入的是parseDefaultElement这个方法，这个方法是处理默认命名空间的标签的，当我们配置扫描包的时候，比如context:component-scan base-package=”” 这个不是默认命名空间下的标签，他的命名空间是<a href="http://www.springframework.org/schema/context。" target="_blank" rel="noopener">http://www.springframework.org/schema/context。</a> 所以会进入parseCustomElement这个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BeanDefinitionParserDelegate.parseCustomElement</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">        String namespaceUri = <span class="keyword">this</span>.getNamespaceURI(ele);</span><br><span class="line">        NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">        <span class="keyword">if</span>(handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//具体的解析方法。交给NamespaceHandlerSupport去处理的。</span></span><br><span class="line">            <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NamespaceHandlerSupport.parse</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先根据而element找出合适的BeanDefinitionParser，然后在调用parse解析。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据element得的解析器的名称。小洋这里得到的是component-scan，这里很好理解配置的就是扫描包嘛</span></span><br><span class="line">       String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">       <span class="comment">//直接从map里面获取对应的BeanDefinition。spring这里给我初始化了8个具体的解析bean用的对象。</span></span><br><span class="line">       <span class="comment">//具体的看下面的debug图，这里我们是ComponentScanBeanDefinitionParser这个解析.</span></span><br><span class="line">       BeanDefinitionParser parser = (BeanDefinitionParser)<span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">       <span class="keyword">if</span>(parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">           parserContext.getReaderContext().fatal(<span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> parser;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/QQ20161128-0.png" alt="Alt text"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ComponentScanBeanDefinitionParser.parse</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取配置的package</span></span><br><span class="line">        String basePackage = element.getAttribute(<span class="string">"base-package"</span>);</span><br><span class="line">        basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">        <span class="comment">//将配置的对个package放到String数组里面</span></span><br><span class="line">        String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, <span class="string">",; \t\n"</span>);</span><br><span class="line">        <span class="comment">//新建一个ClassPathBeanDefinitionScanner。</span></span><br><span class="line">        ClassPathBeanDefinitionScanner scanner = <span class="keyword">this</span>.configureScanner(parserContext, element);</span><br><span class="line">        <span class="comment">//去扫描包了。具体看这里</span></span><br><span class="line">        Set beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">        <span class="keyword">this</span>.registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassPathBeanDefinitionScanner.doScan</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">        LinkedHashSet beanDefinitions = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        String[] var3 = basePackages;</span><br><span class="line">        <span class="keyword">int</span> var4 = basePackages.length;</span><br><span class="line">        <span class="comment">//扫描配置的每个package</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">            String basePackage = var3[var5];</span><br><span class="line">            <span class="comment">//根据名称我们就能看到找到候选人，就是加Components注解的bean。核心</span></span><br><span class="line">            Set candidates = <span class="keyword">this</span>.findCandidateComponents(basePackage);</span><br><span class="line">            Iterator var8 = candidates.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">                BeanDefinition candidate = (BeanDefinition)var8.next();</span><br><span class="line">                ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">                candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">                String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">                <span class="comment">//根据不同的类型去做不同的处理</span></span><br><span class="line">                <span class="keyword">if</span>(candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.postProcessBeanDefinition((AbstractBeanDefinition)candidate, beanName);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                    AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition)candidate);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">this</span>.checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                   <span class="comment">//封装成BeanDefinitionHolder</span></span><br><span class="line">                    BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                    beanDefinitions.add(definitionHolder);</span><br><span class="line">                    <span class="comment">//注册到beanFactory</span></span><br><span class="line">                    <span class="keyword">this</span>.registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassPathBeanDefinitionScanner.findCandidateComponents</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;BeanDefinition&gt; <span class="title">findCandidateComponents</span><span class="params">(String basePackage)</span> </span>&#123;</span><br><span class="line">        LinkedHashSet candidates = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String ex = <span class="string">"classpath*:"</span> + <span class="keyword">this</span>.resolveBasePackage(basePackage) + <span class="string">"/"</span> + <span class="keyword">this</span>.resourcePattern;</span><br><span class="line">            <span class="comment">//这里去获取package包下面的class资源，核心，接着看</span></span><br><span class="line">            Resource[] resources = <span class="keyword">this</span>.resourcePatternResolver.getResources(ex);</span><br><span class="line">            <span class="keyword">boolean</span> traceEnabled = <span class="keyword">this</span>.logger.isTraceEnabled();</span><br><span class="line">            <span class="keyword">boolean</span> debugEnabled = <span class="keyword">this</span>.logger.isDebugEnabled();</span><br><span class="line">            Resource[] var7 = resources;</span><br><span class="line">            <span class="keyword">int</span> var8 = resources.length;</span><br><span class="line">            <span class="comment">//循环每个class资源</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var9 = <span class="number">0</span>; var9 &lt; var8; ++var9) &#123;</span><br><span class="line">                Resource resource = var7[var9];</span><br><span class="line">                <span class="keyword">if</span>(traceEnabled) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Scanning "</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(resource.isReadable()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//这里通过ASM去解析class文件。</span></span><br><span class="line">                        MetadataReader ex1 = <span class="keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);</span><br><span class="line">                        <span class="comment">//判断是是否有Component注解</span></span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span>.isCandidateComponent(ex1)) &#123;</span><br><span class="line">                            ScannedGenericBeanDefinition sbd = <span class="keyword">new</span> ScannedGenericBeanDefinition(ex1);</span><br><span class="line">                            sbd.setResource(resource);</span><br><span class="line">                            sbd.setSource(resource);</span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">this</span>.isCandidateComponent((AnnotatedBeanDefinition)sbd)) &#123;</span><br><span class="line">                                <span class="keyword">if</span>(debugEnabled) &#123;</span><br><span class="line">                                    <span class="keyword">this</span>.logger.debug(<span class="string">"Identified candidate component class: "</span> + resource);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//加入到候选人集合</span></span><br><span class="line">                                candidates.add(sbd);</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(debugEnabled) &#123;</span><br><span class="line">                                <span class="keyword">this</span>.logger.debug(<span class="string">"Ignored because not a concrete top-level class: "</span> + resource);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(traceEnabled) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.logger.trace(<span class="string">"Ignored because not matching any filter: "</span> + resource);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var13) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Failed to read candidate component class: "</span> + resource, var13);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(traceEnabled) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.logger.trace(<span class="string">"Ignored because not readable: "</span> + resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> candidates;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"I/O failure during classpath scanning"</span>, var14);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PathMatchingResourcePatternResolver.doFindAllClassPathResources</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;Resource&gt; <span class="title">doFindAllClassPathResources</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        LinkedHashSet result = <span class="keyword">new</span> LinkedHashSet(<span class="number">16</span>);</span><br><span class="line">        ClassLoader cl = <span class="keyword">this</span>.getClassLoader();</span><br><span class="line">        <span class="comment">//这里通过classLoader去加载资源。</span></span><br><span class="line">        Enumeration resourceUrls = cl != <span class="keyword">null</span>?cl.getResources(path):ClassLoader.getSystemResources(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(resourceUrls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = (URL)resourceUrls.nextElement();</span><br><span class="line">            result.add(<span class="keyword">this</span>.convertClassLoaderURL(url));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(path)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addAllClassLoaderJarRoots(cl, result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;小洋这就看完了处理非默认命名空间的元素解析，这里具体用component-scan这个标签来举例说的，Spring针对不同的标签，会用具体的对象去处理解析，改天再去看看其他标签的解析。小洋这里要嘱咐一下，这里我们不管是配置的bean还是扫描的bean，现在在Spring里面就只是一个java对象的数据结构BeanDefinition,并没有实例化。</p>
<hr>
<p align="center"><font color="blue">笨蛋自以为聪明，聪明人才知道自己是笨蛋。</font></p><p align="right"> —— 莎士比亚</p>

<hr>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring bean（一）</title>
    <url>/2016/11/24/Spring-bean/</url>
    <content><![CDATA[<p>Spring bean 配置文件初始化</p>
<p>&emsp;&emsp;Spring框架基础之模块-IOC，主要提供了依赖注入的实现。甚为重要，小洋闲来无事，再此专研一番。记之、</p>
<h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><p>&emsp;&emsp;1.  新建一个maven项目，导入最基本的spring包依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rpc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxx.rpc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-bean-init<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;写个一简单的bean类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;3.  新建spring.xml文件，配置一下User。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.lty.bean"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.lty.bean.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userName"</span> <span class="attr">value</span>=<span class="string">"LTY"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"PASSWORD"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;4.  写个启动类，加载spring.xml文件，并获取配置的bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"spring.xml"</span>).getBean(<span class="string">"user"</span>,User<span class="class">.<span class="keyword">class</span>).<span class="title">toString</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ouptput: User&#123;userName='LTY', password='PASSWORD'&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单设想"><a href="#简单设想" class="headerlink" title="简单设想"></a>简单设想</h3><p>&emsp;&emsp;上面是很简单的Spring用法，可以看到小洋自定义的bean已经交给Spring管理了，看输出结果属性的值也初始化了。小洋默默深思，这一切是怎么发生的呢，在Java的世界里能通过运行时去加载的类的，也就只有反射了。是不是通过标签的class属性去加载User，然后在根据配置的属性通过反射设置进去呢。为了解决这个疑问和设想，小洋开始了源码之旅。</p>
<h3 id="源码之旅"><a href="#源码之旅" class="headerlink" title="源码之旅"></a>源码之旅</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassPathXmlApplicationContext构造方法。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="comment">//设置配置文件的位置。</span></span><br><span class="line">        <span class="keyword">this</span>.setConfigLocations(configLocations);</span><br><span class="line">        <span class="keyword">if</span>(refresh) &#123;</span><br><span class="line">            <span class="comment">//核心方法</span></span><br><span class="line">            <span class="keyword">this</span>.refresh();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassPathXmlApplicationContext.refresh()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">        Object var1 = <span class="keyword">this</span>.startupShutdownMonitor;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">            <span class="comment">//这个是做一些准备工作，打打日志啊，获取一下环境啊什么的，没有做什么重要的事情，不关注</span></span><br><span class="line">            <span class="keyword">this</span>.prepareRefresh();</span><br><span class="line">            <span class="comment">//初始化一个beanFactory，这个beanFactory很重要，核心的东东。看看他都干了什么。</span></span><br><span class="line">            ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.obtainFreshBeanFactory();</span><br><span class="line">            <span class="keyword">this</span>.prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//下面这些方法是Spring初始化需要做的一些事情，小洋只是想看看bean的初始化</span></span><br><span class="line">                <span class="comment">//下面好多方法是不会讲的。等那天小洋闲了在来看看。小洋只会讲finishBeanFactoryInitialization</span></span><br><span class="line">                <span class="comment">//他是bean实例化的一个过程。不过先来看看beanFactory吧。</span></span><br><span class="line">                <span class="keyword">this</span>.postProcessBeanFactory(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.registerBeanPostProcessors(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.initMessageSource();</span><br><span class="line">                <span class="keyword">this</span>.initApplicationEventMulticaster();</span><br><span class="line">                <span class="keyword">this</span>.onRefresh();</span><br><span class="line">                <span class="keyword">this</span>.registerListeners();</span><br><span class="line">                <span class="keyword">this</span>.finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">                <span class="keyword">this</span>.finishRefresh();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException var5) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">"Exception encountered during context initialization - cancelling refresh attempt"</span>, var5);</span><br><span class="line">                <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">                <span class="keyword">this</span>.cancelRefresh(var5);</span><br><span class="line">                <span class="keyword">throw</span> var5;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassPathXmlApplicationContext.obtainFreshBeanFactory</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//核心方法，初始化beanFactory,这个方法是抽象方法，具体的实现是AbstractRefreshableApplicationContext</span></span><br><span class="line">        <span class="keyword">this</span>.refreshBeanFactory();</span><br><span class="line">        <span class="comment">//这里this.getBeanFactory获取上一步初始化的beanFactory，和这个方法也是抽象的，具体实现和上面一样</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = <span class="keyword">this</span>.getBeanFactory();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Bean factory for "</span> + <span class="keyword">this</span>.getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractRefreshableApplicationContext.refreshBeanFactory</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasBeanFactory()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.destroyBeans();</span><br><span class="line">            <span class="keyword">this</span>.closeBeanFactory();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里创建了一个beanFactory,代码就不用看了直接new DefaultListableBeanFactory这个对象的。</span></span><br><span class="line">            DefaultListableBeanFactory ex = <span class="keyword">this</span>.createBeanFactory();</span><br><span class="line">            ex.setSerializationId(<span class="keyword">this</span>.getId());</span><br><span class="line">            <span class="comment">//这个方法是设置初始化bean的一些策略，相同的bean是否允许覆盖，是否允许循环引用</span></span><br><span class="line">            <span class="keyword">this</span>.customizeBeanFactory(ex);</span><br><span class="line">            <span class="comment">//这个是核心方法，一个bean的配置在Spring内部结构就是BeanDefinition对象，下面看怎么加载的</span></span><br><span class="line">            <span class="comment">//这个调用很长我直接给出最终的调用方法，中间都是些无关紧要的跳转。</span></span><br><span class="line">            <span class="keyword">this</span>.loadBeanDefinitions(ex);</span><br><span class="line">            Object var2 = <span class="keyword">this</span>.beanFactoryMonitor;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">                <span class="comment">//然后设置一下给成员变量。</span></span><br><span class="line">                <span class="keyword">this</span>.beanFactory = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + <span class="keyword">this</span>.getDisplayName(), var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultBeanDefinitionDocumentReader.doRegisterBeanDefinitions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个代理对象去解析bean</span></span><br><span class="line">        BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">        <span class="keyword">this</span>.delegate = <span class="keyword">this</span>.createDelegate(<span class="keyword">this</span>.getReaderContext(), root, parent);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            String profileSpec = root.getAttribute(<span class="string">"profile"</span>);</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                String[] specifiedProfiles = StringUtils.tokenizeToStringArray(profileSpec, <span class="string">",; "</span>);</span><br><span class="line">                <span class="keyword">if</span>(!<span class="keyword">this</span>.getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//预处理xml</span></span><br><span class="line">        <span class="keyword">this</span>.preProcessXml(root);</span><br><span class="line">        <span class="comment">//解析bean，核心方法。</span></span><br><span class="line">        <span class="keyword">this</span>.parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">        <span class="comment">//后处理xml</span></span><br><span class="line">        <span class="keyword">this</span>.postProcessXml(root);</span><br><span class="line">        <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultBeanDefinitionDocumentReader.parseBeanDefinitions</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里root是xml解析后的根元素，判断是否是默认的命名空间。也就是http://www.springframework.org/schema/beans</span></span><br><span class="line">        <span class="comment">//仔细看xml文件就能发现这个命名空间是配置bean相关的，比如&lt;bean&gt;&lt;import&gt;&lt;alias&gt;&lt;description&gt;等标签</span></span><br><span class="line">        <span class="keyword">if</span>(delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">            NodeList nl = root.getChildNodes();</span><br><span class="line">            <span class="comment">//循环去解析xml配置的标签</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); ++i) &#123;</span><br><span class="line">                Node node = nl.item(i);</span><br><span class="line">                <span class="keyword">if</span>(node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                    Element ele = (Element)node;</span><br><span class="line">                    <span class="keyword">if</span>(delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                        <span class="comment">//处理默认的命名空间，我们在前期准备中是通过配置&lt;bean&gt;，是默认的命名空间下的标签，所以这里进入是这个方法。</span></span><br><span class="line">                        <span class="keyword">this</span>.parseDefaultElement(ele, delegate);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//处理自定义的 比如我们常用的http://www.springframework.org/schema/context</span></span><br><span class="line">                        <span class="comment">//&lt;context:component-scan base-package="com.xxx.rpc.sample.server"/&gt;</span></span><br><span class="line">                        <span class="comment">//这个就是扫描包的配置。我们列举这一个命名空间的解析。后面文章会讲到。</span></span><br><span class="line">                        delegate.parseCustomElement(ele);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            delegate.parseCustomElement(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上我们可以看到，当解析到具体的某个标签的时候，Spring有两个分支，自定义和默认的。很好理解我们可以通过在xml文件配置<bean>来让Spring初始化，也可以什么都不写直接在类上面加Component注解就行，然后在xml文件指定一些Spring的扫描路径。下面我先看通过<bean>配置的解析。</bean></bean></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultBeanDefinitionDocumentReader.parseDefaultElement</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(delegate.nodeNameEquals(ele, <span class="string">"import"</span>)) &#123;</span><br><span class="line">            <span class="comment">//处理import标签</span></span><br><span class="line">            <span class="keyword">this</span>.importBeanDefinitionResource(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(delegate.nodeNameEquals(ele, <span class="string">"alias"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.processAliasRegistration(ele);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(delegate.nodeNameEquals(ele, <span class="string">"bean"</span>)) &#123;</span><br><span class="line">            <span class="comment">//处理bean标签，我们看这个方法。</span></span><br><span class="line">            <span class="keyword">this</span>.processBeanDefinition(ele, delegate);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(delegate.nodeNameEquals(ele, <span class="string">"beans"</span>)) &#123;</span><br><span class="line">            <span class="comment">//处理beans标签</span></span><br><span class="line">            <span class="keyword">this</span>.doRegisterBeanDefinitions(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DefaultBeanDefinitionDocumentReader.processBeanDefinition</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过代理去解析bean标签，然后组装成BeanDefinitionHolder，这个BeanDefinitionHolder是BeanDefinition的包装类。</span></span><br><span class="line">        BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">        <span class="keyword">if</span>(bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//讲上面解析到的BeanDefinition注册到beanFactory当中。最开始我们创建的DefaultListableBeanFactory有个成员变量</span></span><br><span class="line">                <span class="comment">//private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap(64);</span></span><br><span class="line">                <span class="comment">//这里的注册就是讲解析出来的BeanDefinition放入到这个map当中，这个map后面我们实例化bean的时候会用到。切记我们解析</span></span><br><span class="line">                <span class="comment">//出来的BeanDefinition不是bean的实例对象，只是把bean标签里面的内容，以Java对象的数据结构来表示。</span></span><br><span class="line">                BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, <span class="keyword">this</span>.getReaderContext().getRegistry());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException var5) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getReaderContext().error(<span class="string">"Failed to register bean definition with name \'"</span> + bdHolder.getBeanName() + <span class="string">"\'"</span>, ele, var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BeanDefinitionParserDelegate.parseBeanDefinitionElement</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//小洋看到这里，看到了希望，走了那么远，终于看见&lt;bean&gt;里面的id啊name了。这里就是解析了</span></span><br><span class="line">        String id = ele.getAttribute(<span class="string">"id"</span>);</span><br><span class="line">        String nameAttr = ele.getAttribute(<span class="string">"name"</span>);</span><br><span class="line">        ArrayList aliases = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">            String[] beanName = StringUtils.tokenizeToStringArray(nameAttr, <span class="string">",; "</span>);</span><br><span class="line">            aliases.addAll(Arrays.asList(beanName));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String beanName1 = id;</span><br><span class="line">        <span class="keyword">if</span>(!StringUtils.hasText(id) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">            beanName1 = (String)aliases.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"No XML \'id\' specified - using \'"</span> + beanName1 + <span class="string">"\' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//检查一下bean名称是否重复啊</span></span><br><span class="line">            <span class="keyword">this</span>.checkNameUniqueness(beanName1, aliases, ele);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里解析配置&lt;bean&gt;里面属性。这里是关键。</span></span><br><span class="line">        AbstractBeanDefinition beanDefinition = <span class="keyword">this</span>.parseBeanDefinitionElement(ele, beanName1, containingBean);</span><br><span class="line">        <span class="keyword">if</span>(beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!StringUtils.hasText(beanName1)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanName1 = BeanDefinitionReaderUtils.generateBeanName(beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        beanName1 = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                        String aliasesArray = beanDefinition.getBeanClassName();</span><br><span class="line">                        <span class="keyword">if</span>(aliasesArray != <span class="keyword">null</span> &amp;&amp; beanName1.startsWith(aliasesArray) &amp;&amp; beanName1.length() &gt; aliasesArray.length() &amp;&amp; !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(aliasesArray)) &#123;</span><br><span class="line">                            aliases.add(aliasesArray);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.logger.debug(<span class="string">"Neither XML \'id\' nor \'name\' specified - using generated bean name ["</span> + beanName1 + <span class="string">"]"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception var9) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.error(var9.getMessage(), ele);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String[] aliasesArray1 = StringUtils.toStringArray(aliases);</span><br><span class="line">            <span class="comment">//然后包装beanDefinition</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName1, aliasesArray1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//这里就是解析的最底层了，小洋喝了杯水，看了看天空的月亮，看见了嫦娥。</span></span><br><span class="line">        <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line">        String className = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(ele.hasAttribute(<span class="string">"class"</span>)) &#123;</span><br><span class="line">            className = ele.getAttribute(<span class="string">"class"</span>).trim();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String ex = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(ele.hasAttribute(<span class="string">"parent"</span>)) &#123;</span><br><span class="line">                ex = ele.getAttribute(<span class="string">"parent"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建BeanDefinition对象，用来封装解析处理的数据。</span></span><br><span class="line">            AbstractBeanDefinition bd = <span class="keyword">this</span>.createBeanDefinition(className, ex);</span><br><span class="line">            <span class="comment">//解析属性，这里就是解析我们配置singleton啊scope啊lazy-init啊这些等等。</span></span><br><span class="line">            <span class="keyword">this</span>.parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">            <span class="comment">//设置描述</span></span><br><span class="line">            bd.setDescription(DomUtils.getChildElementValueByTagName(ele, <span class="string">"description"</span>));</span><br><span class="line">            <span class="comment">//解析meta标签</span></span><br><span class="line">            <span class="keyword">this</span>.parseMetaElements(ele, bd);</span><br><span class="line">            <span class="comment">//解析lookup-method标签</span></span><br><span class="line">            <span class="keyword">this</span>.parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">            <span class="comment">//机械replaced-method标签</span></span><br><span class="line">            <span class="keyword">this</span>.parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">            <span class="comment">//解析构造函数的参数</span></span><br><span class="line">            <span class="keyword">this</span>.parseConstructorArgElements(ele, bd);</span><br><span class="line">            <span class="comment">//解析property，我们要注入的属性值</span></span><br><span class="line">            <span class="keyword">this</span>.parsePropertyElements(ele, bd);</span><br><span class="line">            <span class="comment">//解析qualifier标签</span></span><br><span class="line">            <span class="keyword">this</span>.parseQualifierElements(ele, bd);</span><br><span class="line">            bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">            bd.setSource(<span class="keyword">this</span>.extractSource(ele));</span><br><span class="line">            AbstractBeanDefinition var7 = bd;</span><br><span class="line">            <span class="keyword">return</span> var7;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var13) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, var13);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError var14) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, var14);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var15) &#123;</span><br><span class="line">            <span class="keyword">this</span>.error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, var15);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;到此bean解析成BeanDefinition数据对象，就到此结束了，小洋也感觉到筋疲力尽了，但感觉还是很有成就感的，正准备歇息一番，突然一想，不妙啊，这里只是把bean标签解析成了BeanDefinition对象，可是我们getBean拿到的是一个实例对象啊。还有上面只看到了配置bean处理，还没有看扫描注解包的处理。小洋对此只能仰天长叹，道路还很长啊。后面看小洋如何披荆斩棘，雄霸天下。</p>
<hr>
<p align="center"><font color="blue">我读的书愈多，就愈亲近世界，愈明了生活的意义，愈觉得生活的重要。</font></p><p align="right"> —— 高尔基</p>

<hr>
]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink执行流程五</title>
    <url>/2024/09/04/Flink%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%BA%94/</url>
    <content><![CDATA[<h2 id="1-数据流转——Flink的数据抽象及数据交换过程"><a href="#1-数据流转——Flink的数据抽象及数据交换过程" class="headerlink" title="1.数据流转——Flink的数据抽象及数据交换过程"></a>1.数据流转——Flink的数据抽象及数据交换过程</h2><h3 id="1-1-MemorySegment"><a href="#1-1-MemorySegment" class="headerlink" title="1.1 MemorySegment"></a>1.1 MemorySegment</h3><p>Flink作为一个高效的流框架，为了避免JVM的固有缺陷（java对象存储密度低，FGC影响吞吐和响应等），必然走上自主管理内存的道路。</p>
<p>这个MemorySegment就是Flink的内存抽象。默认情况下，一个MemorySegment可以被看做是一个32kb大的内存块的抽象。这块内存既可以是JVM里的一个byte[]，也可以是堆外内存（DirectByteBuffer）。</p>
<p>如果说byte[]数组和direct memory是最底层的存储，那么memorysegment就是在其上覆盖的一层统一抽象。它定义了一系列抽象方法，用于控制和底层内存的交互，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MemorySegment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，它在提供了诸多直接操作内存的方法外，还提供了一个wrap()方法，将自己包装成一个ByteBuffer，我们待会儿讲这个ByteBuffer。</p>
<p>Flink为MemorySegment提供了两个实现类：HeapMemorySegment和HybridMemorySegment。他们的区别在于前者只能分配堆内存，而后者能用来分配堆内和堆外内存。事实上，Flink框架里，只使用了后者。这是为什么呢？</p>
<p>如果HybridMemorySegment只能用于分配堆外内存的话，似乎更合常理。但是在JVM的世界中，如果一个方法是一个虚方法，那么每次调用时，JVM都要花时间去确定调用的到底是哪个子类实现的该虚方法（方法重写机制，不明白的去看JVM的invokeVirtual指令），也就意味着每次都要去翻方法表；而如果该方法虽然是个虚方法，但实际上整个JVM里只有一个实现（就是说只加载了一个子类进来），那么JVM会很聪明的把它去虚化处理，这样就不用每次调用方法时去找方法表了，能够大大提升性能。但是只分配堆内或者堆外内存不能满足我们的需要，所以就出现了HybridMemorySegment同时可以分配两种内存的设计。</p>
<p>我们可以看看HybridMemorySegment的构造代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HybridMemorySegment(ByteBuffer buffer, Object owner) &#123;</span><br><span class="line">	<span class="keyword">super</span>(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);</span><br><span class="line">	<span class="keyword">this</span>.offHeapBuffer = buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	HybridMemorySegment(<span class="keyword">byte</span>[] buffer, Object owner) &#123;</span><br><span class="line">	<span class="keyword">super</span>(buffer, owner);</span><br><span class="line">	<span class="keyword">this</span>.offHeapBuffer = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，第一个构造函数的checkBufferAndGetAddress()方法能够得到direct buffer的内存地址，因此可以操作堆外内存。</p>
<h3 id="1-2-ByteBuffer与NetworkBufferPool"><a href="#1-2-ByteBuffer与NetworkBufferPool" class="headerlink" title="1.2 ByteBuffer与NetworkBufferPool"></a>1.2 ByteBuffer与NetworkBufferPool</h3><p>在MemorySegment这个抽象之上，Flink在数据从operator内的数据对象在向TaskManager上转移，预备被发给下个节点的过程中，使用的抽象或者说内存对象是Buffer。</p>
<p><strong>注意</strong>：这个Buffer是个flink接口，不是java.nio提供的那个Buffer抽象类。Flink在这一层面同时使用了这两个同名概念，用来存储对象，直接看代码时到处都是各种xxxBuffer很容易混淆：</p>
<ul>
<li>java提供的那个Buffer抽象类在这一层主要用于构建HeapByteBuffer，这个主要是当数据从jvm里的一个对象被序列化成字节数组时用的；</li>
<li>Flink的这个Buffer接口主要是一种flink层面用于传输数据和事件的统一抽象，其实现类是NetworkBuffer，是对MemorySegment的包装。Flink在各个TaskManager之间传递数据时，使用的是这一层的抽象。</li>
</ul>
<p>因为Buffer的底层是MemorySegment，这可能不是JVM所管理的，所以为了知道什么时候一个Buffer用完了可以回收，Flink引入了引用计数的概念，当确认这个buffer没有人引用，就可以回收这一片MemorySegment用于别的地方了（JVM的垃圾回收为啥不用引用计数？读者思考一下）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractReferenceCountedByteBuf</span> <span class="keyword">extends</span> <span class="title">AbstractByteBuf</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> refCnt = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便管理NetworkBuffer，Flink提供了BufferPoolFactory，并且提供了唯一实现NetworkBufferPool，这是个工厂模式的应用。</p>
<p>NetworkBufferPool在每个TaskManager上只有一个，负责所有子task的内存管理。其实例化时就会尝试获取所有可由它管理的内存（对于堆内存来说，直接获取所有内存并放入老年代，并令用户对象只在新生代存活，可以极大程度的减少Full GC），我们看看其构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NetworkBufferPool</span><span class="params">(<span class="keyword">int</span> numberOfSegmentsToAllocate, <span class="keyword">int</span> segmentSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.availableMemorySegments = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(numberOfSegmentsToAllocate);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (OutOfMemoryError err) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Could not allocate buffer queue of length "</span></span><br><span class="line">					+ numberOfSegmentsToAllocate + <span class="string">" - "</span> + err.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfSegmentsToAllocate; i++) &#123;</span><br><span class="line">				ByteBuffer memory = ByteBuffer.allocateDirect(segmentSize);</span><br><span class="line">				availableMemorySegments.add(MemorySegmentFactory.wrapPooledOffHeapMemory(memory, <span class="keyword">null</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> allocatedMb = (sizeInLong * availableMemorySegments.size()) &gt;&gt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">		LOG.info(<span class="string">"Allocated &#123;&#125; MB for network buffer pool (number of memory segments: &#123;&#125;, bytes per segment: &#123;&#125;)."</span>,</span><br><span class="line">				allocatedMb, availableMemorySegments.size(), segmentSize);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>由于NetworkBufferPool只是个工厂，实际的内存池是LocalBufferPool。每个TaskManager都只有一个NetworkBufferPool工厂，但是上面运行的每个task都要有一个和其他task隔离的LocalBufferPool池，这从逻辑上很好理解。另外，NetworkBufferPool会计算自己所拥有的所有内存分片数，在分配新的内存池时对每个内存池应该占有的内存分片数重分配，步骤是：</p>
<ul>
<li>首先，从整个工厂管理的内存片中拿出所有的内存池所需要的最少Buffer数目总和</li>
<li>如果正好分配完，就结束</li>
<li>其次，把所有的剩下的没分配的内存片，按照每个LocalBufferPool内存池的剩余想要容量大小进行按比例分配</li>
<li>剩余想要容量大小是这么个东西：如果该内存池至少需要3个buffer，最大需要10个buffer，那么它的剩余想要容量就是7</li>
</ul>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">redistributeBuffers</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">assert</span> Thread.holdsLock(factoryLock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All buffers, which are not among the required ones</span></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (numAvailableMemorySegment == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// in this case, we need to redistribute buffers so that every pool gets its minimum</span></span><br><span class="line">		<span class="keyword">for</span> (LocalBufferPool bufferPool : allBufferPools) &#123;</span><br><span class="line">			bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> totalCapacity = <span class="number">0</span>; <span class="comment">// long to avoid int overflow</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (LocalBufferPool bufferPool : allBufferPools) &#123;</span><br><span class="line">		<span class="keyword">int</span> excessMax = bufferPool.getMaxNumberOfMemorySegments() -</span><br><span class="line">			bufferPool.getNumberOfRequiredMemorySegments();</span><br><span class="line">		totalCapacity += Math.min(numAvailableMemorySegment, excessMax);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// no capacity to receive additional buffers?</span></span><br><span class="line">	<span class="keyword">if</span> (totalCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// necessary to avoid div by zero when nothing to re-distribute</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> memorySegmentsToDistribute = MathUtils.checkedDownCast(</span><br><span class="line">			Math.min(numAvailableMemorySegment, totalCapacity));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> totalPartsUsed = <span class="number">0</span>; <span class="comment">// of totalCapacity</span></span><br><span class="line">	<span class="keyword">int</span> numDistributedMemorySegment = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (LocalBufferPool bufferPool : allBufferPools) &#123;</span><br><span class="line">		<span class="keyword">int</span> excessMax = bufferPool.getMaxNumberOfMemorySegments() -</span><br><span class="line">			bufferPool.getNumberOfRequiredMemorySegments();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// shortcut</span></span><br><span class="line">		<span class="keyword">if</span> (excessMax == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> mySize = MathUtils.checkedDownCast(</span><br><span class="line">				memorySegmentsToDistribute * totalPartsUsed / totalCapacity - numDistributedMemorySegment);</span><br><span class="line"></span><br><span class="line">		numDistributedMemorySegment += mySize;</span><br><span class="line">		bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">assert</span> (totalPartsUsed == totalCapacity);</span><br><span class="line">	<span class="keyword">assert</span> (numDistributedMemorySegment == memorySegmentsToDistribute);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来说说这个LocalBufferPool内存池。<br>LocalBufferPool的逻辑想想无非是增删改查，值得说的是其fields：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 该内存池需要的最少内存片数目*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfRequiredMemorySegments;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前已经获得的内存片中，还没有写入数据的空白内存片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;MemorySegment&gt; availableMemorySegments = <span class="keyword">new</span> ArrayDeque&lt;MemorySegment&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册的所有监控buffer可用性的监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;BufferListener&gt; registeredListeners = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 能给内存池分配的最大分片数*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxNumberOfMemorySegments;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 当前内存池大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> currentPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有经由NetworkBufferPool分配的，被本内存池引用到的（非直接获得的）分片数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> numberOfRequestedMemorySegments;</span><br></pre></td></tr></table></figure>
<p>承接NetworkBufferPool的重分配方法，我们来看看LocalBufferPool的setNumBuffers方法，代码很短，逻辑也相当简单，就不展开说了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumBuffers</span><span class="params">(<span class="keyword">int</span> numBuffers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (availableMemorySegments) &#123;</span><br><span class="line">		checkArgument(numBuffers &gt;= numberOfRequiredMemorySegments,</span><br><span class="line">				<span class="string">"Buffer pool needs at least %s buffers, but tried to set to %s"</span>,</span><br><span class="line">				numberOfRequiredMemorySegments, numBuffers);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (numBuffers &gt; maxNumberOfMemorySegments) &#123;</span><br><span class="line">			currentPoolSize = maxNumberOfMemorySegments;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			currentPoolSize = numBuffers;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		returnExcessMemorySegments();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If there is a registered owner and we have still requested more buffers than our</span></span><br><span class="line">		<span class="comment">// size, trigger a recycle via the owner.</span></span><br><span class="line">		<span class="keyword">if</span> (owner != <span class="keyword">null</span> &amp;&amp; numberOfRequestedMemorySegments &gt; currentPoolSize) &#123;</span><br><span class="line">			owner.releaseMemory(numberOfRequestedMemorySegments - numBuffers);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-RecordWriter与Record"><a href="#1-3-RecordWriter与Record" class="headerlink" title="1.3 RecordWriter与Record"></a>1.3 RecordWriter与Record</h3><p>我们接着往高层抽象走，刚刚提到了最底层内存抽象是MemorySegment，用于数据传输的是Buffer，那么，承上启下对接从Java对象转为Buffer的中间对象是什么呢？是StreamRecord。</p>
<p>从StreamRecord<t>这个类名字就可以看出来，这个类就是个wrap，里面保存了原始的Java对象。另外，StreamRecord还保存了一个timestamp。</t></p>
<p>那么这个对象是怎么变成LocalBufferPool内存池里的一个大号字节数组的呢？借助了StreamWriter这个类。</p>
<p>我们直接来看把数据序列化交出去的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">(T record, <span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">	RecordSerializer&lt;T&gt; serializer = serializers[targetChannel];</span><br><span class="line"></span><br><span class="line">	SerializationResult result = serializer.addRecord(record);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (result.isFullBuffer()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tryFinishCurrentBufferBuilder(targetChannel, serializer)) &#123;</span><br><span class="line">			<span class="comment">// If this was a full record, we are done. Not breaking</span></span><br><span class="line">			<span class="comment">// out of the loop at this point will lead to another</span></span><br><span class="line">			<span class="comment">// buffer request before breaking out (that would not be</span></span><br><span class="line">			<span class="comment">// a problem per se, but it can lead to stalls in the</span></span><br><span class="line">			<span class="comment">// pipeline).</span></span><br><span class="line">			<span class="keyword">if</span> (result.isFullRecord()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		BufferBuilder bufferBuilder = requestNewBufferBuilder(targetChannel);</span><br><span class="line"></span><br><span class="line">		result = serializer.continueWritingWithNextBufferBuilder(bufferBuilder);</span><br><span class="line">	&#125;</span><br><span class="line">	checkState(!serializer.hasSerializedData(), <span class="string">"All data should be written at once"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flushAlways) &#123;</span><br><span class="line">		targetPartition.flush(targetChannel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先说最后一行，如果配置为flushAlways，那么会立刻把元素发送出去，但是这样吞吐量会下降；Flink的默认设置其实也不是一个元素一个元素的发送，是单独起了一个线程，每隔固定时间flush一次所有channel，较真起来也算是mini batch了。</p>
<p>再说序列化那一句:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SerializationResult result = serializer.addRecord(record);</span><br></pre></td></tr></table></figure>
<p>在这行代码中，Flink把对象调用该对象所属的序列化器序列化为字节数组。</p>
<h3 id="1-4-数据流转过程"><a href="#1-4-数据流转过程" class="headerlink" title="1.4 数据流转过程"></a>1.4 数据流转过程</h3><p>上一节讲了各层数据的抽象，这一节讲讲数据在各个task之间exchange的过程。</p>
<h4 id="1-4-1-整体过程"><a href="#1-4-1-整体过程" class="headerlink" title="1.4.1 整体过程"></a>1.4.1 整体过程</h4><p>看这张图：<br><img src="/img/image_1cetavukjja42ce1261v5k57i9.png" alt="image_1cetavukjja42ce1261v5k57i9.png-821.8kB"></p>
<ol>
<li>第一步必然是准备一个ResultPartition；</li>
<li>通知JobMaster；</li>
<li>JobMaster通知下游节点；如果下游节点尚未部署，则部署之；</li>
<li>下游节点向上游请求数据</li>
<li>开始传输数据</li>
</ol>
<h4 id="1-4-2-数据跨task传递"><a href="#1-4-2-数据跨task传递" class="headerlink" title="1.4.2 数据跨task传递"></a>1.4.2 数据跨task传递</h4><p>本节讲一下算子之间具体的数据传输过程。也先上一张图：<br><img src="/img/image_1cfmpba9v15anggtvsba2o1277m.png" alt="image_1cfmpba9v15anggtvsba2o1277m.png-357.5kB"><br>数据在task之间传递有如下几步：</p>
<ol>
<li>数据在本operator处理完后，交给RecordWriter。每条记录都要选择一个下游节点，所以要经过ChannelSelector。</li>
<li>每个channel都有一个serializer（我认为这应该是为了避免多线程写的麻烦），把这条Record序列化为ByteBuffer</li>
<li>接下来数据被写入ResultPartition下的各个subPartition里，此时该数据已经存入DirectBuffer（MemorySegment）</li>
<li>单独的线程控制数据的flush速度，一旦触发flush，则通过Netty的nio通道向对端写入</li>
<li>对端的netty client接收到数据，decode出来，把数据拷贝到buffer里，然后通知InputChannel</li>
<li>有可用的数据时，下游算子从阻塞醒来，从InputChannel取出buffer，再解序列化成record，交给算子执行用户代码</li>
</ol>
<p>数据在不同机器的算子之间传递的步骤就是以上这些。</p>
<p>了解了步骤之后，再来看一下部分关键代码：<br>首先是把数据交给recordwriter。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//RecordWriterOutput.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collect</span><span class="params">(StreamRecord&lt;OUT&gt; record)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.outputTag != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// we are only responsible for emitting to the main input</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//这里可以看到把记录交给了recordwriter</span></span><br><span class="line">	pushToRecordWriter(record);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后recordwriter把数据发送到对应的通道。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//RecordWriter.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(T record)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//channelselector登场了</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> targetChannel : channelSelector.selectChannels(record, numChannels)) &#123;</span><br><span class="line">		sendToTarget(record, targetChannel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendToTarget</span><span class="params">(T record, <span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//选择序列化器并序列化数据</span></span><br><span class="line">	RecordSerializer&lt;T&gt; serializer = serializers[targetChannel];</span><br><span class="line"></span><br><span class="line">	SerializationResult result = serializer.addRecord(record);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (result.isFullBuffer()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tryFinishCurrentBufferBuilder(targetChannel, serializer)) &#123;</span><br><span class="line">			<span class="comment">// If this was a full record, we are done. Not breaking</span></span><br><span class="line">			<span class="comment">// out of the loop at this point will lead to another</span></span><br><span class="line">			<span class="comment">// buffer request before breaking out (that would not be</span></span><br><span class="line">			<span class="comment">// a problem per se, but it can lead to stalls in the</span></span><br><span class="line">			<span class="comment">// pipeline).</span></span><br><span class="line">			<span class="keyword">if</span> (result.isFullRecord()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		BufferBuilder bufferBuilder = requestNewBufferBuilder(targetChannel);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//写入channel</span></span><br><span class="line">		result = serializer.continueWritingWithNextBufferBuilder(bufferBuilder);</span><br><span class="line">	&#125;</span><br><span class="line">	checkState(!serializer.hasSerializedData(), <span class="string">"All data should be written at once"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flushAlways) &#123;</span><br><span class="line">		targetPartition.flush(targetChannel);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是把数据推给底层设施（netty）的过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//ResultPartition.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flushAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (ResultSubpartition subpartition : subpartitions) &#123;</span><br><span class="line">		subpartition.flush();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PartitionRequestQueue.java</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">notifyReaderNonEmpty</span><span class="params">(<span class="keyword">final</span> NetworkSequenceViewReader reader)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里交给了netty server线程去推</span></span><br><span class="line">	ctx.executor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ctx.pipeline().fireUserEventTriggered(reader);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>netty相关的部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireUserEventTriggered</span><span class="params">(<span class="keyword">final</span> Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"event"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext next = <span class="keyword">this</span>.findContextInbound();</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            next.invokeUserEventTriggered(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> OneTimeTask() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeUserEventTriggered(event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后真实的写入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//PartittionRequesetQueue.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueAvailableReader</span><span class="params">(<span class="keyword">final</span> NetworkSequenceViewReader reader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (reader.isRegisteredAsAvailable() || !reader.isAvailable()) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Queue an available reader for consumption. If the queue is empty,</span></span><br><span class="line">	<span class="comment">// we try trigger the actual write. Otherwise this will be handled by</span></span><br><span class="line">	<span class="comment">// the writeAndFlushNextMessageIfPossible calls.</span></span><br><span class="line">	<span class="keyword">boolean</span> triggerWrite = availableReaders.isEmpty();</span><br><span class="line">	registerAvailableReader(reader);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (triggerWrite) &#123;</span><br><span class="line">		writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeAndFlushNextMessageIfPossible</span><span class="params">(<span class="keyword">final</span> Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">			next = reader.getNextBuffer();</span><br><span class="line">			<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!reader.isReleased()) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				markAsReleased(reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">				Throwable cause = reader.getFailureCause();</span><br><span class="line">				<span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">					ErrorResponse msg = <span class="keyword">new</span> ErrorResponse(</span><br><span class="line">						<span class="keyword">new</span> ProducerFailedException(cause),</span><br><span class="line">						reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">					ctx.writeAndFlush(msg);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// This channel was now removed from the available reader queue.</span></span><br><span class="line">				<span class="comment">// We re-add it into the queue if it is still available</span></span><br><span class="line">				<span class="keyword">if</span> (next.moreAvailable()) &#123;</span><br><span class="line">					registerAvailableReader(reader);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				BufferResponse msg = <span class="keyword">new</span> BufferResponse(</span><br><span class="line">					next.buffer(),</span><br><span class="line">					reader.getSequenceNumber(),</span><br><span class="line">					reader.getReceiverId(),</span><br><span class="line">					next.buffersInBacklog());</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (isEndOfPartitionEvent(next.buffer())) &#123;</span><br><span class="line">					reader.notifySubpartitionConsumed();</span><br><span class="line">					reader.releaseAllResources();</span><br><span class="line"></span><br><span class="line">					markAsReleased(reader.getReceiverId());</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Write and flush and wait until this is done before</span></span><br><span class="line">				<span class="comment">// trying to continue with the next buffer.</span></span><br><span class="line">				channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码里第二个方法中调用的writeAndFlush就是真正往netty的nio通道里写入的地方了。在这里，写入的是一个RemoteInputChannel，对应的就是下游节点的InputGate的channels。</p>
<p>有写就有读，nio通道的另一端需要读入buffer，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//CreditBasedPartitionRequestClientHandler.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeMsg</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Class&lt;?&gt; msgClazz = msg.getClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---- Buffer --------------------------------------------------------</span></span><br><span class="line">	<span class="keyword">if</span> (msgClazz == NettyMessage.BufferResponse<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">		NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;</span><br><span class="line"></span><br><span class="line">		RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);</span><br><span class="line">		<span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">			bufferOrEvent.releaseBuffer();</span><br><span class="line"></span><br><span class="line">			cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		decodeBufferOrEvent(inputChannel, bufferOrEvent);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插一句，Flink其实做阻塞和获取数据的方式非常自然，利用了生产者和消费者模型，当获取不到数据时，消费者自然阻塞；当数据被加入队列，消费者被notify。Flink的背压机制也是借此实现。</p>
<p>然后在这里又反序列化成StreamRecord：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//StreamElementSerializer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StreamElement <span class="title">deserialize</span><span class="params">(DataInputView source)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tag = source.readByte();</span><br><span class="line">	<span class="keyword">if</span> (tag == TAG_REC_WITH_TIMESTAMP) &#123;</span><br><span class="line">		<span class="keyword">long</span> timestamp = source.readLong();</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StreamRecord&lt;T&gt;(typeSerializer.deserialize(source), timestamp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_REC_WITHOUT_TIMESTAMP) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StreamRecord&lt;T&gt;(typeSerializer.deserialize(source));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_WATERMARK) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Watermark(source.readLong());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_STREAM_STATUS) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> StreamStatus(source.readInt());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (tag == TAG_LATENCY_MARKER) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LatencyMarker(source.readLong(), <span class="keyword">new</span> OperatorID(source.readLong(), source.readLong()), source.readInt());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Corrupt stream, found tag: "</span> + tag);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再次在<em>StreamInputProcessor.processInput</em>循环中得到处理。</p>
<p>至此，数据在跨jvm的节点之间的流转过程就讲完了。</p>
<h2 id="2-Credit漫谈"><a href="#2-Credit漫谈" class="headerlink" title="2 Credit漫谈"></a>2 Credit漫谈</h2><h3 id="2-1-背压问题"><a href="#2-1-背压问题" class="headerlink" title="2.1 背压问题"></a>2.1 背压问题</h3><p>在流模型中，我们期待数据是像水流一样平滑的流过我们的引擎，但现实生活不会这么美好。数据的上游可能因为各种原因数据量暴增，远远超出了下游的瞬时处理能力（回忆一下98年大洪水），导致系统崩溃。<br>那么框架应该怎么应对呢？和人类处理自然灾害的方式类似，我们修建了三峡大坝，当洪水来临时把大量的水囤积在大坝里；对于Flink来说，就是在数据的接收端和发送端放置了缓存池，用以缓冲数据，并且设置闸门阻止数据向下流。</p>
<p>那么Flink又是如何处理背压的呢？答案也是靠这些缓冲池。</p>
<p><img src="/img/image_1cfksrl5cd4m1lbqqqgvc811349.png" alt="image_1cfksrl5cd4m1lbqqqgvc811349.png-43.1kB"><br>这张图说明了Flink在生产和消费数据时的大致情况。ResultPartition和InputGate在输出和输入数据时，都要向NetworkBufferPool申请一块MemorySegment作为缓存池。<br>接下来的情况和生产者消费者很类似。当数据发送太多，下游处理不过来了，那么首先InputChannel会被填满，然后是InputChannel能申请到的内存达到最大，于是下游停止读取数据，上游负责发送数据的nettyServer会得到响应，停止从ResultSubPartition读取缓存，那么ResultPartition很快也将存满数据不能被消费，从而生产数据的逻辑被阻塞在获取新buffer上，非常自然地形成背压的效果。</p>
<p>Flink自己做了个试验用以说明这个机制的效果：<br><img src="/img/image_1cfkta54rkdd1od4aau1e3n7nhm.png" alt="image_1cfkta54rkdd1od4aau1e3n7nhm.png-240.6kB"><br>我们首先设置生产者的发送速度为60%，然后下游的算子以同样的速度处理数据。然后我们将下游算子的处理速度降低到30%，可以看到上游的生产者的数据产生曲线几乎与消费者同步下滑。而后当我们解除限速，整个流的速度立刻提高到了100%。</p>
<h3 id="2-2-使用Credit实现ATM网络流控"><a href="#2-2-使用Credit实现ATM网络流控" class="headerlink" title="2.2 使用Credit实现ATM网络流控"></a>2.2 使用Credit实现ATM网络流控</h3><p>上文已经提到，对于流量控制，一个朴素的思路就是在长江上建三峡链路上建立一个拦截的dam，如下图所示：<br><img src="/img/image_1cfku114lf7hpqf3lmcl0116c13.png" alt="image_1cfku114lf7hpqf3lmcl0116c13.png-22.7kB"><br>基于Credit的流控就是这样一种建立在信用（消费数据的能力)上的，面向每个虚链路（而非端到端的）流模型，如下图所示：<br><img src="/img/image_1cfku4g4g174d7gb5ecbfcib71g.png" alt="image_1cfku4g4g174d7gb5ecbfcib71g.png-22.5kB"><br>首先，下游会向上游发送一条credit message，用以通知其目前的信用（可联想信用卡的可用额度），然后上游会根据这个信用消息来决定向下游发送多少数据。当上游把数据发送给下游时，它就从下游的信用卡上划走相应的额度（credit balance）：<br><img src="/img/image_1cfkug5sm1v4l15pbgj4jntc7q1t.png" alt="image_1cfkug5sm1v4l15pbgj4jntc7q1t.png-12.9kB"><br>下游总共获得的credit数目是Buf_Alloc，已经消费的数据是Fwd_Cnt，上游发送出来的数据是Tx_Cnt，那么剩下的那部分就是Crd_Bal:<br>Crd_Bal = Buf_Alloc - ( Tx_Cnt - Fwd_Cnt )<br>上面这个式子应该很好理解。</p>
<p>可以看到，Credit Based Flow Control的关键是buffer分配。这种分配可以在数据的发送端完成，也可以在接收端完成。对于下游可能有多个上游节点的情况（比如Flink），使用接收端的credit分配更加合理：<br><img src="/img/image_1cfkvpmlh1gl31ef41cvh1c903a19.png" alt="image_1cfkvpmlh1gl31ef41cvh1c903a19.png-13.1kB"><br>上图中，接收者可以观察到每个上游连接的带宽情况，而上游的节点Snd1却不可能轻易知道发往同一个下游节点的其他Snd2的带宽情况，从而如果在上游控制流量将会很困难，而在下游控制流量将会很方便。</p>
<p>因此，这就是为何Flink在接收端有一个基于Credit的Client，而不是在发送端有一个CreditServer的原因。</p>
<p>最后，再讲一下Credit的面向虚链路的流设计和端到端的流设计的区别：<br><img src="/img/image_1cfl05d2f1ub879c1lc5qsq14n9m.png" alt="image_1cfl05d2f1ub879c1lc5qsq14n9m.png-13.4kB"><br>如上图所示，a是面向连接的流设计，b是端到端的流设计。其中，a的设计使得当下游节点3因某些情况必须缓存数据暂缓处理时，每个上游节点（1和2）都可以利用其缓存保存数据；而端到端的设计b里，只有节点3的缓存才可以用于保存数据（读者可以从如何实现上想想为什么）。</p>
<p>对流控制感兴趣的读者，可以看这篇文章：<a href="https://www.nap.edu/read/5769/chapter/1" target="_blank" rel="noopener">Traffic Management For High-Speed Networks</a>。</p>
<h2 id="3-其他核心概念"><a href="#3-其他核心概念" class="headerlink" title="3.其他核心概念"></a>3.其他核心概念</h2><h3 id="3-1-EventTime时间模型"><a href="#3-1-EventTime时间模型" class="headerlink" title="3.1 EventTime时间模型"></a>3.1 EventTime时间模型</h3><p>flink有三种时间模型：ProcessingTime，EventTime和IngestionTime。<br>关于时间模型看这张图：<br><img src="/img/image_1cdbotdcmoe11q961st5lbn1j4n9.png" alt="image_1cdbotdcmoe11q961st5lbn1j4n9.png-38.4kB"><br>从这张图里可以很清楚的看到三种Time模型的区别。</p>
<ul>
<li>EventTime是数据被生产出来的时间，可以是比如传感器发出信号的时间等（此时数据还没有被传输给flink）。</li>
<li>IngestionTime是数据进入flink的时间，也就是从Source进入flink流的时间（此时数据刚刚被传给flink）</li>
<li>ProcessingTime是针对当前算子的系统时间，是指该数据已经进入某个operator时，operator所在系统的当前时间</li>
</ul>
<p>例如，我在写这段话的时间是2018年5月13日03点47分，但是我引用的这张EventTime的图片，是2015年画出来的，那么这张图的EventTime是2015年，而ProcessingTime是现在。<br>Flink官网对于时间戳的解释非常详细：<a href="https://ci.apache.org/projects/flink/flink-docs-master/dev/event_time.html" target="_blank" rel="noopener">点我</a><br>Flink对于EventTime模型的实现，依赖的是一种叫做watermark的对象。watermark是携带有时间戳的一个对象，会按照程序的要求被插入到数据流中，用以标志某个事件在该时间发生了。<br>我再做一点简短的说明，还是以官网的图为例：<br><img src="/img/image_1cdbt8v5jl2ujn91uu1joh1p4gm.png" alt="image_1cdbt8v5jl2ujn91uu1joh1p4gm.png-11.3kB"><br>对于有序到来的数据，假设我们在timestamp为11的元素后加入一个watermark，时间记录为11，则下个元素收到该watermark时，认为所有早于11的元素均已到达。这是非常理想的情况。<br><img src="/img/image_1cdbtcc5c1a6i1tuaadb1rd5136913.png" alt="image_1cdbtcc5c1a6i1tuaadb1rd5136913.png-11.6kB"><br>而在现实生活中，经常会遇到乱序的数据。这时，我们虽然在timestamp为7的元素后就收到了11，但是我们一直等到了收到元素12之后，才插入了watermark为11的元素。与上面的图相比，如果我们仍然在11后就插入11的watermark，那么元素9就会被丢弃，造成数据丢失。而我们在12之后插入watermark11，就保证了9仍然会被下一个operator处理。当然，我们不可能无限制的永远等待迟到元素，所以要在哪个元素后插入11需要根据实际场景权衡。</p>
<p>对于来自多个数据源的watermark，可以看这张图：</p>
<p><img src="/img/image_1cdbufp4a1opmsit5n61mial4520.png" alt="image_1cdbufp4a1opmsit5n61mial4520.png-72kB"><br>可以看到，当一个operator收到多个watermark时，它遵循最小原则（或者说最早），即算子的当前watermark是流经该算子的最小watermark，以容许来自不同的source的乱序数据到来。<br>关于事件时间模型，更多内容可以参考<a href="https://www.oreilly.com/ideas/the-world-beyond-batch-streaming-101" target="_blank" rel="noopener">Stream 101</a> 和谷歌的这篇论文：<a href="https://research.google.com/pubs/archive/43864.pdf" target="_blank" rel="noopener">Dataflow Model paper</a></p>
<h3 id="3-2-FLIP-6-部署及处理模型演进"><a href="#3-2-FLIP-6-部署及处理模型演进" class="headerlink" title="3.2 FLIP-6 部署及处理模型演进"></a>3.2 FLIP-6 部署及处理模型演进</h3><p>就在老白写这篇blog的时候，Flink发布了其1.5 RELEASE版本，号称实现了其部署及处理模型（也就是FLIP-6)，所以打算简略地说一下FLIP-6的主要内容。</p>
<h4 id="3-2-1-现有模型不足"><a href="#3-2-1-现有模型不足" class="headerlink" title="3.2.1 现有模型不足"></a>3.2.1 现有模型不足</h4><p>1.5之前的Flink模型有很多不足，包括：</p>
<ul>
<li>只能静态分配计算资源</li>
<li>在YARN上所有的资源分配都是一碗水端平的</li>
<li>与Docker/k8s的集成非常之蠢，颇有脱裤子放屁的神韵</li>
<li>JobManager没有任务调度逻辑</li>
<li>任务在YARN上执行结束后web dashboard就不可用</li>
<li>集群的session模式和per job模式混淆难以理解</li>
</ul>
<p>就我个人而言，我觉得Flink有一个这里完全没提到的不足才是最应该修改的：针对任务的完全的资源隔离。尤其是如果用Standalone集群，一个用户的task跑挂了TaskManager，然后拖垮了整个集群的情况简直不要太多。</p>
<h4 id="3-2-2-核心变更"><a href="#3-2-2-核心变更" class="headerlink" title="3.2.2 核心变更"></a>3.2.2 核心变更</h4><p><strong>Single Job JobManager</strong><br>最重要的变更是一个JobManager只处理一个job。当我们生成JobGraph时就顺便起一个JobManager，这显然更加自然。</p>
<p><strong>ResourceManager</strong><br>其职责包括获取新的TM和slot，通知失败，释放资源以及缓存TM以用于重用等。重要的是，这个组件要能做到挂掉时不要搞垮正在运行的好好的任务。其职责和与JobManager、TaskManager的交互图如下：</p>
<p><img src="/img/image_1cfl9453k1gld4acr1m13j3195sg.png" alt="image_1cfl9453k1gld4acr1m13j3195sg.png-23.9kB"></p>
<p><strong>TaskManager</strong><br>TM要与上面的两个组件交互。与JobManager交互时，要能提供slot，要能与所有给出slot的JM交互。丢失与JM的连接时要能试图把本TM上的slot的情况通告给新JM，如果这一步失败，就要能重新分配slot。<br>与ResourceManager交互时，要通知RM自己的资源和当前的Job分配情况，能按照RM的要求分配资源或者关闭自身。</p>
<p><strong>JobManager Slot Pool</strong><br>这个pool要持有所有分配给当前job的slot资源，并且能在RM挂掉的情况下管理当前已经持有的slot。</p>
<p><strong>Dispatcher</strong><br>需要一个Job的分发器的主要原因是在有的集群环境下我们可能需要一个统一的提交和监控点，以及替代之前的Standalone模式下的JobManager。将来对分发器的期望可能包括权限控制等。<br><img src="/img/image_1cfl9ju2617bh1s191mar1jsp12vot.png" alt="image_1cfl9ju2617bh1s191mar1jsp12vot.png-31.4kB"></p>
<h4 id="3-2-3-Cluster-Manager的架构"><a href="#3-2-3-Cluster-Manager的架构" class="headerlink" title="3.2.3 Cluster Manager的架构"></a>3.2.3 Cluster Manager的架构</h4><p><strong>YARN</strong><br>新的基于YARN的架构主要包括不再需要先在容器里启动集群，然后提交任务；用户代码不再使用动态ClassLoader加载；不用的资源可以释放；可以按需分配不同大小的容器等。其执行过程如下：<br>无Dispatcher时</p>
<p><img src="/img/image_1cfla0n7u1lg21n3o36uu0c1o5h1a.png" alt="image_1cfla0n7u1lg21n3o36uu0c1o5h1a.png-46.2kB"><br>有Dispatcher时</p>
<p><img src="/img/image_1cfla15os15i3qcsu6c4p4clk1n.png" alt="image_1cfla15os15i3qcsu6c4p4clk1n.png-50.7kB"></p>
<p><strong>Mesos</strong><br>与基于YARN的模式很像，但是只有带Dispatcher模式，因为只有这样才能在Mesos集群里跑其RM。</p>
<p><img src="/img/image_1cfla4tka101n18bf1mno4npu9s24.png" alt="image_1cfla4tka101n18bf1mno4npu9s24.png-49.2kB"><br>Mesos的Fault Tolerance是类似这样的：</p>
<p><img src="/img/image_1cfla6eka1ph71mu1pll1q0mgqq2h.png" alt="image_1cfla6eka1ph71mu1pll1q0mgqq2h.png-12.1kB"><br>必须用类似Marathon之类的技术保证Dispatcher的HA。</p>
<p><strong>Standalone</strong><br>其实没啥可说的，把以前的JobManager的职责换成现在的Dispatcher就行了。</p>
<p><img src="/img/image_1cflaaim2ih2v54umsmq01lqc2u.png" alt="image_1cflaaim2ih2v54umsmq01lqc2u.png-36.8kB"><br>将来可能会实现一个类似于轻量级Yarn的模式。</p>
<p><strong>Docker/k8s</strong><br>用户定义好容器，至少有一个是job specific的（不然怎么启动任务）；还有用于启动TM的，可以不是job specific的。启动过程如下</p>
<p><img src="/img/image_1cflafs2o1trgicjmdbndn1bdq3b.png" alt="image_1cflafs2o1trgicjmdbndn1bdq3b.png-24.2kB"></p>
<h4 id="3-2-4-组件设计及细节"><a href="#3-2-4-组件设计及细节" class="headerlink" title="3.2.4 组件设计及细节"></a>3.2.4 组件设计及细节</h4><p><strong>分配slot相关细节</strong><br>从新的TM取slot过程：</p>
<p><img src="/img/image_1cflakoadvjm8pf6nt1k331qj33o.png" alt="image_1cflakoadvjm8pf6nt1k331qj33o.png-77.2kB"></p>
<p>从Cached TM取slot过程：</p>
<p><img src="/img/image_1cflambu91ufi5fl1cg9gimdff45.png" alt="image_1cflambu91ufi5fl1cg9gimdff45.png-63.4kB"></p>
<p><strong>失败处理</strong></p>
<ol>
<li><p>TM失败<br>TM失败时，RM要能检测到失败，更新自己的状态，发送消息给JM，重启一份TM；JM要能检测到失败，从状态移除失效slot，标记该TM的task为失败，并在没有足够slot继续任务时调整规模；TM自身则要能从Checkpoint恢复</p>
</li>
<li><p>RM失败<br>此时TM要能检测到失败，并准备向新的RM注册自身，并且向新的RM传递自身的资源情况；JM要能检测到失败并且等待新的RM可用，重新请求需要的资源；丢失的数据要能从Container、TM等处恢复。</p>
</li>
<li><p>JM失败<br>TM释放所有task，向新JM注册资源，并且如果不成功，就向RM报告这些资源可用于重分配；RM坐等；JM丢失的数据从持久化存储中获得，已完成的checkpoints从HA恢复，从最近的checkpoint重启task，并申请资源。</p>
</li>
<li><p>JM &amp; RM 失败<br>TM将在一段时间内试图把资源交给新上任的JM，如果失败，则把资源交给新的RM</p>
</li>
<li><p>TM &amp; RM失败<br>JM如果正在申请资源，则要等到新的RM启动后才能获得；JM可能需要调整其规模，因为损失了TM的slot。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink执行流程四</title>
    <url>/2024/09/03/Flink%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%9B/</url>
    <content><![CDATA[<h2 id="1-StreamOperator的抽象与实现"><a href="#1-StreamOperator的抽象与实现" class="headerlink" title="1. StreamOperator的抽象与实现"></a>1. StreamOperator的抽象与实现</h2><h3 id="1-1-数据源的逻辑——StreamSource与时间模型"><a href="#1-1-数据源的逻辑——StreamSource与时间模型" class="headerlink" title="1.1 数据源的逻辑——StreamSource与时间模型"></a>1.1 数据源的逻辑——StreamSource与时间模型</h3><p>StreamSource抽象了一个数据源，并且指定了一些如何处理数据的模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamSource</span>&lt;<span class="title">OUT</span>, <span class="title">SRC</span> <span class="keyword">extends</span> <span class="title">SourceFunction</span>&lt;<span class="title">OUT</span>&gt;&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">AbstractUdfStreamOperator</span>&lt;<span class="title">OUT</span>, <span class="title">SRC</span>&gt; <span class="keyword">implements</span> <span class="title">StreamOperator</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Object lockingObject, <span class="keyword">final</span> StreamStatusMaintainer streamStatusMaintainer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		run(lockingObject, streamStatusMaintainer, output);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">final</span> Object lockingObject,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> StreamStatusMaintainer streamStatusMaintainer,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> Output&lt;StreamRecord&lt;OUT&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> TimeCharacteristic timeCharacteristic = getOperatorConfig().getTimeCharacteristic();</span><br><span class="line"></span><br><span class="line">		LatencyMarksEmitter latencyEmitter = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (getExecutionConfig().isLatencyTrackingEnabled()) &#123;</span><br><span class="line">			latencyEmitter = <span class="keyword">new</span> LatencyMarksEmitter&lt;&gt;(</span><br><span class="line">				getProcessingTimeService(),</span><br><span class="line">				collector,</span><br><span class="line">				getExecutionConfig().getLatencyTrackingInterval(),</span><br><span class="line">				getOperatorConfig().getVertexID(),</span><br><span class="line">				getRuntimeContext().getIndexOfThisSubtask());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">long</span> watermarkInterval = getRuntimeContext().getExecutionConfig().getAutoWatermarkInterval();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.ctx = StreamSourceContexts.getSourceContext(</span><br><span class="line">			timeCharacteristic,</span><br><span class="line">			getProcessingTimeService(),</span><br><span class="line">			lockingObject,</span><br><span class="line">			streamStatusMaintainer,</span><br><span class="line">			collector,</span><br><span class="line">			watermarkInterval,</span><br><span class="line">			-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			userFunction.run(ctx);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if we get here, then the user function either exited after being done (finite source)</span></span><br><span class="line">			<span class="comment">// or the function was canceled or stopped. For the finite source case, we should emit</span></span><br><span class="line">			<span class="comment">// a final watermark that indicates that we reached the end of event-time</span></span><br><span class="line">			<span class="keyword">if</span> (!isCanceledOrStopped()) &#123;</span><br><span class="line">				ctx.emitWatermark(Watermark.MAX_WATERMARK);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// make sure that the context is closed in any case</span></span><br><span class="line">			ctx.close();</span><br><span class="line">			<span class="keyword">if</span> (latencyEmitter != <span class="keyword">null</span>) &#123;</span><br><span class="line">				latencyEmitter.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LatencyMarksEmitter</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> ScheduledFuture&lt;?&gt; latencyMarkTimer;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">LatencyMarksEmitter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> ProcessingTimeService processingTimeService,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> Output&lt;StreamRecord&lt;OUT&gt;&gt; output,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">long</span> latencyTrackingInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> <span class="keyword">int</span> vertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> <span class="keyword">int</span> subtaskIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">			latencyMarkTimer = processingTimeService.scheduleAtFixedRate(</span><br><span class="line">				<span class="keyword">new</span> ProcessingTimeCallback() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">// ProcessingTimeService callbacks are executed under the checkpointing lock</span></span><br><span class="line">							output.emitLatencyMarker(<span class="keyword">new</span> LatencyMarker(timestamp, vertexID, subtaskIndex));</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">							<span class="comment">// we catch the Throwables here so that we don't trigger the processing</span></span><br><span class="line">							<span class="comment">// timer services async exception handler</span></span><br><span class="line">							LOG.warn(<span class="string">"Error while emitting latency marker."</span>, t);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="number">0L</span>,</span><br><span class="line">				latencyTrackingInterval);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			latencyMarkTimer.cancel(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在StreamSource生成上下文之后，接下来就是把上下文交给SourceFunction去执行:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">userFunction.run(ctx);</span><br></pre></td></tr></table></figure>
<p>SourceFunction是对Function的一个抽象，就好像MapFunction，KeyByFunction一样，用户选择实现这些函数，然后flink框架就能利用这些函数进行计算，完成用户逻辑。<br>我们的wordcount程序使用了flink提供的一个SocketTextStreamFunction。我们可以看一下它的实现逻辑，对source如何运行有一个基本的认识：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;String&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">long</span> attempt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> (Socket socket = <span class="keyword">new</span> Socket()) &#123;</span><br><span class="line">				currentSocket = socket;</span><br><span class="line"></span><br><span class="line">				LOG.info(<span class="string">"Connecting to server socket "</span> + hostname + <span class="string">':'</span> + port);</span><br><span class="line">				socket.connect(<span class="keyword">new</span> InetSocketAddress(hostname, port), CONNECTION_TIMEOUT_TIME);</span><br><span class="line">				BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line"></span><br><span class="line">				<span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8192</span>];</span><br><span class="line">				<span class="keyword">int</span> bytesRead;</span><br><span class="line">				<span class="comment">//核心逻辑就是一直读inputSocket,然后交给collect方法</span></span><br><span class="line">				<span class="keyword">while</span> (isRunning &amp;&amp; (bytesRead = reader.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">					buffer.append(cbuf, <span class="number">0</span>, bytesRead);</span><br><span class="line">					<span class="keyword">int</span> delimPos;</span><br><span class="line">					<span class="keyword">while</span> (buffer.length() &gt;= delimiter.length() &amp;&amp; (delimPos = buffer.indexOf(delimiter)) != -<span class="number">1</span>) &#123;</span><br><span class="line">						String record = buffer.substring(<span class="number">0</span>, delimPos);</span><br><span class="line">						<span class="comment">// truncate trailing carriage return</span></span><br><span class="line">						<span class="keyword">if</span> (delimiter.equals(<span class="string">"\n"</span>) &amp;&amp; record.endsWith(<span class="string">"\r"</span>)) &#123;</span><br><span class="line">							record = record.substring(<span class="number">0</span>, record.length() - <span class="number">1</span>);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">//读到数据后，把数据交给collect方法，collect方法负责把数据交到合适的位置（如发布为br变量，或者交给下个operator，或者通过网络发出去）</span></span><br><span class="line">						ctx.collect(record);</span><br><span class="line">						buffer.delete(<span class="number">0</span>, delimPos + delimiter.length());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// if we dropped out of this loop due to an EOF, sleep and retry</span></span><br><span class="line">			<span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">				attempt++;</span><br><span class="line">				<span class="keyword">if</span> (maxNumRetries == -<span class="number">1</span> || attempt &lt; maxNumRetries) &#123;</span><br><span class="line">					LOG.warn(<span class="string">"Lost connection to server socket. Retrying in "</span> + delayBetweenRetries + <span class="string">" msecs..."</span>);</span><br><span class="line">					Thread.sleep(delayBetweenRetries);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// this should probably be here, but some examples expect simple exists of the stream source</span></span><br><span class="line">					<span class="comment">// throw new EOFException("Reached end of stream and reconnects are not enabled.");</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// collect trailing data</span></span><br><span class="line">		<span class="keyword">if</span> (buffer.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ctx.collect(buffer.toString());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>整段代码里，只有collect方法有些复杂度，后面我们在讲到flink的对象机制时会结合来讲，此处知道collect方法会收集结果，然后发送给接收者即可。在我们的wordcount里，这个算子的接收者就是被chain在一起的flatmap算子，不记得这个示例程序的话，可以返回第一章去看一下。</p>
<h3 id="1-2-从数据输入到数据处理——OneInputStreamOperator-amp-AbstractUdfStreamOperator"><a href="#1-2-从数据输入到数据处理——OneInputStreamOperator-amp-AbstractUdfStreamOperator" class="headerlink" title="1.2 从数据输入到数据处理——OneInputStreamOperator &amp; AbstractUdfStreamOperator"></a>1.2 从数据输入到数据处理——OneInputStreamOperator &amp; AbstractUdfStreamOperator</h3><p>StreamSource是用来开启整个流的算子，而承接输入数据并进行处理的算子就是OneInputStreamOperator、TwoInputStreamOperator等。<br><img src="/img/image_1cdc1tbgs136k1ppf17at14fumjf2d.png" alt="image_1cdc1tbgs136k1ppf17at14fumjf2d.png-126.7kB"><br>整个StreamOperator的继承关系如上图所示（图很大，建议点开放大看）。<br>OneInputStreamOperator这个接口的逻辑很简单：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OneInputStreamOperator</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">StreamOperator</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Processes one element that arrived at this operator.</span></span><br><span class="line"><span class="comment">	 * This method is guaranteed to not be called concurrently with other methods of the operator.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Processes a &#123;<span class="doctag">@link</span> Watermark&#125;.</span></span><br><span class="line"><span class="comment">	 * This method is guaranteed to not be called concurrently with other methods of the operator.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.apache.flink.streaming.api.watermark.Watermark</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">processWatermark</span><span class="params">(Watermark mark)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">processLatencyMarker</span><span class="params">(LatencyMarker latencyMarker)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而实现了这个接口的StreamFlatMap算子也很简单，没什么可说的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamFlatMap</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">AbstractUdfStreamOperator</span>&lt;<span class="title">OUT</span>, <span class="title">FlatMapFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt;&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">OneInputStreamOperator</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> TimestampedCollector&lt;OUT&gt; collector;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StreamFlatMap</span><span class="params">(FlatMapFunction&lt;IN, OUT&gt; flatMapper)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(flatMapper);</span><br><span class="line">		chainingStrategy = ChainingStrategy.ALWAYS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.open();</span><br><span class="line">		collector = <span class="keyword">new</span> TimestampedCollector&lt;&gt;(output);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		collector.setTimestamp(element);</span><br><span class="line">		userFunction.flatMap(element.getValue(), collector);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从类图里可以看到，flink为我们封装了一个算子的基类AbstractUdfStreamOperator，提供了一些通用功能，比如把context赋给算子，保存快照等等，其中最为大家了解的应该是这两个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.open();</span><br><span class="line">	FunctionUtils.openFunction(userFunction, <span class="keyword">new</span> Configuration());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.close();</span><br><span class="line">	functionsClosed = <span class="keyword">true</span>;</span><br><span class="line">	FunctionUtils.closeFunction(userFunction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个就是flink提供的RichFunction系列算子的open和close方法被执行的地方。</p>
<h3 id="1-3-StreamSink"><a href="#1-3-StreamSink" class="headerlink" title="1.3 StreamSink"></a>1.3 StreamSink</h3><p>StreamSink着实没什么可说的，逻辑很简单，值得一提的只有两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(StreamRecord&lt;IN&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	sinkContext.element = element;</span><br><span class="line">	userFunction.invoke(element.getValue(), sinkContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">reportOrForwardLatencyMarker</span><span class="params">(LatencyMarker maker)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// all operators are tracking latencies</span></span><br><span class="line">	<span class="keyword">this</span>.latencyGauge.reportLatency(maker, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sinks don't forward latency markers</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，processElement是继承自StreamOperator的方法。reportOrForwardLatencyMarker是用来计算延迟的，前面提到StreamSource会产生LateMarker，用于记录数据计算时间，就是在这里完成了计算。</p>
<p>算子这部分逻辑相对简单清晰，就讲这么多吧。</p>
<h2 id="2-为执行保驾护航——Fault-Tolerant与保证Exactly-Once语义"><a href="#2-为执行保驾护航——Fault-Tolerant与保证Exactly-Once语义" class="headerlink" title="2. 为执行保驾护航——Fault Tolerant与保证Exactly-Once语义"></a>2. 为执行保驾护航——Fault Tolerant与保证Exactly-Once语义</h2><h3 id="2-1-Fault-Tolerant演进之路"><a href="#2-1-Fault-Tolerant演进之路" class="headerlink" title="2.1 Fault Tolerant演进之路"></a>2.1 Fault Tolerant演进之路</h3><p>对于7×24小时不间断运行的流程序来说，要保证fault tolerant是很难的，这不像是离线任务，如果失败了只需要清空已有结果，重新跑一次就可以了。对于流任务，如果要保证能够重新处理已处理过的数据，就要把数据保存下来；而这就面临着几个问题：比如一是保存多久的数据？二是重复计算的数据应该怎么处理，怎么保证幂等性？<br>对于一个流系统，我们有以下希望：</p>
<ol>
<li>最好能做到exactly-once</li>
<li>处理延迟越低越好</li>
<li>吞吐量越高越好</li>
<li>计算模型应当足够简单易用，又具有足够的表达力</li>
<li>从错误恢复的开销越低越好</li>
<li>足够的流控制能力（背压能力）</li>
</ol>
<h3 id="2-2-Storm的Record-acknowledgement模式"><a href="#2-2-Storm的Record-acknowledgement模式" class="headerlink" title="2.2 Storm的Record acknowledgement模式"></a>2.2 Storm的Record acknowledgement模式</h3><p>storm的fault tolerant是这样工作的：每一个被storm的operator处理的数据都会向其上一个operator发送一份应答消息，通知其已被下游处理。storm的源operator保存了所有已发送的消息的每一个下游算子的应答消息，当它收到来自sink的应答时，它就知道该消息已经被完整处理，可以移除了。<br>如果没有收到应答，storm就会重发该消息。显而易见，这是一种at least once的逻辑。另外，这种方式面临着严重的幂等性问题，例如对一个count算子，如果count的下游算子出错，source重发该消息，那么防止该消息被count两遍的逻辑需要程序员自己去实现。最后，这样一种处理方式非常低效，吞吐量很低。</p>
<h3 id="2-3-Spark-streaming的micro-batch模式"><a href="#2-3-Spark-streaming的micro-batch模式" class="headerlink" title="2.3 Spark streaming的micro batch模式"></a>2.3 Spark streaming的micro batch模式</h3><p>前面提到，storm的实现方式就注定了与高吞吐量无缘。那么，为了提高吞吐量，把一批数据聚集在一起处理就是很自然的选择。Spark Streaming的实现就是基于这样的思路：<br>我们可以在完全的连续计算与完全的分批计算中间取折中，通过控制每批计算数据的大小来控制延迟与吞吐量的制约，如果想要低延迟，就用小一点的batch，如果想要大吞吐量，就不得不忍受更高的延迟（更久的等待数据到来的时间和更多的计算），如下图所示。</p>
<p><img src="/img/image_1ceop58ha180p1h3ren58jk15gb9.png" alt="image_1ceop58ha180p1h3ren58jk15gb9.png-105.7kB"></p>
<p>以这样的方式，可以在每个batch中做到exactly-once，但是这种方式也有其弊端：<br>首先，batch的方式使得一些需要跨batch的操作变得非常困难，例如session window；用户不得不自己想办法去实现相关逻辑。<br>其次，batch模式很难做好背压。当一个batch因为种种原因处理慢了，那么下一个batch要么不得不容纳更多的新来数据，要么不得不堆积更多的batch，整个任务可能会被拖垮，这是一个非常致命的问题。<br>最后，batch的方式基本意味着其延迟是有比较高的下限的，实时性上不好。</p>
<h3 id="2-4-Google-Cloud-Dataflow的事务式模型"><a href="#2-4-Google-Cloud-Dataflow的事务式模型" class="headerlink" title="2.4 Google Cloud Dataflow的事务式模型"></a>2.4 Google Cloud Dataflow的事务式模型</h3><p>我们在传统数据库，如mysql中使用binlog来完成事务，这样的思路也可以被用在实现exactly-once模型中。例如，我们可以log下每个数据元素每一次被处理时的结果和当时所处的操作符的状态。这样，当我们需要fault tolerant时，我们只需要读一下log就可以了。这种模式规避了storm和spark所面临的问题，并且能够很好的实现exactly-once，唯一的弊端是：如何尽可能的减少log的成本？Flink给了我们答案。</p>
<h3 id="2-5-Flink的分布式快照机制"><a href="#2-5-Flink的分布式快照机制" class="headerlink" title="2.5 Flink的分布式快照机制"></a>2.5 Flink的分布式快照机制</h3><p> 实现exactly-once的关键是什么？是能够准确的知道和快速记录下来当前的operator的状态、当前正在处理的元素（以及正处在不同算子之间传递的元素）。如果上面这些可以做到，那么fault tolerant无非就是从持久化存储中读取上次记录的这些元信息，并且恢复到程序中。那么Flink是如何实现的呢？</p>
<p>Flink的分布式快照的核心是其轻量级异步分布式快照机制。为了实现这一机制，flink引入了一个概念，叫做Barrier。Barrier是一种标记，它被source产生并且插入到流数据中，被发送到下游节点。当下游节点处理到该barrier标志时，这就意味着在该barrier插入到流数据时，已经进入系统的数据在当前节点已经被处理完毕。</p>
<p><img src="/img/image_1ceos05badva20hb5glen1voqm.png" alt="image_1ceos05badva20hb5glen1voqm.png-15.3kB"></p>
<p>如图所示，每当一个barrier流过一个算子节点时，就说明了在该算子上，可以触发一次检查点，用以保存当前节点的状态和已经处理过的数据，这就是一份快照。（在这里可以联想一下micro-batch，把barrier想象成分割每个batch的逻辑，会好理解一点）这样的方式下，记录快照就像和前面提到的micro-batch一样容易。</p>
<p>与此同时，该算子会向下游发送该barrier。因为数据在算子之间是按顺序发送的，所以当下游节点收到该barrier时，也就意味着同样的一批数据在下游节点上也处理完毕，可以进行一次checkpoint，保存基于该节点的一份快照，快照完成后，会通知JobMananger自己完成了这个快照。这就是分布式快照的基本含义。</p>
<p>再看这张图：</p>
<p><img src="/img/image_1ceot7q13apu1a04170af7j1jao34.png" alt="image_1ceot7q13apu1a04170af7j1jao34.png-66.6kB"><br>有时，有的算子的上游节点和下游节点都不止一个，应该怎么处理呢？如果有不止一个下游节点，就向每个下游发送barrier。同理，如果有不止一个上游节点，那么就要等到所有上游节点的同一批次的barrier到达之后，才能触发checkpoint。因为每个节点运算速度不同，所以有的上游节点可能已经在发下个barrier周期的数据了，有的上游节点还没发送本次的barrier，这时候，当前算子就要缓存一下提前到来的数据，等比较慢的上游节点发送barrier之后，才能处理下一批数据。</p>
<p>当整个程序的最后一个算子sink都收到了这个barrier，也就意味着这个barrier和上个barrier之间所夹杂的这批元素已经全部落袋为安。这时，最后一个算子通知JobManager整个流程已经完成，而JobManager随后发出通知，要求所有算子删除本次快照内容，以完成清理。这整个部分，就是Flink的<strong>两阶段提交的checkpoint过程</strong>，如下面四幅图所示：</p>
<p><img src="/img/image_1ceot517e14g31u2u1mnt12o91dkb1g.png" alt="image_1ceot517e14g31u2u1mnt12o91dkb1g.png-175.5kB"></p>
<p><img src="/img/image_1ceot5kqbnik1f2i1dss1q5c1a1t.png" alt="image_1ceot5kqbnik1f2i1dss1q5c1a1t.png-221.3kB"></p>
<p><img src="/img/image_1ceot64dppjtojkq3n1jl5j0h2a.png" alt="image_1ceot64dppjtojkq3n1jl5j0h2a.png-297.8kB"></p>
<p><img src="/img/image_1ceot6kes56sidn1f2u1voo19kf2n.png" alt="image_1ceot6kes56sidn1f2u1voo19kf2n.png-255.5kB"><br>总之，通过这种方式，flink实现了我们前面提到的六项对流处理框架的要求：exactly-once、低延迟、高吞吐、易用的模型、方便的恢复机制。</p>
<p>最后，贴一个美团做的flink与storm的性能对比：<a href="https://tech.meituan.com/Flink_Benchmark.html" target="_blank" rel="noopener">flink与storm的性能对比</a></p>
<h2 id="3-checkpoint的生命周期"><a href="#3-checkpoint的生命周期" class="headerlink" title="3 checkpoint的生命周期"></a>3 checkpoint的生命周期</h2><p>接下来，我们结合源码来看看flink的checkpoint到底是如何实现其生命周期的：</p>
<h3 id="3-1-触发checkpoint"><a href="#3-1-触发checkpoint" class="headerlink" title="3.1 触发checkpoint"></a>3.1 触发checkpoint</h3><p>要完成一次checkpoint，第一步必然是发起checkpoint请求。那么，这个请求是哪里发出的，怎么发出的，又由谁控制呢？<br>还记得如果我们要设置checkpoint的话，需要指定checkpoint间隔吧？既然是一个指定间隔触发的功能，那应该会有类似于Scheduler的东西存在，flink里，这个负责触发checkpoint的类是CheckpointCoordinator。</p>
<p>flink在提交job时，会启动这个类的startCheckpointScheduler方法，如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCheckpointScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (shutdown) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Checkpoint coordinator is shut down"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// make sure all prior timers are cancelled</span></span><br><span class="line">		stopCheckpointScheduler();</span><br><span class="line"></span><br><span class="line">		periodicScheduling = <span class="keyword">true</span>;</span><br><span class="line">		currentPeriodicTrigger = timer.scheduleAtFixedRate(</span><br><span class="line">				<span class="keyword">new</span> ScheduledTrigger(),</span><br><span class="line">				baseInterval, baseInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTrigger</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			triggerCheckpoint(System.currentTimeMillis(), <span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			LOG.error(<span class="string">"Exception while triggering checkpoint."</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动之后，就会以设定好的频率调用triggerCheckPoint()方法。这个方法太长，我大概说一下都做了什么：</p>
<ul>
<li>检查符合触发checkpoint的条件，例如如果禁止了周期性的checkpoint，尚未达到触发checkpoint的最小间隔等等，就直接return</li>
<li>检查是否所有需要checkpoint和需要响应checkpoint的ACK（ack涉及到checkpoint的两阶段提交，后面会讲）的task都处于running状态，否则return</li>
<li>如果都符合，那么执行checkpointID = checkpointIdCounter.getAndIncrement();以生成一个新的id，然后生成一个PendingCheckpoint。PendingCheckpoint是一个启动了的checkpoint，但是还没有被确认。等到所有的task都确认了本次checkpoint，那么这个checkpoint对象将转化为一个CompletedCheckpoint。</li>
<li>定义一个超时callback，如果checkpoint执行了很久还没完成，就把它取消</li>
<li>触发MasterHooks，用户可以定义一些额外的操作，用以增强checkpoint的功能（如准备和清理外部资源）</li>
</ul>
<p>接下来是核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// send the messages to the tasks that trigger their checkpoint</span></span><br><span class="line"><span class="keyword">for</span> (Execution execution: executions) &#123;</span><br><span class="line">	execution.triggerCheckpoint(checkpointID, timestamp, checkpointOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是调用了Execution的triggerCheckpoint方法，一个execution就是一个executionVertex的实际执行者。我们看一下这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerCheckpoint</span><span class="params">(<span class="keyword">long</span> checkpointId, <span class="keyword">long</span> timestamp, CheckpointOptions checkpointOptions)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> LogicalSlot slot = assignedResource;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (slot != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//TaskManagerGateway是用来跟taskManager进行通信的组件</span></span><br><span class="line">		<span class="keyword">final</span> TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">		taskManagerGateway.triggerCheckpoint(attemptId, getVertex().getJobId(), checkpointId, timestamp, checkpointOptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		LOG.debug(<span class="string">"The execution has no slot assigned. This indicates that the execution is "</span> +</span><br><span class="line">			<span class="string">"no longer running."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-Task层面checkpoint的准备工作"><a href="#3-2-Task层面checkpoint的准备工作" class="headerlink" title="3.2 Task层面checkpoint的准备工作"></a>3.2 Task层面checkpoint的准备工作</h3><p>先说Task类中的部分，该类创建了一个CheckpointMetaData的对象，并且生成了一个Runable匿名类用于执行checkpoint，然后以异步的方式触发了该Runable：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">triggerCheckpointBarrier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> <span class="keyword">long</span> checkpointID,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">long</span> checkpointTimestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> CheckpointOptions checkpointOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           ......</span><br><span class="line"></span><br><span class="line">		Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// set safety net from the task's context for checkpointing thread</span></span><br><span class="line">				LOG.debug(<span class="string">"Creating FileSystem stream leak safety net for &#123;&#125;"</span>, Thread.currentThread().getName());</span><br><span class="line">				FileSystemSafetyNet.setSafetyNetCloseableRegistryForThread(safetyNetCloseableRegistry);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">boolean</span> success = invokable.triggerCheckpoint(checkpointMetaData, checkpointOptions);</span><br><span class="line">					<span class="keyword">if</span> (!success) &#123;</span><br><span class="line">						checkpointResponder.declineCheckpoint(</span><br><span class="line">								getJobID(), getExecutionId(), checkpointID,</span><br><span class="line">								<span class="keyword">new</span> CheckpointDeclineTaskNotReadyException(taskName));</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">                   ......</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		executeAsyncCallRunnable(runnable, String.format(<span class="string">"Checkpoint Trigger for %s (%s)."</span>, taskNameWithSubtask, executionId));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码里的invokable事实上就是我们的StreamTask了。Task类实际上是将checkpoint委托给了更具体的类去执行，而StreamTask也将委托给更具体的类，直到业务代码。<br>StreamTask是这样实现的：</p>
<ul>
<li>如果task还在运行，那就可以进行checkpoint。方法是先向下游所有出口广播一个Barrier，然后触发本task的State保存。</li>
<li>如果task结束了，那我们就要通知下游取消本次checkpoint，方法是发送一个CancelCheckpointMarker，这是类似于Barrier的另一种消息。</li>
<li>注意，从这里开始，整个执行链路上开始出现Barrier，可以和前面讲Fault Tolerant原理的地方结合看一下。</li>
</ul>
<p>完成broadcastCheckpointBarrier方法后，在checkpointState()方法中，StreamTask还做了很多别的工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performCheckpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		CheckpointMetaData checkpointMetaData,</span></span></span><br><span class="line"><span class="function"><span class="params">		CheckpointOptions checkpointOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">		CheckpointMetrics checkpointMetrics)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line"></span><br><span class="line">			operatorChain.broadcastCheckpointBarrier(</span><br><span class="line">					checkpointMetaData.getCheckpointId(),</span><br><span class="line">					checkpointMetaData.getTimestamp(),</span><br><span class="line">					checkpointOptions);</span><br><span class="line"></span><br><span class="line">			checkpointState(checkpointMetaData, checkpointOptions, checkpointMetrics);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCheckpointing</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//这里，就是调用StreamOperator进行snapshotState的入口方法</span></span><br><span class="line">		<span class="keyword">for</span> (StreamOperator&lt;?&gt; op : allOperators) &#123;</span><br><span class="line">			checkpointStreamOperator(op);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// we are transferring ownership over snapshotInProgressList for cleanup to the thread, active on submit</span></span><br><span class="line">		AsyncCheckpointRunnable asyncCheckpointRunnable = <span class="keyword">new</span> AsyncCheckpointRunnable(</span><br><span class="line">			owner,</span><br><span class="line">			operatorSnapshotsInProgress,</span><br><span class="line">			checkpointMetaData,</span><br><span class="line">			checkpointMetrics,</span><br><span class="line">			startAsyncPartNano);</span><br><span class="line"></span><br><span class="line">		owner.cancelables.registerCloseable(asyncCheckpointRunnable);</span><br><span class="line">		<span class="comment">//这里注册了一个Runnable，在执行完checkpoint之后向JobManager发出CompletedCheckPoint消息，这也是fault tolerant两阶段提交的一部分</span></span><br><span class="line">		owner.asyncOperationsThreadPool.submit(asyncCheckpointRunnable);</span><br><span class="line"></span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说到checkpoint，我们印象里最直观的感受肯定是我们的一些做聚合的操作符的状态保存，比如sum的和以及count的值等等。这些内容就是StreamOperator部分将要触发保存的内容。可以看到，除了我们直观的这些操作符的状态保存外，flink的checkpoint做了大量的其他工作。</p>
<p>接下来，我们就把目光转向操作符的checkpoint机制。</p>
<h3 id="3-3-操作符的状态保存及barrier传递"><a href="#3-3-操作符的状态保存及barrier传递" class="headerlink" title="3.3 操作符的状态保存及barrier传递"></a>3.3 操作符的状态保存及barrier传递</h3><p>第四章时，我们已经了解了StreamOperator的类关系，这里，我们就直接接着上一节的checkpointStreamOperator方法往下讲。<br>顺便，前面也提到了，在进行checkpoint之前，operator初始化时，会执行一个initializeState方法，在该方法中，如果task是从失败中恢复的话，其保存的state也会被restore进来。</p>
<p>传递barrier是在进行本operator的statesnapshot之前完成的，我们先来看看其逻辑，其实和传递一条数据是类似的，就是生成一个CheckpointBarrier对象，然后向每个streamOutput写进去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">broadcastCheckpointBarrier</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">long</span> timestamp, CheckpointOptions checkpointOptions)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		CheckpointBarrier barrier = <span class="keyword">new</span> CheckpointBarrier(id, timestamp, checkpointOptions);</span><br><span class="line">		<span class="keyword">for</span> (RecordWriterOutput&lt;?&gt; streamOutput : streamOutputs) &#123;</span><br><span class="line">			streamOutput.broadcastEvent(barrier);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Interrupted while broadcasting checkpoint barrier"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下游的operator接收到本barrier，就会触发其自身的checkpoint。</p>
<p>StreamTask在执行完broadcastCheckpointBarrier之后，<br>我们当前的wordcount程序里有两个operator chain，分别是：</p>
<ul>
<li>kafka source -&gt; flatmap</li>
<li>keyed aggregation -&gt; sink</li>
</ul>
<p>我们就按这个顺序来捋一下checkpoint的过程。</p>
<p>1.kafka source的checkpoint过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!running) &#123;</span><br><span class="line">		LOG.debug(<span class="string">"snapshotState() called on closed source"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		unionOffsetStates.clear();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">final</span> AbstractFetcher&lt;?, ?&gt; fetcher = <span class="keyword">this</span>.kafkaFetcher;</span><br><span class="line">		<span class="keyword">if</span> (fetcher == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// the fetcher has not yet been initialized, which means we need to return the</span></span><br><span class="line">			<span class="comment">// originally restored offsets or the assigned partitions</span></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;KafkaTopicPartition, Long&gt; subscribedPartition : subscribedPartitionsToStartOffsets.entrySet()) &#123;</span><br><span class="line">				unionOffsetStates.add(Tuple2.of(subscribedPartition.getKey(), subscribedPartition.getValue()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</span><br><span class="line">				<span class="comment">// the map cannot be asynchronously updated, because only one checkpoint call can happen</span></span><br><span class="line">				<span class="comment">// on this function at a time: either snapshotState() or notifyCheckpointComplete()</span></span><br><span class="line">				pendingOffsetsToCommit.put(context.getCheckpointId(), restoredState);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			HashMap&lt;KafkaTopicPartition, Long&gt; currentOffsets = fetcher.snapshotCurrentState();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</span><br><span class="line">				<span class="comment">// the map cannot be asynchronously updated, because only one checkpoint call can happen</span></span><br><span class="line">				<span class="comment">// on this function at a time: either snapshotState() or notifyCheckpointComplete()</span></span><br><span class="line">				pendingOffsetsToCommit.put(context.getCheckpointId(), currentOffsets);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;KafkaTopicPartition, Long&gt; kafkaTopicPartitionLongEntry : currentOffsets.entrySet()) &#123;</span><br><span class="line">				unionOffsetStates.add(</span><br><span class="line">						Tuple2.of(kafkaTopicPartitionLongEntry.getKey(), kafkaTopicPartitionLongEntry.getValue()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (offsetCommitMode == OffsetCommitMode.ON_CHECKPOINTS) &#123;</span><br><span class="line">			<span class="comment">// truncate the map of pending offsets to commit, to prevent infinite growth</span></span><br><span class="line">			<span class="keyword">while</span> (pendingOffsetsToCommit.size() &gt; MAX_NUM_PENDING_CHECKPOINTS) &#123;</span><br><span class="line">				pendingOffsetsToCommit.remove(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kafka的snapshot逻辑就是记录一下当前消费的offsets，然后做成tuple（partitiion，offset）放进一个StateBackend里。StateBackend是flink抽象出来的一个用于保存状态的接口。</p>
<p>2.<strong>FlatMap算子的checkpoint过程</strong><br>没什么可说的，就是调用了snapshotState()方法而已。</p>
<p>3.<strong>本operator chain的state保存过程</strong><br>细心的同学应该注意到了，各个算子的snapshot方法只把自己的状态保存到了StateBackend里，没有写入的持久化操作。这部分操作被放到了AbstractStreamOperator中，由flink统一负责持久化。其实不需要看源码我们也能想出来，持久化无非就是把这些数据用一个流写到磁盘或者别的地方，接下来我们来看看是不是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//还是AbstractStreamOperator.java的snapshotState方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> != operatorStateBackend) &#123;</span><br><span class="line">	snapshotInProgress.setOperatorStateManagedFuture(</span><br><span class="line">		operatorStateBackend.snapshot(checkpointId, timestamp, factory, checkpointOptions));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个operatorStateBackend是怎么保存状态的呢？</p>
<ul>
<li>首先把各个算子的state做了一份深拷贝；</li>
<li>然后以异步的方式执行了一个内部类的runnable，该内部类的run方法实现了一个模版方法，首先打开stream，然后写入数据，然后再关闭stream。</li>
</ul>
<p>我们来看看这个写入数据的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SnapshotResult&lt;OperatorStateHandle&gt; <span class="title">performOperation</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> asyncStartTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	CheckpointStreamFactory.CheckpointStateOutputStream localOut = <span class="keyword">this</span>.out;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// get the registered operator state infos ...</span></span><br><span class="line">	List&lt;RegisteredOperatorBackendStateMetaInfo.Snapshot&lt;?&gt;&gt; operatorMetaInfoSnapshots =</span><br><span class="line">		<span class="keyword">new</span> ArrayList&lt;&gt;(registeredOperatorStatesDeepCopies.size());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;String, PartitionableListState&lt;?&gt;&gt; entry : registeredOperatorStatesDeepCopies.entrySet()) &#123;</span><br><span class="line">		operatorMetaInfoSnapshots.add(entry.getValue().getStateMetaInfo().snapshot());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... write them all in the checkpoint stream ...</span></span><br><span class="line">	DataOutputView dov = <span class="keyword">new</span> DataOutputViewStreamWrapper(localOut);</span><br><span class="line"></span><br><span class="line">	OperatorBackendSerializationProxy backendSerializationProxy =</span><br><span class="line">		<span class="keyword">new</span> OperatorBackendSerializationProxy(operatorMetaInfoSnapshots, broadcastMetaInfoSnapshots);</span><br><span class="line"></span><br><span class="line">	backendSerializationProxy.write(dov);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释写的很清楚，我就不多说了。</p>
<p>4.<strong>后继operatorChain的checkpoint过程</strong><br>前面说到，在flink的流中，barrier流过时会触发checkpoint。在上面第1步中，上游节点已经发出了Barrier，所以在我们的keyed aggregation -&gt; sink 这个operatorchain中，我们将首先捕获这个barrier。</p>
<p>捕获barrier的过程其实就是处理input数据的过程，对应着StreamInputProcessor.processInput()方法，该方法我们在第四章已经讲过，这里我们简单回顾一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个元素都会触发这一段逻辑，如果下一个数据是buffer，则从外围的while循环里进入处理用户数据的逻辑；这个方法里默默的处理了barrier的逻辑</span></span><br><span class="line"><span class="keyword">final</span> BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</span><br><span class="line"><span class="keyword">if</span> (bufferOrEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">		currentChannel = bufferOrEvent.getChannelIndex();</span><br><span class="line">		currentRecordDeserializer = recordDeserializers[currentChannel];</span><br><span class="line">		currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Event received</span></span><br><span class="line">		<span class="keyword">final</span> AbstractEvent event = bufferOrEvent.getEvent();</span><br><span class="line">		<span class="keyword">if</span> (event.getClass() != EndOfPartitionEvent<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected event: "</span> + event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理barrier的过程在这段代码里没有体现，因为被包含在了etNextNonBlocked()方法中，我们看下这个方法的核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BarrierBuffer.getNextNonBlocked方法</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bufferOrEvent.getEvent().getClass() == CheckpointBarrier<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!endOfStream) &#123;</span><br><span class="line">		<span class="comment">// process barriers only if there is a chance of the checkpoint completing</span></span><br><span class="line">		processBarrier((CheckpointBarrier) bufferOrEvent.getEvent(), bufferOrEvent.getChannelIndex());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bufferOrEvent.getEvent().getClass() == CancelCheckpointMarker<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">	processCancellationBarrier((CancelCheckpointMarker) bufferOrEvent.getEvent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先提一嘴，大家还记得之前的部分也提到过CheckpointMarker吧，这里正好也对上了。</p>
<p>处理barrier也是个麻烦事，大家回想一下5.1节提到的屏障的原理图，一个opertor必须收到从每个inputchannel发过来的同一序号的barrier之后才能发起本节点的checkpoint，如果有的channel的数据处理的快了，那该barrier后的数据还需要缓存起来，如果有的inputchannel被关闭了，那它就不会再发送barrier过来了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBarrier</span><span class="params">(CheckpointBarrier receivedBarrier, <span class="keyword">int</span> channelIndex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">long</span> barrierId = receivedBarrier.getId();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// fast path for single channel cases</span></span><br><span class="line">		<span class="keyword">if</span> (totalNumberOfInputChannels == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">				<span class="comment">// new checkpoint</span></span><br><span class="line">				currentCheckpointId = barrierId;</span><br><span class="line">				notifyCheckpoint(receivedBarrier);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// -- general code path for multiple input channels --</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (numBarriersReceived &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// this is only true if some alignment is already progress and was not canceled</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (barrierId == currentCheckpointId) &#123;</span><br><span class="line">				<span class="comment">// regular case</span></span><br><span class="line">				onBarrier(channelIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">				<span class="comment">// we did not complete the current checkpoint, another started before</span></span><br><span class="line">				LOG.warn(<span class="string">"Received checkpoint barrier for checkpoint &#123;&#125; before completing current checkpoint &#123;&#125;. "</span> +</span><br><span class="line">						<span class="string">"Skipping current checkpoint."</span>, barrierId, currentCheckpointId);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// let the task know we are not completing this</span></span><br><span class="line">				notifyAbort(currentCheckpointId, <span class="keyword">new</span> CheckpointDeclineSubsumedException(barrierId));</span><br><span class="line"></span><br><span class="line">				<span class="comment">// abort the current checkpoint</span></span><br><span class="line">				releaseBlocksAndResetBarriers();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// begin a the new checkpoint</span></span><br><span class="line">				beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// ignore trailing barrier from an earlier checkpoint (obsolete now)</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (barrierId &gt; currentCheckpointId) &#123;</span><br><span class="line">			<span class="comment">// first barrier of a new checkpoint</span></span><br><span class="line">			beginNewAlignment(barrierId, channelIndex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// either the current checkpoint was canceled (numBarriers == 0) or</span></span><br><span class="line">			<span class="comment">// this barrier is from an old subsumed checkpoint</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// check if we have all barriers - since canceled checkpoints always have zero barriers</span></span><br><span class="line">		<span class="comment">// this can only happen on a non canceled checkpoint</span></span><br><span class="line">		<span class="keyword">if</span> (numBarriersReceived + numClosedChannels == totalNumberOfInputChannels) &#123;</span><br><span class="line">			<span class="comment">// actually trigger checkpoint</span></span><br><span class="line">			<span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">				LOG.debug(<span class="string">"Received all barriers, triggering checkpoint &#123;&#125; at &#123;&#125;"</span>,</span><br><span class="line">						receivedBarrier.getId(), receivedBarrier.getTimestamp());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			releaseBlocksAndResetBarriers();</span><br><span class="line">			notifyCheckpoint(receivedBarrier);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>总之，当收到全部的barrier之后，就会触发notifyCheckpoint()，该方法又会调用StreamTask的triggerCheckpoint，和之前的operator是一样的。</p>
<p>如果还有后续的operator的话，就是完全相同的循环，不再赘述。</p>
<p>5.<strong>报告完成checkpoint事件</strong><br>当一个operator保存完checkpoint数据后，就会启动一个异步对象AsyncCheckpointRunnable，用以报告该检查点已完成，其具体逻辑在reportCompletedSnapshotStates中。这个方法把任务又最终委托给了RpcCheckpointResponder这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">checkpointResponder.acknowledgeCheckpoint(</span><br><span class="line">			jobId,</span><br><span class="line">			executionAttemptID,</span><br><span class="line">			checkpointId,</span><br><span class="line">			checkpointMetrics,</span><br><span class="line">			acknowledgedState);</span><br></pre></td></tr></table></figure>
<p>从这个类也可以看出来，它的逻辑是通过rpc的方式远程调JobManager的相关方法完成报告事件，底层也是通过akka实现的。<br>那么，谁响应了这个rpc调用呢？是该任务的JobMaster。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//JobMaster.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acknowledgeCheckpoint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> JobID jobID,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> ExecutionAttemptID executionAttemptID,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> <span class="keyword">long</span> checkpointId,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> CheckpointMetrics checkpointMetrics,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> TaskStateSnapshot checkpointState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> CheckpointCoordinator checkpointCoordinator = executionGraph.getCheckpointCoordinator();</span><br><span class="line">	<span class="keyword">final</span> AcknowledgeCheckpoint ackMessage = <span class="keyword">new</span> AcknowledgeCheckpoint(</span><br><span class="line">		jobID,</span><br><span class="line">		executionAttemptID,</span><br><span class="line">		checkpointId,</span><br><span class="line">		checkpointMetrics,</span><br><span class="line">		checkpointState);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (checkpointCoordinator != <span class="keyword">null</span>) &#123;</span><br><span class="line">		getRpcService().execute(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				checkpointCoordinator.receiveAcknowledgeMessage(ackMessage);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">				log.warn(<span class="string">"Error while processing checkpoint acknowledgement message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.error(<span class="string">"Received AcknowledgeCheckpoint message for job &#123;&#125; with no CheckpointCoordinator"</span>,</span><br><span class="line">				jobGraph.getJobID());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JobMaster反手<del>就是一巴掌</del>就把任务又rpc给了CheckpointCoordinator.receiveAcknowledgeMessage方法。</p>
<p>之前提到，coordinator在触发checkpoint时，生成了一个PendingCheckpoint，保存了所有operator的id。</p>
<p>当PendingCheckpoint收到一个operator的完成checkpoint的消息时，它就把这个operator从未完成checkpoint的节点集合移动到已完成的集合。当所有的operator都报告完成了checkpoint时，CheckpointCoordinator会触发completePendingCheckpoint()方法，该方法做了以下事情：</p>
<ul>
<li>把pendinCgCheckpoint转换为CompletedCheckpoint</li>
<li>把CompletedCheckpoint加入已完成的检查点集合，并从未完成检查点集合删除该检查点</li>
<li>再度向各个operator发出rpc，通知该检查点已完成</li>
</ul>
<p>本文里，收到这个远程调用的就是那两个operator chain，我们来看看其逻辑:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyCheckpointComplete</span><span class="params">(<span class="keyword">long</span> checkpointId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isRunning) &#123;</span><br><span class="line">			LOG.debug(<span class="string">"Notification of complete checkpoint for task &#123;&#125;"</span>, getName());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (StreamOperator&lt;?&gt; operator : operatorChain.getAllOperators()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (operator != <span class="keyword">null</span>) &#123;</span><br><span class="line">					operator.notifyCheckpointComplete(checkpointId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			LOG.debug(<span class="string">"Ignoring notification of complete checkpoint for not-running task &#123;&#125;"</span>, getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来无非就是层层通知对应的算子做出响应罢了。</p>
<p>至此，flink的两阶段提交的checkpoint逻辑全部完成。</p>
<h2 id="4-承载checkpoint数据的抽象：State-amp-StateBackend"><a href="#4-承载checkpoint数据的抽象：State-amp-StateBackend" class="headerlink" title="4 承载checkpoint数据的抽象：State &amp; StateBackend"></a>4 承载checkpoint数据的抽象：State &amp; StateBackend</h2><p>State是快照数据的载体，StateBackend是快照如何被保存的抽象。</p>
<p>State分为 KeyedState和OperatorState，从名字就可以看出来分别对应着keyedStream和其他的oeprator。从State由谁管理上，也可以区分为raw state和Managed state。Flink管理的就是Managed state，用户自己管理的就是raw state。Managed State又分为ValueState、ListState、ReducingState、AggregatingState、FoldingState、MapState这么几种，看名字知用途。</p>
<p>StateBackend目前提供了三个backend，MemoryStateBackend，FsStateBackend，RocksDBStateBackend，都是看名字知用途系列。</p>
<p>State接口、StateBackend接口及其实现都比较简单，代码就不贴了， 尤其State本质上就是一层容器封装。</p>
<p>贴个别人写的状态管理的文章吧：<a href="https://yq.aliyun.com/articles/225623?spm=a2c4e.11153940.blogcont225624.12.7c797f6bZo3tiM" target="_blank" rel="noopener">详解Flink中的状态管理</a></p>
<p>本文至此结束。</p>
]]></content>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink执行流程三</title>
    <url>/2024/09/03/Flink%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%89/</url>
    <content><![CDATA[<h2 id="1-任务的调度与执行"><a href="#1-任务的调度与执行" class="headerlink" title="1.任务的调度与执行"></a>1.任务的调度与执行</h2><p>关于flink的任务执行架构，官网的这两张图就是最好的说明：</p>
<p><img src="/img/image_1cafnu1pl1d8c15m219b8vkb2334.png" alt="image_1cafnu1pl1d8c15m219b8vkb2334.png-112.9kB"></p>
<p>Flink集群启动后，首先会启动一个JobManger和多个的TaskManager。用户的代码会由JobClient提交给JobManager，JobManager再把来自不同用户的任务发给不同的TaskManager去执行，每个TaskManager管理着多个task，task是执行计算的最小结构，TaskManager将心跳和统计信息汇报给JobManager。TaskManager 之间以流的形式进行数据的传输。上述除了task外的三者均为独立的 JVM 进程。<br>要注意的是，TaskManager和job并非一一对应的关系。flink调度的最小单元是task而非TaskManager，也就是说，来自不同job的不同task可能运行于同一个TaskManager的不同线程上。</p>
<p><img src="/img/image_1cclle7ui2j41nf611gs1is18m19.png" alt="image_1cclle7ui2j41nf611gs1is18m19.png-127.5kB"></p>
<p>一个flink任务所有可能的状态如上图所示。图上画的很明白，就不再赘述了。</p>
<h2 id="2-计算资源的调度"><a href="#2-计算资源的调度" class="headerlink" title="2.计算资源的调度"></a>2.计算资源的调度</h2><p>Task Slot是一个TaskManager内资源分配的最小载体，代表了一个固定大小的资源子集，每个TaskManager会将其所占有的资源平分给它的Slot。<br>通过调整Task Slot的数量，用户可以定义task之间是如何相互隔离的。每个TaskManager有一个Slot，也就意味着每个Task运行在独立的JVM中。每个 TaskManager 有多个Slot的话，也就是说多个Task运行在同一个JVM中。<br>而在同一个JVM进程中的Task，可以共享TCP连接（基于多路复用）和心跳消息，可以减少数据的网络传输，也能共享一些数据结构，一定程度上减少了每个Task的消耗。<br>每个Slot可以接受单个Task，也可以接受多个连续Task组成的Pipeline，如下图所示，FlatMap函数占用一个Task Slot，而key Agg函数和sink函数共用一个Task Slot：</p>
<p><img src="/img/image_1cafpf21c1jh3s5ap1fisu4v23h.png" alt="image_1cafpf21c1jh3s5ap1fisu4v23h.png-44.7kB"></p>
<p>为了达到共用Slot的目的，除了可以以chain的方式pipeline算子，我们还可以允许SlotSharingGroup，如下图所示：</p>
<p><img src="/img/image_1cafpko68b3r1lk0dpsnmbj3c3u.png" alt="image_1cafpko68b3r1lk0dpsnmbj3c3u.png-61.2kB"></p>
<p>我们可以把不能被chain成一条的两个操作如flatmap和key&amp;sink放在一个TaskSlot里执行，这样做可以获得以下好处：</p>
<ul>
<li>共用slot使得我们不再需要计算每个任务需要的总task数目，直接取最高算子的并行度即可</li>
<li>对计算资源的利用率更高。例如，通常的轻量级操作map和重量级操作Aggregate不再分别需要一个线程，而是可以在同一个线程内执行，而且对于slot有限的场景，我们可以增大每个task的并行度了。</li>
</ul>
<p>接下来我们还是用官网的图来说明flink是如何重用slot的：</p>
<p><img src="/img/image_1cafqroarkjkuje1hfi18gor654b.png" alt="image_1cafqroarkjkuje1hfi18gor654b.png-137kB"></p>
<ol>
<li>TaskManager1分配一个SharedSlot0</li>
<li>把source task放入一个SimpleSlot0，再把该slot放入SharedSlot0</li>
<li>把flatmap task放入一个SimpleSlot1，再把该slot放入SharedSlot0</li>
<li>因为我们的flatmap task并行度是2，因此不能再放入SharedSlot0，所以向TaskMange21申请了一个新的SharedSlot0</li>
<li>把第二个flatmap task放进一个新的SimpleSlot，并放进TaskManager2的SharedSlot0</li>
<li>开始处理key&amp;sink task，因为其并行度也是2，所以先把第一个task放进TaskManager1的SharedSlot</li>
<li>把第二个key&amp;sink放进TaskManager2的SharedSlot</li>
</ol>
<h2 id="3-JobManager执行job"><a href="#3-JobManager执行job" class="headerlink" title="3.JobManager执行job"></a>3.JobManager执行job</h2><p>JobManager负责接收 flink 的作业，调度 task，收集 job 的状态、管理 TaskManagers。被实现为一个 akka actor。</p>
<h3 id="3-1JobManager的组件"><a href="#3-1JobManager的组件" class="headerlink" title="3.1JobManager的组件"></a>3.1JobManager的组件</h3><ul>
<li>BlobServer 是一个用来管理二进制大文件的服务，比如保存用户上传的jar文件，该服务会将其写到磁盘上。还有一些相关的类，如BlobCache，用于TaskManager向JobManager下载用户的jar文件</li>
<li>InstanceManager 用来管理当前存活的TaskManager的组件，记录了TaskManager的心跳信息等</li>
<li>CompletedCheckpointStore 用于保存已完成的checkpoint相关信息，持久化到内存中或者zookeeper上</li>
<li>MemoryArchivist 保存了已经提交到flink的作业的相关信息，如JobGraph等</li>
</ul>
<h3 id="3-2JobManager的启动过程"><a href="#3-2JobManager的启动过程" class="headerlink" title="3.2JobManager的启动过程"></a>3.2JobManager的启动过程</h3><p>先列出JobManager启动的核心代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">runJobManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      configuration: Configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">      executionMode: JobManagerMode,</span></span></span><br><span class="line"><span class="function"><span class="params">      listeningAddress: String,</span></span></span><br><span class="line"><span class="function"><span class="params">      listeningPort: Int)</span></span></span><br><span class="line"><span class="function">    : Unit </span>= &#123;</span><br><span class="line"></span><br><span class="line">    val numberProcessors = Hardware.getNumberCPUCores()</span><br><span class="line"></span><br><span class="line">    val futureExecutor = Executors.newScheduledThreadPool(</span><br><span class="line">      numberProcessors,</span><br><span class="line">      <span class="keyword">new</span> ExecutorThreadFactory(<span class="string">"jobmanager-future"</span>))</span><br><span class="line"></span><br><span class="line">    val ioExecutor = Executors.newFixedThreadPool(</span><br><span class="line">      numberProcessors,</span><br><span class="line">      <span class="keyword">new</span> ExecutorThreadFactory(<span class="string">"jobmanager-io"</span>))</span><br><span class="line"></span><br><span class="line">    val timeout = AkkaUtils.getTimeout(configuration)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we have to first start the JobManager ActorSystem because this determines the port if 0</span></span><br><span class="line">    <span class="comment">// was chosen before. The method startActorSystem will update the configuration correspondingly.</span></span><br><span class="line">    val jobManagerSystem = startActorSystem(</span><br><span class="line">      configuration,</span><br><span class="line">      listeningAddress,</span><br><span class="line">      listeningPort)</span><br><span class="line"></span><br><span class="line">    val highAvailabilityServices = HighAvailabilityServicesUtils.createHighAvailabilityServices(</span><br><span class="line">      configuration,</span><br><span class="line">      ioExecutor,</span><br><span class="line">      AddressResolution.NO_ADDRESS_RESOLUTION)</span><br><span class="line"></span><br><span class="line">    val metricRegistry = <span class="keyword">new</span> MetricRegistryImpl(</span><br><span class="line">      MetricRegistryConfiguration.fromConfiguration(configuration))</span><br><span class="line"></span><br><span class="line">    metricRegistry.startQueryService(jobManagerSystem, <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line">    val (_, _, webMonitorOption, _) = <span class="keyword">try</span> &#123;</span><br><span class="line">      startJobManagerActors(</span><br><span class="line">        jobManagerSystem,</span><br><span class="line">        configuration,</span><br><span class="line">        executionMode,</span><br><span class="line">        listeningAddress,</span><br><span class="line">        futureExecutor,</span><br><span class="line">        ioExecutor,</span><br><span class="line">        highAvailabilityServices,</span><br><span class="line">        metricRegistry,</span><br><span class="line">        classOf[JobManager],</span><br><span class="line">        classOf[MemoryArchivist],</span><br><span class="line">        Option(classOf[StandaloneResourceManager])</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t: Throwable =&gt;</span><br><span class="line">        futureExecutor.shutdownNow()</span><br><span class="line">        ioExecutor.shutdownNow()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> t</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block until everything is shut down</span></span><br><span class="line">    jobManagerSystem.awaitTermination()</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码主要做了以下事情：</p>
<ul>
<li>配置Akka并生成ActorSystem，启动JobManager</li>
<li>启动HA和metric相关服务</li>
<li>在<em>startJobManagerActors()</em>方法中启动JobManagerActors，以及webserver，TaskManagerActor，ResourceManager等等</li>
<li>阻塞等待终止</li>
<li>集群通过LeaderService等选出JobManager的leader</li>
</ul>
<h3 id="3-3-JobManager启动Task"><a href="#3-3-JobManager启动Task" class="headerlink" title="3.3 JobManager启动Task"></a>3.3 JobManager启动Task</h3><p>JobManager 是一个Actor，通过各种消息来完成核心逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">override def handleMessage: Receive = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">case</span> <span class="title">GrantLeadership</span><span class="params">(newLeaderSessionID)</span> </span>=&gt;</span><br><span class="line">    log.info(s<span class="string">"JobManager $getAddress was granted leadership with leader session ID "</span> +</span><br><span class="line">      s<span class="string">"$newLeaderSessionID."</span>)</span><br><span class="line">    leaderSessionID = newLeaderSessionID</span><br><span class="line"></span><br><span class="line">    .......</span><br></pre></td></tr></table></figure>
<p>有几个比较重要的消息：</p>
<ul>
<li>GrantLeadership 获得leader授权，将自身被分发到的 session id 写到 zookeeper，并恢复所有的 jobs</li>
<li>RevokeLeadership 剥夺leader授权，打断清空所有的 job 信息，但是保留作业缓存，注销所有的 TaskManagers</li>
<li>RegisterTaskManagers 注册 TaskManager，如果之前已经注册过，则只给对应的 Instance 发送消息，否则启动注册逻辑：在 InstanceManager 中注册该 Instance 的信息，并停止 Instance BlobLibraryCacheManager 的端口【供下载 lib 包用】，同时使用 watch 监听 task manager 的存活</li>
<li>SubmitJob 提交 jobGraph</li>
</ul>
<p>最后一项SubmintJob就是我们要关注的，从客户端收到JobGraph，转换为ExecutionGraph并执行的过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">submitJob</span><span class="params">(jobGraph: JobGraph, jobInfo: JobInfo, isRecovery: Boolean = <span class="keyword">false</span>)</span>: Unit </span>= &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    executionGraph = ExecutionGraphBuilder.buildGraph(</span><br><span class="line">          executionGraph,</span><br><span class="line">          jobGraph,</span><br><span class="line">          flinkConfiguration,</span><br><span class="line">          futureExecutor,</span><br><span class="line">          ioExecutor,</span><br><span class="line">          scheduler,</span><br><span class="line">          userCodeLoader,</span><br><span class="line">          checkpointRecoveryFactory,</span><br><span class="line">          Time.of(timeout.length, timeout.unit),</span><br><span class="line">          restartStrategy,</span><br><span class="line">          jobMetrics,</span><br><span class="line">          numSlots,</span><br><span class="line">          blobServer,</span><br><span class="line">          log.logger)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leaderElectionService.hasLeadership) &#123;</span><br><span class="line">            log.info(s<span class="string">"Scheduling job $jobId ($jobName)."</span>)</span><br><span class="line"></span><br><span class="line">            executionGraph.scheduleForExecution()</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            self ! decorateMessage(RemoveJob(jobId, removeJobFromStateBackend = <span class="keyword">false</span>))</span><br><span class="line"></span><br><span class="line">            log.warn(s<span class="string">"Submitted job $jobId, but not leader. The other leader needs to recover "</span> +</span><br><span class="line">              <span class="string">"this. I am not scheduling the job for execution."</span>)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先做一些准备工作，然后获取一个ExecutionGraph，判断是否是恢复的job，然后将job保存下来，并且通知客户端本地已经提交成功了，最后如果确认本JobManager是leader，则执行<em>executionGraph.scheduleForExecution()</em>方法，这个方法经过一系列调用，把每个ExecutionVertex传递给了Excution类的deploy方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deploy</span><span class="params">()</span> <span class="keyword">throws</span> JobException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// good, we are allowed to deploy</span></span><br><span class="line">			<span class="keyword">if</span> (!slot.setExecutedVertex(<span class="keyword">this</span>)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> JobException(<span class="string">"Could not assign the ExecutionVertex to the slot "</span> + slot);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// race double check, did we fail/cancel and do we need to release the slot?</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.state != DEPLOYING) &#123;</span><br><span class="line">				slot.releaseSlot();</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (LOG.isInfoEnabled()) &#123;</span><br><span class="line">				LOG.info(String.format(<span class="string">"Deploying %s (attempt #%d) to %s"</span>, vertex.getTaskNameWithSubtaskIndex(),</span><br><span class="line">						attemptNumber, getAssignedResourceLocation().getHostname()));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(</span><br><span class="line">				attemptId,</span><br><span class="line">				slot,</span><br><span class="line">				taskState,</span><br><span class="line">				attemptNumber);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; submitResultFuture = taskManagerGateway.submitTask(deployment, timeout);</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">			markFailed(t);</span><br><span class="line">			ExceptionUtils.rethrow(t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先生成了一个TaskDeploymentDescriptor，然后交给了<em>taskManagerGateway.submitTask()</em>方法执行。接下来的部分，就属于TaskManager的范畴了</p>
<h2 id="4-TaskManager执行task"><a href="#4-TaskManager执行task" class="headerlink" title="4.TaskManager执行task"></a>4.TaskManager执行task</h2><h3 id="4-1-TaskManager的基本组件"><a href="#4-1-TaskManager的基本组件" class="headerlink" title="4.1 TaskManager的基本组件"></a>4.1 TaskManager的基本组件</h3><p>TaskManager是flink中资源管理的基本组件，是所有执行任务的基本容器，提供了内存管理、IO管理、通信管理等一系列功能，本节对各个模块进行简要介绍。</p>
<ol>
<li>MemoryManager flink并没有把所有内存的管理都委托给JVM，因为JVM普遍存在着存储对象密度低、大内存时GC对系统影响大等问题。所以flink自己抽象了一套内存管理机制，将所有对象序列化后放在自己的MemorySegment上进行管理。MemoryManger涉及内容较多，将在后续章节进行继续剖析。</li>
<li>IOManager flink通过IOManager管理磁盘IO的过程，提供了同步和异步两种写模式，又进一步区分了block、buffer和bulk三种读写方式。<br>IOManager提供了两种方式枚举磁盘文件，一种是直接遍历文件夹下所有文件，另一种是计数器方式，对每个文件名以递增顺序访问。<br>在底层，flink将文件IO抽象为FileIOChannle，封装了底层实现。<br><img src="/img/image_1cag7idg4vfj1l871n0l1k0e1f7u4o.png" alt="image_1cag7idg4vfj1l871n0l1k0e1f7u4o.png-194.1kB"><br>可以看到，flink在底层实际上都是以异步的方式进行读写。</li>
<li>NetworkEnvironment 是TaskManager的网络 IO 组件，包含了追踪中间结果和数据交换的数据结构。它的构造器会统一将配置的内存先分配出来，抽象成 NetworkBufferPool 统一管理内存的申请和释放。意思是说，在输入和输出数据时，不管是保留在本地内存，等待chain在一起的下个操作符进行处理，还是通过网络把本操作符的计算结果发送出去，都被抽象成了NetworkBufferPool。后续我们还将对这个组件进行详细分析。</li>
</ol>
<h3 id="4-2-TaskManager执行Task"><a href="#4-2-TaskManager执行Task" class="headerlink" title="4.2 TaskManager执行Task"></a>4.2 TaskManager执行Task</h3><p>对于TM来说，执行task就是把收到的<em>TaskDeploymentDescriptor</em>对象转换成一个task并执行的过程。TaskDeploymentDescriptor这个类保存了task执行所必须的所有内容，例如序列化的算子，输入的InputGate和输出的ResultPartition的定义，该task要作为几个subtask执行等等。<br>按照正常逻辑思维，很容易想到TM的submitTask方法的行为：首先是确认资源，如寻找JobManager和Blob，而后建立连接，解序列化算子，收集task相关信息，接下来就是创建一个新的Task对象，这个Task对象就是真正执行任务的关键所在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">val task = <span class="keyword">new</span> Task(</span><br><span class="line">        jobInformation,</span><br><span class="line">        taskInformation,</span><br><span class="line">        tdd.getExecutionAttemptId,</span><br><span class="line">        tdd.getAllocationId,</span><br><span class="line">        tdd.getSubtaskIndex,</span><br><span class="line">        tdd.getAttemptNumber,</span><br><span class="line">        tdd.getProducedPartitions,</span><br><span class="line">        tdd.getInputGates,</span><br><span class="line">        tdd.getTargetSlotNumber,</span><br><span class="line">        tdd.getTaskStateHandles,</span><br><span class="line">        memoryManager,</span><br><span class="line">        ioManager,</span><br><span class="line">        network,</span><br><span class="line">        bcVarManager,</span><br><span class="line">        taskManagerConnection,</span><br><span class="line">        inputSplitProvider,</span><br><span class="line">        checkpointResponder,</span><br><span class="line">        blobCache,</span><br><span class="line">        libCache,</span><br><span class="line">        fileCache,</span><br><span class="line">        config,</span><br><span class="line">        taskMetricGroup,</span><br><span class="line">        resultPartitionConsumableNotifier,</span><br><span class="line">        partitionStateChecker,</span><br><span class="line">        context.dispatcher)</span><br></pre></td></tr></table></figure>
<p>如果读者是从头开始看这篇blog，里面有很多对象应该已经比较明确其作用了（除了那个brVarManager，这个是管理广播变量的，广播变量是一类会被分发到每个任务中的共享变量）。接下来的主要任务，就是把这个task启动起来,然后报告说已经启动task了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// all good, we kick off the task, which performs its own initialization</span></span><br><span class="line">task.startTaskThread()</span><br><span class="line"></span><br><span class="line">sender ! decorateMessage(Acknowledge.get())</span><br></pre></td></tr></table></figure>
<h3 id="4-3-生成Task对象"><a href="#4-3-生成Task对象" class="headerlink" title="4.3 生成Task对象"></a>4.3 生成Task对象</h3><p>在执行new Task()方法时，第一步是把构造函数里的这些变量赋值给当前task的fields。<br>接下来是初始化ResultPartition和InputGate。这两个类描述了task的输出数据和输入数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ResultPartitionDeploymentDescriptor desc: resultPartitionDeploymentDescriptors) &#123;</span><br><span class="line">	ResultPartitionID partitionId = <span class="keyword">new</span> ResultPartitionID(desc.getPartitionId(), executionId);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.producedPartitions[counter] = <span class="keyword">new</span> ResultPartition(</span><br><span class="line">	    taskNameWithSubtaskAndId,</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		jobId,</span><br><span class="line">		partitionId,</span><br><span class="line">		desc.getPartitionType(),</span><br><span class="line">		desc.getNumberOfSubpartitions(),</span><br><span class="line">		desc.getMaxParallelism(),</span><br><span class="line">		networkEnvironment.getResultPartitionManager(),</span><br><span class="line">		resultPartitionConsumableNotifier,</span><br><span class="line">		ioManager,</span><br><span class="line">		desc.sendScheduleOrUpdateConsumersMessage());		</span><br><span class="line">	<span class="comment">//为每个partition初始化对应的writer</span></span><br><span class="line">	writers[counter] = <span class="keyword">new</span> ResultPartitionWriter(producedPartitions[counter]);</span><br><span class="line"></span><br><span class="line">	++counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consumed intermediate result partitions</span></span><br><span class="line"><span class="keyword">this</span>.inputGates = <span class="keyword">new</span> SingleInputGate[inputGateDeploymentDescriptors.size()];</span><br><span class="line"><span class="keyword">this</span>.inputGatesById = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (InputGateDeploymentDescriptor inputGateDeploymentDescriptor: inputGateDeploymentDescriptors) &#123;</span><br><span class="line">	SingleInputGate gate = SingleInputGate.create(</span><br><span class="line">		taskNameWithSubtaskAndId,</span><br><span class="line">		jobId,</span><br><span class="line">		executionId,</span><br><span class="line">		inputGateDeploymentDescriptor,</span><br><span class="line">		networkEnvironment,</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		metricGroup.getIOMetricGroup());</span><br><span class="line"></span><br><span class="line">	inputGates[counter] = gate;</span><br><span class="line">	inputGatesById.put(gate.getConsumedResultId(), gate);</span><br><span class="line"></span><br><span class="line">	++counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，创建一个Thread对象，并把自己放进该对象，这样在执行时，自己就有了自身的线程的引用。</p>
<h3 id="4-4-运行Task对象"><a href="#4-4-运行Task对象" class="headerlink" title="4.4 运行Task对象"></a>4.4 运行Task对象</h3><p>Task对象本身就是一个Runable，因此在其run方法里定义了运行逻辑。第一步是切换Task的状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	ExecutionState current = <span class="keyword">this</span>.executionState;</span><br><span class="line">	<span class="comment">////如果当前的执行状态为CREATED，则将其设置为DEPLOYING状态</span></span><br><span class="line">	<span class="keyword">if</span> (current == ExecutionState.CREATED) &#123;</span><br><span class="line">		<span class="keyword">if</span> (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</span><br><span class="line">			<span class="comment">// success, we can start our work</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果当前执行状态为FAILED，则发出通知并退出run方法</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current == ExecutionState.FAILED) &#123;</span><br><span class="line">		<span class="comment">// we were immediately failed. tell the TaskManager that we reached our final state</span></span><br><span class="line">		notifyFinalState();</span><br><span class="line">		<span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">			metrics.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果当前执行状态为CANCELING，则将其修改为CANCELED状态，并退出run</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current == ExecutionState.CANCELING) &#123;</span><br><span class="line">		<span class="keyword">if</span> (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</span><br><span class="line">			<span class="comment">// we were immediately canceled. tell the TaskManager that we reached our final state</span></span><br><span class="line">			notifyFinalState();</span><br><span class="line">			<span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">				metrics.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//否则说明发生了异常</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">			metrics.close();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Invalid state for beginning of operation of task "</span> + <span class="keyword">this</span> + <span class="string">'.'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里有个值得关注的点，就是flink里大量使用了这种while(true)的写法来修改和检测状态，emmm…<br>接下来，就是导入用户类加载器并加载用户代码。<br>然后，是向网络管理器注册当前任务（flink的各个算子在运行时进行数据交换需要依赖网络管理器），分配一些缓存以保存数据<br>然后，读入指定的缓存文件。<br>然后，再把task创建时传入的那一大堆变量用于创建一个执行环境Envrionment。<br>再然后，对于那些并不是第一次执行的task（比如失败后重启的）要恢复其状态。<br>接下来最重要方法的是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">invokable.invoke();</span><br></pre></td></tr></table></figure>
<p>为什么这么说呢，因为这个方法就是用户代码所真正被执行的入口。比如我们写的什么new MapFunction()的逻辑，最终就是在这里被执行的。这里说一下这个invokable，这是一个抽象类，提供了可以被TaskManager执行的对象的基本抽象。<br>这个invokable是在解析JobGraph的时候生成相关信息的，并在此处形成真正可执行的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// now load the task's invokable code</span></span><br><span class="line"><span class="comment">//通过反射生成对象</span></span><br><span class="line">invokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass);</span><br></pre></td></tr></table></figure>
<p><img src="/img/image_1cbkaa8r9182i18ct1kfu8g829m9.png" alt="image_1cbkaa8r9182i18ct1kfu8g829m9.png-29.9kB"></p>
<p>上图显示了flink提供的可被执行的Task类型。从名字上就可以看出各个task的作用，在此不再赘述。<br>接下来就是invoke方法了，因为我们的wordcount例子用了流式api，在此我们以StreamTask的invoke方法为例进行说明。</p>
<h3 id="4-5-StreamTask的执行逻辑"><a href="#4-5-StreamTask的执行逻辑" class="headerlink" title="4.5 StreamTask的执行逻辑"></a>4.5 StreamTask的执行逻辑</h3><p>先上部分核心代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">boolean</span> disposed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// -------- Initialize ---------</span></span><br><span class="line">			<span class="comment">//先做一些赋值操作</span></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// if the clock is not already set, then assign a default TimeServiceProvider</span></span><br><span class="line">	<span class="comment">//处理timer</span></span><br><span class="line">	<span class="keyword">if</span> (timerService == <span class="keyword">null</span>) &#123;</span><br><span class="line">		ThreadFactory timerThreadFactory =</span><br><span class="line">			<span class="keyword">new</span> DispatcherThreadFactory(TRIGGER_THREAD_GROUP, <span class="string">"Time Trigger for "</span> + getName());</span><br><span class="line"></span><br><span class="line">		timerService = <span class="keyword">new</span> SystemProcessingTimeService(<span class="keyword">this</span>, getCheckpointLock(), timerThreadFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把之前JobGraph串起来的chain的信息形成实现</span></span><br><span class="line">	operatorChain = <span class="keyword">new</span> OperatorChain&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">	headOperator = operatorChain.getHeadOperator();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// task specific initialization</span></span><br><span class="line">	<span class="comment">//这个init操作的起名非常诡异，因为这里主要是处理算子采用了自定义的checkpoint检查机制的情况，但是起了一个非常大众脸的名字</span></span><br><span class="line">	init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// save the work of reloading state, etc, if the task is already canceled</span></span><br><span class="line">	<span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> CancelTaskException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// -------- Invoke --------</span></span><br><span class="line">	LOG.debug(<span class="string">"Invoking &#123;&#125;"</span>, getName());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we need to make sure that any triggers scheduled in open() cannot be</span></span><br><span class="line">	<span class="comment">// executed before all operators are opened</span></span><br><span class="line">	<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// both the following operations are protected by the lock</span></span><br><span class="line">		<span class="comment">// so that we avoid race conditions in the case that initializeState()</span></span><br><span class="line">		<span class="comment">// registers a timer, that fires before the open() is called.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化操作符状态，主要是一些state啥的</span></span><br><span class="line">		initializeState();</span><br><span class="line">		<span class="comment">//对于富操作符，执行其open操作</span></span><br><span class="line">		openAllOperators();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// final check to exit early before starting to run</span></span><br><span class="line">	f (canceled) &#123;</span><br><span class="line">	    <span class="keyword">throw</span> <span class="keyword">new</span> CancelTaskException();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// let the task do its work</span></span><br><span class="line">	<span class="comment">//真正开始执行的代码</span></span><br><span class="line">	isRunning = <span class="keyword">true</span>;</span><br><span class="line">	run();</span><br></pre></td></tr></table></figure>
<p>StreamTask.invoke()方法里，第一个值得一说的是<em>TimerService</em>。Flink在2015年决定向StreamTask类加入timer service的时候解释到：</p>
<blockquote>
<p>This integrates the timer as a service in StreamTask that StreamOperators can use by calling a method on the StreamingRuntimeContext. This also ensures that the timer callbacks can not be called concurrently with other methods on the StreamOperator. This behaviour is ensured by an ITCase.</p>
</blockquote>
<p>第二个要注意的是chain操作。前面提到了，flink会出于优化的角度，把一些算子chain成一个整体的算子作为一个task来执行。比如wordcount例子中，Source和FlatMap算子就被chain在了一起。在进行chain操作的时候，会设定头节点，并且指定输出的RecordWriter。</p>
<p>接下来不出所料仍然是初始化，只不过初始化的对象变成了各个operator。如果是有checkpoint的，那就从state信息里恢复，不然就作为全新的算子处理。从源码中可以看到，flink针对keyed算子和普通算子做了不同的处理。keyed算子在初始化时需要计算出一个group区间，这个区间的值在整个生命周期里都不会再变化，后面key就会根据hash的不同结果，分配到特定的group中去计算。顺便提一句，flink的keyed算子保存的是对每个数据的key的计算方法，而非真实的key，用户需要自己保证对每一行数据提供的keySelector的幂等性。至于为什么要用KeyGroup的设计，这就牵扯到扩容的范畴了，将在后面的章节进行讲述。</p>
<p>对于<em>openAllOperators()</em>方法，就是对各种RichOperator执行其open方法，通常可用于在执行计算之前加载资源。<br>最后，run方法千呼万唤始出来，该方法经过一系列跳转，最终调用chain上的第一个算子的run方法。在wordcount的例子中，它最终调用了SocketTextStreamFunction的run，建立socket连接并读入文本。</p>
<h2 id="5-StreamTask与StreamOperator"><a href="#5-StreamTask与StreamOperator" class="headerlink" title="5. StreamTask与StreamOperator"></a>5. StreamTask与StreamOperator</h2><p>前面提到，Task对象在执行过程中，把执行的任务交给了StreamTask这个类去执行。在我们的wordcount例子中，实际初始化的是OneInputStreamTask的对象（参考上面的类图）。那么这个对象是如何执行用户的代码的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">// cache processor reference on the stack, to make the code more JIT friendly</span></span><br><span class="line">	<span class="keyword">final</span> StreamInputProcessor&lt;IN&gt; inputProcessor = <span class="keyword">this</span>.inputProcessor;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (running &amp;&amp; inputProcessor.processInput()) &#123;</span><br><span class="line">		<span class="comment">// all the work happens in the "processInput" method</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它做的，就是把任务直接交给了InputProcessor去执行processInput方法。这是一个<em>StreamInputProcessor</em>的实例，该processor的任务就是处理输入的数据，包括用户数据、watermark和checkpoint数据等。我们先来看看这个processor是如何产生的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	StreamConfig configuration = getConfiguration();</span><br><span class="line"></span><br><span class="line">	TypeSerializer&lt;IN&gt; inSerializer = configuration.getTypeSerializerIn1(getUserCodeClassLoader());</span><br><span class="line">	<span class="keyword">int</span> numberOfInputs = configuration.getNumberOfInputs();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (numberOfInputs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		InputGate[] inputGates = getEnvironment().getAllInputGates();</span><br><span class="line"></span><br><span class="line">		inputProcessor = <span class="keyword">new</span> StreamInputProcessor&lt;&gt;(</span><br><span class="line">				inputGates,</span><br><span class="line">				inSerializer,</span><br><span class="line">				<span class="keyword">this</span>,</span><br><span class="line">				configuration.getCheckpointMode(),</span><br><span class="line">				getCheckpointLock(),</span><br><span class="line">				getEnvironment().getIOManager(),</span><br><span class="line">				getEnvironment().getTaskManagerInfo().getConfiguration(),</span><br><span class="line">				getStreamStatusMaintainer(),</span><br><span class="line">				<span class="keyword">this</span>.headOperator);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// make sure that stream tasks report their I/O statistics</span></span><br><span class="line">		inputProcessor.setMetricGroup(getEnvironment().getMetricGroup().getIOMetricGroup());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是OneInputStreamTask的init方法，从configs里面获取StreamOperator信息，生成自己的inputProcessor。那么inputProcessor是如何处理数据的呢？我们接着跟进源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">processInput</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (isFinished) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (numRecordsIn == <span class="keyword">null</span>) &#123;</span><br><span class="line">		numRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	    <span class="comment">//注意 1在下面</span></span><br><span class="line">	    <span class="comment">//2.接下来，会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作</span></span><br><span class="line">		<span class="keyword">if</span> (currentRecordDeserializer != <span class="keyword">null</span>) &#123;</span><br><span class="line">			DeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result.isBufferConsumed()) &#123;</span><br><span class="line">				currentRecordDeserializer.getCurrentBuffer().recycle();</span><br><span class="line">				currentRecordDeserializer = <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (result.isFullRecord()) &#123;</span><br><span class="line">				StreamElement recordOrMark = deserializationDelegate.getInstance();</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在），</span></span><br><span class="line">				<span class="keyword">if</span> (recordOrMark.isWatermark()) &#123;</span><br><span class="line">					<span class="comment">// handle watermark</span></span><br><span class="line">					statusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (recordOrMark.isStreamStatus()) &#123;</span><br><span class="line">				<span class="comment">//如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。</span></span><br><span class="line">					<span class="comment">// handle stream status</span></span><br><span class="line">					statusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (recordOrMark.isLatencyMarker()) &#123;</span><br><span class="line">				<span class="comment">//LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间</span></span><br><span class="line">					<span class="comment">// handle latency marker</span></span><br><span class="line">					<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">						streamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//这里就是真正的，用户的代码即将被执行的地方。从章节1到这里足足用了三万字，有点万里长征的感觉</span></span><br><span class="line">					<span class="comment">// now we can do the actual processing</span></span><br><span class="line">					StreamRecord&lt;IN&gt; record = recordOrMark.asRecord();</span><br><span class="line">					<span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">						numRecordsIn.inc();</span><br><span class="line">						streamOperator.setKeyContextElement1(record);</span><br><span class="line">						streamOperator.processElement(record);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//1.程序首先获取下一个buffer</span></span><br><span class="line">          <span class="comment">//这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器</span></span><br><span class="line">		<span class="keyword">final</span> BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</span><br><span class="line">		<span class="keyword">if</span> (bufferOrEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">				currentChannel = bufferOrEvent.getChannelIndex();</span><br><span class="line">				currentRecordDeserializer = recordDeserializers[currentChannel];</span><br><span class="line">				currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// Event received</span></span><br><span class="line">				<span class="keyword">final</span> AbstractEvent event = bufferOrEvent.getEvent();</span><br><span class="line">				<span class="keyword">if</span> (event.getClass() != EndOfPartitionEvent<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unexpected event: "</span> + event);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			isFinished = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!barrierHandler.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Trailing data in checkpoint barrier handler."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此为止，以上部分就是一个flink程序启动后，到执行用户代码之前，flink框架所做的准备工作。回顾一下：</p>
<ul>
<li>启动一个环境</li>
<li>生成StreamGraph</li>
<li>注册和选举JobManager</li>
<li>在各节点生成TaskManager，并根据JobGraph生成对应的Task</li>
<li>启动各个task，准备执行代码</li>
</ul>
<p>接下来，我们挑几个Operator看看flink是如何抽象这些算子的。</p>
]]></content>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink执行流程二</title>
    <url>/2024/09/03/Flink%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="1-理解flink的图结构"><a href="#1-理解flink的图结构" class="headerlink" title="1.理解flink的图结构"></a>1.理解flink的图结构</h2><p>第一部分讲到，我们的主函数最后一项任务就是生成StreamGraph，然后生成JobGraph，然后以此开始调度任务运行，所以接下来我们从这里入手，继续探索flink。</p>
<h2 id="1-1-flink的三层图结构"><a href="#1-1-flink的三层图结构" class="headerlink" title="1.1 flink的三层图结构"></a>1.1 flink的三层图结构</h2><p>事实上，flink总共提供了三种图的抽象，我们前面已经提到了StreamGraph和JobGraph，还有一种是ExecutionGraph，是用于调度的基本数据结构。</p>
<p><img src="/img/image_1caf1oll019fp1odv1bh9idosr79.png" alt="image_1caf1oll019fp1odv1bh9idosr79.png-486.3kB"></p>
<p>上面这张图清晰的给出了flink各个图的工作原理和转换过程。其中最后一个物理执行图并非flink的数据结构，而是程序开始执行后，各个task分布在不同的节点上，所形成的物理上的关系表示。</p>
<ul>
<li>从JobGraph的图里可以看到，数据从上一个operator流到下一个operator的过程中，上游作为生产者提供了IntermediateDataSet，而下游作为消费者需要JobEdge。事实上，JobEdge是一个通信管道，连接了上游生产的dataset和下游的JobVertex节点。</li>
<li>在JobGraph转换到ExecutionGraph的过程中，主要发生了以下转变：<ul>
<li>加入了并行度的概念，成为真正可调度的图结构</li>
<li>生成了与JobVertex对应的ExecutionJobVertex，ExecutionVertex，与IntermediateDataSet对应的IntermediateResult和IntermediateResultPartition等，并行将通过这些类实现</li>
</ul>
</li>
<li>ExecutionGraph已经可以用于调度任务。我们可以看到，flink根据该图生成了一一对应的Task，每个task对应一个ExecutionGraph的一个Execution。Task用InputGate、InputChannel和ResultPartition对应了上面图中的IntermediateResult和ExecutionEdge。</li>
</ul>
<p>那么，flink抽象出这三层图结构，四层执行逻辑的意义是什么呢？<br>StreamGraph是对用户逻辑的映射。JobGraph在此基础上进行了一些优化，比如把一部分操作串成chain以提高效率。ExecutionGraph是为了调度存在的，加入了并行处理的概念。而在此基础上真正执行的是Task及其相关结构。</p>
<h2 id="2-StreamGraph的生成"><a href="#2-StreamGraph的生成" class="headerlink" title="2.StreamGraph的生成"></a>2.StreamGraph的生成</h2><p>在第一节的算子注册部分，我们可以看到，flink把每一个算子transform成一个对流的转换（比如上文中返回的SingleOutputStreamOperator是一个DataStream的子类），并且注册到执行环境中，用于生成StreamGraph。实际生成StreamGraph的入口是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//其中的transformations是一个list，里面记录的就是我们在transform方法中放进来的算子。</span></span><br><span class="line">StreamGraphGenerator.generate(env, transformations)</span><br></pre></td></tr></table></figure>
<p>StreamTransformation代表了从一个或多个DataStream生成新DataStream的操作。顺便，DataStream类在内部组合了一个StreamTransformation类，实际的转换操作均通过该类完成。<br><img src="/img/image_1caf64b7c1gjnv2eebi1v9e1cvum.png" alt="image_1caf64b7c1gjnv2eebi1v9e1cvum.png-129.4kB"><br>我们可以看到，从source到各种map,union再到sink操作全部被映射成了StreamTransformation。<br>其映射过程如下所示：<br><img src="/img/image_1caf6ak4rkqsc1u1hci93fe0d13.png" alt="image_1caf6ak4rkqsc1u1hci93fe0d13.png-36.6kB"></p>
<p>以MapFunction为例：</p>
<ul>
<li>首先，用户代码里定义的UDF会被当作其基类对待，然后交给StreamMap这个operator做进一步包装。事实上，每一个Transformation都对应了一个StreamOperator。</li>
<li>由于map这个操作只接受一个输入，所以再被进一步包装为OneInputTransformation。</li>
<li>最后，将该transformation注册到执行环境中，当执行上文提到的generate方法时，生成StreamGraph图结构。</li>
</ul>
<p>另外，并不是每一个StreamTransformation都会转换成runtime层中的物理操作。有一些只是逻辑概念，比如union、split/select、partition等。如下图所示的转换树，在运行时会优化成下方的操作图</p>
<p><img src="/img/image_1caf71h79s0s3fodem1aeb1j3m1g.png" alt="image_1caf71h79s0s3fodem1aeb1j3m1g.png-83.8kB"></p>
<h2 id="3-StreamGraph生成函数分析"><a href="#3-StreamGraph生成函数分析" class="headerlink" title="3.StreamGraph生成函数分析"></a>3.StreamGraph生成函数分析</h2><p>我们从StreamGraphGenerator.generate()方法往下看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StreamGraph <span class="title">generate</span><span class="params">(StreamExecutionEnvironment env, List&lt;StreamTransformation&lt;?&gt;&gt; transformations)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> StreamGraphGenerator(env).generateInternal(transformations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//注意，StreamGraph的生成是从sink开始的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> StreamGraph <span class="title">generateInternal</span><span class="params">(List&lt;StreamTransformation&lt;?&gt;&gt; transformations)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (StreamTransformation&lt;?&gt; transformation: transformations) &#123;</span><br><span class="line">		transform(transformation);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> streamGraph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个方法的核心逻辑就是判断传入的steamOperator是哪种类型，并执行相应的操作，详情见下面那一大堆if-else</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Collection&lt;Integer&gt; <span class="title">transform</span><span class="params">(StreamTransformation&lt;?&gt; transform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">		<span class="keyword">return</span> alreadyTransformed.get(transform);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LOG.debug(<span class="string">"Transforming "</span> + transform);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (transform.getMaxParallelism() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// if the max parallelism hasn't been set, then first use the job wide max parallelism</span></span><br><span class="line">		<span class="comment">// from theExecutionConfig.</span></span><br><span class="line">		<span class="keyword">int</span> globalMaxParallelismFromConfig = env.getConfig().getMaxParallelism();</span><br><span class="line">		<span class="keyword">if</span> (globalMaxParallelismFromConfig &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			transform.setMaxParallelism(globalMaxParallelismFromConfig);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call at least once to trigger exceptions about MissingTypeInfo</span></span><br><span class="line">	transform.getOutputType();</span><br><span class="line"></span><br><span class="line">	Collection&lt;Integer&gt; transformedIds;</span><br><span class="line">	<span class="comment">//这里对操作符的类型进行判断，并以此调用相应的处理逻辑.简而言之，处理的核心无非是递归的将该节点和节点的上游节点加入图</span></span><br><span class="line">	<span class="keyword">if</span> (transform <span class="keyword">instanceof</span> OneInputTransformation&lt;?, ?&gt;) &#123;</span><br><span class="line">		transformedIds = transformOneInputTransform((OneInputTransformation&lt;?, ?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> TwoInputTransformation&lt;?, ?, ?&gt;) &#123;</span><br><span class="line">		transformedIds = transformTwoInputTransform((TwoInputTransformation&lt;?, ?, ?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SourceTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformSource((SourceTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SinkTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformSink((SinkTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> UnionTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformUnion((UnionTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SplitTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformSplit((SplitTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SelectTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformSelect((SelectTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> FeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformFeedback((FeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> CoFeedbackTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformCoFeedback((CoFeedbackTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> PartitionTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformPartition((PartitionTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (transform <span class="keyword">instanceof</span> SideOutputTransformation&lt;?&gt;) &#123;</span><br><span class="line">		transformedIds = transformSideOutput((SideOutputTransformation&lt;?&gt;) transform);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown transformation: "</span> + transform);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//注意这里和函数开始时的方法相对应，在有向图中要注意避免循环的产生</span></span><br><span class="line">	<span class="comment">// need this check because the iterate transformation adds itself before</span></span><br><span class="line">	<span class="comment">// transforming the feedback edges</span></span><br><span class="line">	<span class="keyword">if</span> (!alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">		alreadyTransformed.put(transform, transformedIds);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (transform.getBufferTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		streamGraph.setBufferTimeout(transform.getId(), transform.getBufferTimeout());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (transform.getUid() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		streamGraph.setTransformationUID(transform.getId(), transform.getUid());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (transform.getUserProvidedNodeHash() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		streamGraph.setTransformationUserHash(transform.getId(), transform.getUserProvidedNodeHash());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (transform.getMinResources() != <span class="keyword">null</span> &amp;&amp; transform.getPreferredResources() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		streamGraph.setResources(transform.getId(), transform.getMinResources(), transform.getPreferredResources());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> transformedIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为map，filter等常用操作都是OneInputStreamOperator,我们就来看看<em>transformOneInputTransform</em>方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;IN, OUT&gt; <span class="function">Collection&lt;Integer&gt; <span class="title">transformOneInputTransform</span><span class="params">(OneInputTransformation&lt;IN, OUT&gt; transform)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Collection&lt;Integer&gt; inputIds = transform(transform.getInput());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在递归处理节点过程中，某个节点可能已经被其他子节点先处理过了，需要跳过</span></span><br><span class="line">	<span class="keyword">if</span> (alreadyTransformed.containsKey(transform)) &#123;</span><br><span class="line">		<span class="keyword">return</span> alreadyTransformed.get(transform);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这里是获取slotSharingGroup。这个group用来定义当前我们在处理的这个操作符可以跟什么操作符chain到一个slot里进行操作</span></span><br><span class="line">  <span class="comment">//因为有时候我们可能不满意flink替我们做的chain聚合</span></span><br><span class="line">  <span class="comment">//一个slot就是一个执行task的基本容器</span></span><br><span class="line">	String slotSharingGroup = determineSlotSharingGroup(transform.getSlotSharingGroup(), inputIds);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把该operator加入图</span></span><br><span class="line">	streamGraph.addOperator(transform.getId(),</span><br><span class="line">			slotSharingGroup,</span><br><span class="line">			transform.getOperator(),</span><br><span class="line">			transform.getInputType(),</span><br><span class="line">			transform.getOutputType(),</span><br><span class="line">			transform.getName());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于keyedStream，我们还要记录它的keySelector方法</span></span><br><span class="line">  <span class="comment">//flink并不真正为每个keyedStream保存一个key，而是每次需要用到key的时候都使用keySelector方法进行计算</span></span><br><span class="line">  <span class="comment">//因此，我们自定义的keySelector方法需要保证幂等性</span></span><br><span class="line">  <span class="comment">//到后面介绍keyGroup的时候我们还会再次提到这一点</span></span><br><span class="line">	<span class="keyword">if</span> (transform.getStateKeySelector() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		TypeSerializer&lt;?&gt; keySerializer = transform.getStateKeyType().createSerializer(env.getConfig());</span><br><span class="line">		streamGraph.setOneInputStateKey(transform.getId(), transform.getStateKeySelector(), keySerializer);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	streamGraph.setParallelism(transform.getId(), transform.getParallelism());</span><br><span class="line">	streamGraph.setMaxParallelism(transform.getId(), transform.getMaxParallelism());</span><br><span class="line"></span><br><span class="line">  <span class="comment">//为当前节点和它的依赖节点建立边</span></span><br><span class="line">  <span class="comment">//这里可以看到之前提到的select union partition等逻辑节点被合并入edge的过程</span></span><br><span class="line">	<span class="keyword">for</span> (Integer inputId: inputIds) &#123;</span><br><span class="line">		streamGraph.addEdge(inputId, transform.getId(), <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> Collections.singleton(transform.getId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(Integer upStreamVertexID, Integer downStreamVertexID, <span class="keyword">int</span> typeNumber)</span> </span>&#123;</span><br><span class="line">	addEdgeInternal(upStreamVertexID,</span><br><span class="line">			downStreamVertexID,</span><br><span class="line">			typeNumber,</span><br><span class="line">			<span class="keyword">null</span>,</span><br><span class="line">			<span class="keyword">new</span> ArrayList&lt;String&gt;(),</span><br><span class="line">			<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//addEdge的实现，会合并一些逻辑节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEdgeInternal</span><span class="params">(Integer upStreamVertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">		Integer downStreamVertexID,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> typeNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">		StreamPartitioner&lt;?&gt; partitioner,</span></span></span><br><span class="line"><span class="function"><span class="params">		List&lt;String&gt; outputNames,</span></span></span><br><span class="line"><span class="function"><span class="params">		OutputTag outputTag)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果输入边是侧输出节点，则把side的输入边作为本节点的输入边，并递归调用</span></span><br><span class="line">	<span class="keyword">if</span> (virtualSideOutputNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line">		<span class="keyword">int</span> virtualId = upStreamVertexID;</span><br><span class="line">		upStreamVertexID = virtualSideOutputNodes.get(virtualId).f0;</span><br><span class="line">		<span class="keyword">if</span> (outputTag == <span class="keyword">null</span>) &#123;</span><br><span class="line">			outputTag = virtualSideOutputNodes.get(virtualId).f1;</span><br><span class="line">		&#125;</span><br><span class="line">		addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, <span class="keyword">null</span>, outputTag);</span><br><span class="line">		<span class="comment">//如果输入边是select，则把select的输入边作为本节点的输入边</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (virtualSelectNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line">		<span class="keyword">int</span> virtualId = upStreamVertexID;</span><br><span class="line">		upStreamVertexID = virtualSelectNodes.get(virtualId).f0;</span><br><span class="line">		<span class="keyword">if</span> (outputNames.isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// selections that happen downstream override earlier selections</span></span><br><span class="line">			outputNames = virtualSelectNodes.get(virtualId).f1;</span><br><span class="line">		&#125;</span><br><span class="line">		addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames, outputTag);</span><br><span class="line">		<span class="comment">//如果是partition节点</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (virtualPartitionNodes.containsKey(upStreamVertexID)) &#123;</span><br><span class="line">		<span class="keyword">int</span> virtualId = upStreamVertexID;</span><br><span class="line">		upStreamVertexID = virtualPartitionNodes.get(virtualId).f0;</span><br><span class="line">		<span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">			partitioner = virtualPartitionNodes.get(virtualId).f1;</span><br><span class="line">		&#125;</span><br><span class="line">		addEdgeInternal(upStreamVertexID, downStreamVertexID, typeNumber, partitioner, outputNames, outputTag);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//正常的edge处理逻辑</span></span><br><span class="line">		StreamNode upstreamNode = getStreamNode(upStreamVertexID);</span><br><span class="line">		StreamNode downstreamNode = getStreamNode(downStreamVertexID);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If no partitioner was specified and the parallelism of upstream and downstream</span></span><br><span class="line">		<span class="comment">// operator matches use forward partitioning, use rebalance otherwise.</span></span><br><span class="line">		<span class="keyword">if</span> (partitioner == <span class="keyword">null</span> &amp;&amp; upstreamNode.getParallelism() == downstreamNode.getParallelism()) &#123;</span><br><span class="line">			partitioner = <span class="keyword">new</span> ForwardPartitioner&lt;Object&gt;();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (partitioner == <span class="keyword">null</span>) &#123;</span><br><span class="line">			partitioner = <span class="keyword">new</span> RebalancePartitioner&lt;Object&gt;();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (partitioner <span class="keyword">instanceof</span> ForwardPartitioner) &#123;</span><br><span class="line">			<span class="keyword">if</span> (upstreamNode.getParallelism() != downstreamNode.getParallelism()) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Forward partitioning does not allow "</span> +</span><br><span class="line">						<span class="string">"change of parallelism. Upstream operation: "</span> + upstreamNode + <span class="string">" parallelism: "</span> + upstreamNode.getParallelism() +</span><br><span class="line">						<span class="string">", downstream operation: "</span> + downstreamNode + <span class="string">" parallelism: "</span> + downstreamNode.getParallelism() +</span><br><span class="line">						<span class="string">" You must use another partitioning strategy, such as broadcast, rebalance, shuffle or global."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		StreamEdge edge = <span class="keyword">new</span> StreamEdge(upstreamNode, downstreamNode, typeNumber, outputNames, partitioner, outputTag);</span><br><span class="line"></span><br><span class="line">		getStreamNode(edge.getSourceId()).addOutEdge(edge);</span><br><span class="line">		getStreamNode(edge.getTargetId()).addInEdge(edge);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-WordCount函数的StreamGraph"><a href="#3-1-WordCount函数的StreamGraph" class="headerlink" title="3.1 WordCount函数的StreamGraph"></a>3.1 WordCount函数的StreamGraph</h3><p>flink提供了一个StreamGraph可视化显示工具，<a href="https://wints.github.io/flink-web/visualizer/" target="_blank" rel="noopener">在这里</a><br>我们可以把我们的程序的执行计划打印出来 <em>System.out.println(env.getExecutionPlan());</em> 复制到这个网站上，点击生成，如图所示：</p>
<p><img src="/img/image_1cafgsliu1n2n1uj21p971b0h6m71t.png" alt="image_1cafgsliu1n2n1uj21p971b0h6m71t.png-25.7kB"><br>可以看到，我们源程序被转化成了4个operator。另外，在operator之间的连线上也显示出了flink添加的一些逻辑流程。由于我设定了每个操作符的并行度都是1，所以在每个操作符之间都是直接FORWARD，不存在shuffle的过程。</p>
<h2 id="4-JobGraph的生成"><a href="#4-JobGraph的生成" class="headerlink" title="4.JobGraph的生成"></a>4.JobGraph的生成</h2><p>flink会根据上一步生成的StreamGraph生成JobGraph，然后将JobGraph发送到server端进行ExecutionGraph的解析。</p>
<h3 id="4-1-JobGraph生成源码"><a href="#4-1-JobGraph生成源码" class="headerlink" title="4.1 JobGraph生成源码"></a>4.1 JobGraph生成源码</h3><p>与StreamGraph类似，JobGraph的入口方法是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StreamingJobGraphGenerator.createJobGraph()</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JobGraph <span class="title">createJobGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置启动模式为所有节点均在一开始就启动</span></span><br><span class="line">	jobGraph.setScheduleMode(ScheduleMode.EAGER);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为每个节点生成hash id</span></span><br><span class="line">	Map&lt;Integer, <span class="keyword">byte</span>[]&gt; hashes = defaultStreamGraphHasher.traverseStreamGraphAndGenerateHashes(streamGraph);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了保持兼容性创建的hash</span></span><br><span class="line">	List&lt;Map&lt;Integer, <span class="keyword">byte</span>[]&gt;&gt; legacyHashes = <span class="keyword">new</span> ArrayList&lt;&gt;(legacyStreamGraphHashers.size());</span><br><span class="line">	<span class="keyword">for</span> (StreamGraphHasher hasher : legacyStreamGraphHashers) &#123;</span><br><span class="line">		legacyHashes.add(hasher.traverseStreamGraphAndGenerateHashes(streamGraph));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;Integer, List&lt;Tuple2&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; chainedOperatorHashes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      <span class="comment">//生成jobvertex，串成chain等</span></span><br><span class="line">      <span class="comment">//这里的逻辑大致可以理解为，挨个遍历节点，如果该节点是一个chain的头节点，就生成一个JobVertex，如果不是头节点，就要把自身配置并入头节点，然后把头节点和自己的出边相连；对于不能chain的节点，当作只有头节点处理即可</span></span><br><span class="line">	setChaining(hashes, legacyHashes, chainedOperatorHashes);</span><br><span class="line">      <span class="comment">//设置输入边edge</span></span><br><span class="line">	setPhysicalEdges();</span><br><span class="line">      <span class="comment">//设置slot共享group</span></span><br><span class="line">	setSlotSharing();</span><br><span class="line">      <span class="comment">//配置检查点</span></span><br><span class="line">	configureCheckpointing();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果有之前的缓存文件的配置的话，重新读入</span></span><br><span class="line">	<span class="keyword">for</span> (Tuple2&lt;String, DistributedCache.DistributedCacheEntry&gt; e : streamGraph.getEnvironment().getCachedFiles()) &#123;</span><br><span class="line">		DistributedCache.writeFileInfoToConfig(e.f0, e.f1, jobGraph.getJobConfiguration());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 传递执行环境配置</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		jobGraph.setExecutionConfig(streamGraph.getExecutionConfig());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalConfigurationException(<span class="string">"Could not serialize the ExecutionConfig."</span> +</span><br><span class="line">				<span class="string">"This indicates that non-serializable types (like custom serializers) were registered"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> jobGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-operator-chain的逻辑"><a href="#4-2-operator-chain的逻辑" class="headerlink" title="4.2 operator chain的逻辑"></a>4.2 operator chain的逻辑</h3><p> 为了更高效地分布式执行，Flink会尽可能地将operator的subtask链接（chain）在一起形成task。每个task在一个线程中执行。将operators链接成task是非常有效的优化：它能减少线程之间的切换，减少消息的序列化/反序列化，减少数据在缓冲区的交换，减少了延迟的同时提高整体的吞吐量。</p>
<p><img src="/img/image_1cafj7s6bittk5tt0bequlig2a.png" alt="image_1cafj7s6bittk5tt0bequlig2a.png-158.7kB"><br>上图中将KeyAggregation和Sink两个operator进行了合并，因为这两个合并后并不会改变整体的拓扑结构。但是，并不是任意两个 operator 就能 chain 一起的,其条件还是很苛刻的：</p>
<ul>
<li>上下游的并行度一致</li>
<li>下游节点的入度为1 （也就是说下游节点没有来自其他节点的输入）</li>
<li>上下游节点都在同一个 slot group 中（下面会解释 slot group）</li>
<li>下游节点的 chain 策略为 ALWAYS（可以与上下游链接，map、flatmap、filter等默认是ALWAYS）</li>
<li>上游节点的 chain 策略为 ALWAYS 或 HEAD（只能与下游链接，不能与上游链接，Source默认是HEAD）</li>
<li>两个节点间数据分区方式是 forward（参考理解数据流的分区）</li>
<li>用户没有禁用 chain</li>
</ul>
<p>flink的chain逻辑是一种很常见的设计，比如spring的interceptor也是类似的实现方式。通过把操作符串成一个大操作符，flink避免了把数据序列化后通过网络发送给其他节点的开销，能够大大增强效率。</p>
<h3 id="4-3-JobGraph的提交"><a href="#4-3-JobGraph的提交" class="headerlink" title="4.3 JobGraph的提交"></a>4.3 JobGraph的提交</h3><p>前面已经提到，JobGraph的提交依赖于JobClient和JobManager之间的异步通信，如图所示：</p>
<p><img src="/img/image_1cafn516r1p68kt31g7r196rcsv2n.png" alt="image_1cafn516r1p68kt31g7r196rcsv2n.png-40.1kB"><br>在submitJobAndWait方法中，其首先会创建一个JobClientActor的ActorRef,然后向其发起一个SubmitJobAndWait消息，该消息将JobGraph的实例提交给JobClientActor。发起模式是ask，它表示需要一个应答消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Object&gt; future = Patterns.ask(jobClientActor, <span class="keyword">new</span> JobClientMessages.SubmitJobAndWait(jobGraph), <span class="keyword">new</span> Timeout(AkkaUtils.INF_TIMEOUT()));</span><br><span class="line">answer = Await.result(future, AkkaUtils.INF_TIMEOUT());</span><br></pre></td></tr></table></figure>
<p>该SubmitJobAndWait消息被JobClientActor接收后，最终通过调用tryToSubmitJob方法触发真正的提交动作。当JobManager的actor接收到来自client端的请求后，会执行一个submitJob方法，主要做以下事情：</p>
<ul>
<li>向BlobLibraryCacheManager注册该Job；</li>
<li>构建ExecutionGraph对象；</li>
<li>对JobGraph中的每个顶点进行初始化；</li>
<li>将DAG拓扑中从source开始排序，排序后的顶点集合附加到Exec&gt; - utionGraph对象；</li>
<li>获取检查点相关的配置，并将其设置到ExecutionGraph对象；</li>
<li>向ExecutionGraph注册相关的listener；</li>
<li>执行恢复操作或者将JobGraph信息写入SubmittedJobGraphStore以在后续用于恢复目的；</li>
<li>响应给客户端JobSubmitSuccess消息；</li>
<li>对ExecutionGraph对象进行调度执行；</li>
</ul>
<p>最后，JobManger会返回消息给JobClient，通知该任务是否提交成功。</p>
<h2 id="5-ExecutionGraph的生成"><a href="#5-ExecutionGraph的生成" class="headerlink" title="5.ExecutionGraph的生成"></a>5.ExecutionGraph的生成</h2><p>与StreamGraph和JobGraph不同，ExecutionGraph并不是在我们的客户端程序生成，而是在服务端（JobManager处）生成的，顺便flink只维护一个JobManager。其入口代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutionGraphBuilder.buildGraph（...）</span><br></pre></td></tr></table></figure>
<p>该方法长200多行，其中一大半是checkpoiont的相关逻辑，我们暂且略过，直接看核心方法 <em>executionGraph.attachJobGraph</em> 因为ExecutionGraph事实上只是改动了JobGraph的每个节点，而没有对整个拓扑结构进行变动，所以代码里只是挨个遍历jobVertex并进行处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (JobVertex jobVertex : topologiallySorted) &#123;</span><br><span class="line">	<span class="keyword">if</span> (jobVertex.isInputVertex() &amp;&amp; !jobVertex.isStoppable()) &#123;</span><br><span class="line">		<span class="keyword">this</span>.isStoppable = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在这里生成ExecutionGraph的每个节点</span></span><br><span class="line">	<span class="comment">//首先是进行了一堆赋值，将任务信息交给要生成的图节点，以及设定并行度等等</span></span><br><span class="line">	<span class="comment">//然后是创建本节点的IntermediateResult，根据本节点的下游节点的个数确定创建几份</span></span><br><span class="line">	<span class="comment">//最后是根据设定好的并行度创建用于执行task的ExecutionVertex</span></span><br><span class="line">	<span class="comment">//如果job有设定inputsplit的话，这里还要指定inputsplits</span></span><br><span class="line">	ExecutionJobVertex ejv = <span class="keyword">new</span> ExecutionJobVertex(</span><br><span class="line">		<span class="keyword">this</span>,</span><br><span class="line">		jobVertex,</span><br><span class="line">		<span class="number">1</span>,</span><br><span class="line">		rpcCallTimeout,</span><br><span class="line">		globalModVersion,</span><br><span class="line">		createTimestamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里要处理所有的JobEdge</span></span><br><span class="line">    <span class="comment">//对每个edge，获取对应的intermediateResult，并记录到本节点的输入上</span></span><br><span class="line">    <span class="comment">//最后，把每个ExecutorVertex和对应的IntermediateResult关联起来</span></span><br><span class="line">	ejv.connectToPredecessors(<span class="keyword">this</span>.intermediateResults);</span><br><span class="line"></span><br><span class="line">	ExecutionJobVertex previousTask = <span class="keyword">this</span>.tasks.putIfAbsent(jobVertex.getID(), ejv);</span><br><span class="line">	<span class="keyword">if</span> (previousTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> JobException(String.format(<span class="string">"Encountered two job vertices with ID %s : previous=[%s] / new=[%s]"</span>,</span><br><span class="line">				jobVertex.getID(), ejv, previousTask));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (IntermediateResult res : ejv.getProducedDataSets()) &#123;</span><br><span class="line">		IntermediateResult previousDataSet = <span class="keyword">this</span>.intermediateResults.putIfAbsent(res.getId(), res);</span><br><span class="line">		<span class="keyword">if</span> (previousDataSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> JobException(String.format(<span class="string">"Encountered two intermediate data set with ID %s : previous=[%s] / new=[%s]"</span>,</span><br><span class="line">					res.getId(), res, previousDataSet));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span>.verticesInCreationOrder.add(ejv);</span><br><span class="line">	<span class="keyword">this</span>.numVerticesTotal += ejv.getParallelism();</span><br><span class="line">	newExecJobVertices.add(ejv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，ExecutorGraph就创建完成了。</p>
]]></content>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink执行流程一</title>
    <url>/2024/09/03/Flink%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E4%B8%80/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flink是大数据处理领域最近很火的一个开源的分布式、高性能的流式处理框架，其对数据的处理可以达到毫秒级别。本文以一个来自官网的WordCount例子为引，全面阐述flink的核心架构及执行流程，希望读者可以借此更加深入的理解Flink逻辑。本文跳过了一些基本概念，如果对相关概念感到迷惑，请参考<a href="https://nightlies.apache.org/flink/flink-docs-release-1.20/zh/" target="_blank" rel="noopener">官网文档</a>。</p>
<h2 id="1-从WordCount开始"><a href="#1-从WordCount开始" class="headerlink" title="1.从WordCount开始"></a>1.从WordCount开始</h2><p>首先，我们把WordCount的例子再放一遍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketTextStreamWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>)&#123;</span><br><span class="line">			System.err.println(<span class="string">"USAGE:\nSocketTextStreamWordCount &lt;hostname&gt; &lt;port&gt;"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String hostName = args[<span class="number">0</span>];</span><br><span class="line">		Integer port = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// set up the execution environment</span></span><br><span class="line">		<span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment</span><br><span class="line">				.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// get input data</span></span><br><span class="line">		DataStream&lt;String&gt; text = env.socketTextStream(hostName, port);</span><br><span class="line"></span><br><span class="line">		text.flatMap(<span class="keyword">new</span> LineSplitter()).setParallelism(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// group by the tuple field "0" and sum up tuple field "1"</span></span><br><span class="line">				.keyBy(<span class="number">0</span>)</span><br><span class="line">				.sum(<span class="number">1</span>).setParallelism(<span class="number">1</span>)</span><br><span class="line">				.print();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// execute program</span></span><br><span class="line">		env.execute(<span class="string">"Java WordCount from SocketTextStream Example"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Implements the string tokenizer that splits sentences into words as a user-defined</span></span><br><span class="line"><span class="comment">	 * FlatMapFunction. The function takes a line (String) and splits it into</span></span><br><span class="line"><span class="comment">	 * multiple pairs in the form of "(word,1)" (Tuple2&amp;lt;String, Integer&amp;gt;).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LineSplitter</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">			<span class="comment">// normalize and split the line</span></span><br><span class="line">			String[] tokens = value.toLowerCase().split(<span class="string">"\\W+"</span>);</span><br><span class="line">			<span class="comment">// emit the pairs</span></span><br><span class="line">			<span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">				<span class="keyword">if</span> (token.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					out.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(token, <span class="number">1</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先从命令行中获取socket对端的ip和端口，然后启动一个执行环境，从socket中读取数据，split成单个单词的流，并按单词进行总和的计数，最后打印出来。这个例子相信接触过大数据计算或者函数式编程的人都能看懂，就不过多解释了。</p>
<h2 id="2-flink执行环境"><a href="#2-flink执行环境" class="headerlink" title="2.flink执行环境"></a>2.flink执行环境</h2><p>程序的启动，从这句开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment()</span><br></pre></td></tr></table></figure>
<p>这行代码会返回一个可用的执行环境。执行环境是整个flink程序执行的上下文，记录了相关配置（如并行度等），并提供了一系列方法，如读取输入流的方法，以及真正开始运行整个代码的execute方法等。对于分布式流处理程序来说，我们在代码中定义的flatMap,keyBy等等操作，事实上可以理解为一种声明，告诉整个程序我们采用了什么样的算子，而真正开启计算的代码不在此处。由于我们是在本地运行flink程序，因此这行代码会返回一个LocalStreamEnvironment，最后我们要调用它的execute方法来开启真正的任务。我们先接着往下看。</p>
<h2 id="3-算子（Operator）的注册"><a href="#3-算子（Operator）的注册" class="headerlink" title="3.算子（Operator）的注册"></a>3.算子（Operator）的注册</h2><p>我们以flatMap为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">flatMap</span><span class="params">(FlatMapFunction&lt;T, R&gt; flatMapper)</span> </span>&#123;</span><br><span class="line">	TypeInformation&lt;R&gt; outType = TypeExtractor.getFlatMapReturnTypes(clean(flatMapper),</span><br><span class="line">				getType(), Utils.getCallLocationName(), <span class="keyword">true</span>);</span><br><span class="line">	<span class="keyword">return</span> transform(<span class="string">"Flat Map"</span>, outType, <span class="keyword">new</span> StreamFlatMap&lt;&gt;(clean(flatMapper)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面完成了两件事，一是用反射拿到了flatMap算子的输出类型，二是生成了一个Operator。flink流式计算的核心概念，就是将数据从输入流一个个传递给Operator进行链式处理，最后交给输出流的过程。对数据的每一次处理在逻辑上成为一个operator，并且为了本地化处理的效率起见，operator之间也可以串成一个chain一起处理（可以参考责任链模式帮助理解）。下面这张图表明了flink是如何看待用户的处理流程的：抽象化为一系列operator，以source开始，以sink结尾，中间的operator做的操作叫做transform，并且可以把几个操作串在一起执行。</p>
<p><img src="/img/image_1cae39t06eoo3ml1be8o0412c69.png" alt="image_1cae39t06eoo3ml1be8o0412c69.png-43.5kB"><br>我们也可以更改flink的设置，要求它不要对某个操作进行chain处理，或者从某个操作开启一个新chain等。<br>上面代码中的最后一行transform方法的作用是返回一个SingleOutputStreamOperator，它继承了Datastream类并且定义了一些辅助方法，方便对流的操作。在返回之前，transform方法还把它注册到了执行环境中（后面生成执行图的时候还会用到它）。其他的操作，包括keyBy，sum和print，都只是不同的算子，在这里出现都是一样的效果，即生成一个operator并注册给执行环境用于生成DAG。</p>
<h2 id="4-程序的执行"><a href="#4-程序的执行" class="headerlink" title="4. 程序的执行"></a>4. 程序的执行</h2><p>程序执行即这行代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.execute(<span class="string">"Java WordCount from SocketTextStream Example"</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码主要做了以下事情：</p>
<ul>
<li>生成StreamGraph。代表程序的拓扑结构，是从用户代码直接生成的图。</li>
<li>生成JobGraph。这个图是要交给flink去生成task的图。</li>
<li>生成一系列配置</li>
<li>将JobGraph和配置交给flink集群去运行。如果不是本地运行的话，还会把jar文件通过网络发给其他节点。</li>
<li>以本地模式运行的话，可以看到启动过程，如启动性能度量、web模块、JobManager、ResourceManager、taskManager等等</li>
<li>启动任务。值得一提的是在启动任务之前，先启动了一个用户类加载器，这个类加载器可以用来做一些在运行时动态加载类的工作。</li>
</ul>
<h3 id="4-1远程模式（RemoteEnvironment）的execute方法"><a href="#4-1远程模式（RemoteEnvironment）的execute方法" class="headerlink" title="4.1远程模式（RemoteEnvironment）的execute方法"></a>4.1远程模式（RemoteEnvironment）的execute方法</h3><p>远程模式的程序执行更加有趣一点。第一步仍然是获取StreamGraph，然后调用executeRemotely方法进行远程执行。<br>该方法首先创建一个用户代码加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader usercodeClassLoader = JobWithJars.buildUserCodeClassLoader(jarFiles, globalClasspaths,   getClass().getClassLoader());</span><br></pre></td></tr></table></figure>
<p>然后创建一系列配置，交给Client对象。Client这个词有意思，看见它就知道这里绝对是跟远程集群打交道的客户端。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClusterClient client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	client = <span class="keyword">new</span> StandaloneClusterClient(configuration);</span><br><span class="line">	client.setPrintStatusDuringExecution(getConfig().isSysoutLoggingEnabled());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> client.run(streamGraph, jarFiles, globalClasspaths, usercodeClassLoader).getJobExecutionResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>client的run方法首先生成一个JobGraph，然后将其传递给JobClient。关于Client、JobClient、JobManager到底谁管谁，可以看这张图：<br><img src="/img/image_1cae7g15p6k94no1ves121c5pd9.png" alt="image_1cae7g15p6k94no1ves121c5pd9.png-19.7kB"><br>确切的说，JobClient负责以异步的方式和JobManager通信（Actor是scala的异步模块），具体的通信任务由JobClientActor完成。相对应的，JobManager的通信任务也由一个Actor完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JobListeningContext jobListeningContext = submitJob(</span><br><span class="line">		actorSystem,config,highAvailabilityServices,jobGraph,timeout,sysoutLogUpdates,	classLoader);</span><br><span class="line"><span class="keyword">return</span> awaitJobResult(jobListeningContext);</span><br></pre></td></tr></table></figure>
<p>可以看到，该方法阻塞在awaitJobResult方法上，并最终返回了一个JobListeningContext，透过这个Context可以得到程序运行的状态和结果。</p>
<h2 id="5-程序启动过程"><a href="#5-程序启动过程" class="headerlink" title="5.程序启动过程"></a>5.程序启动过程</h2><p>上面提到，整个程序真正意义上开始执行，是这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">env.execute(<span class="string">"Java WordCount from SocketTextStream Example"</span>);</span><br></pre></td></tr></table></figure>
<p>远程模式和本地模式有一点不同，我们先按本地模式来调试。<br>我们跟进源码，（在本地调试模式下）会启动一个miniCluster，然后开始执行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalStreamEnvironment.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">execute</span><span class="params">(String jobName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//生成各种图结构</span></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//启动集群，包括启动JobMaster，进行leader选举等等</span></span><br><span class="line">		miniCluster.start();</span><br><span class="line">		configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().getPort());</span><br><span class="line"></span><br><span class="line">          <span class="comment">//提交任务到JobMaster</span></span><br><span class="line">		<span class="keyword">return</span> miniCluster.executeJobBlocking(jobGraph);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		transformations.clear();</span><br><span class="line">		miniCluster.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法里有一部分逻辑是与生成图结构相关的，我们放在第二章里讲；现在我们先接着往里跟：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MiniCluster.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> JobExecutionResult <span class="title">executeJobBlocking</span><span class="params">(JobGraph job)</span> <span class="keyword">throws</span> JobExecutionException, InterruptedException </span>&#123;</span><br><span class="line">	checkNotNull(job, <span class="string">"job is null"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//在这里，最终把job提交给了jobMaster</span></span><br><span class="line">	<span class="keyword">final</span> CompletableFuture&lt;JobSubmissionResult&gt; submissionFuture = submitJob(job);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> CompletableFuture&lt;JobResult&gt; jobResultFuture = submissionFuture.thenCompose(</span><br><span class="line">		(JobSubmissionResult ignored) -&gt; requestJobResult(job.getJobID()));</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正如我在注释里写的，这一段代码核心逻辑就是调用那个<em>submitJob</em>方法。那么我们再接着看这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;JobSubmissionResult&gt; <span class="title">submitJob</span><span class="params">(JobGraph jobGraph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> DispatcherGateway dispatcherGateway;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		dispatcherGateway = getDispatcherGateway();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (LeaderRetrievalException | InterruptedException e) &#123;</span><br><span class="line">		ExceptionUtils.checkInterrupted(e);</span><br><span class="line">		<span class="keyword">return</span> FutureUtils.completedExceptionally(e);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we have to allow queued scheduling in Flip-6 mode because we need to request slots</span></span><br><span class="line">	<span class="comment">// from the ResourceManager</span></span><br><span class="line">	jobGraph.setAllowQueuedScheduling(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> CompletableFuture&lt;Void&gt; jarUploadFuture = uploadAndSetJarFiles(dispatcherGateway, jobGraph);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; acknowledgeCompletableFuture = jarUploadFuture.thenCompose(</span><br><span class="line"></span><br><span class="line">	<span class="comment">//在这里执行了真正的submit操作</span></span><br><span class="line">		(Void ack) -&gt; dispatcherGateway.submitJob(jobGraph, rpcTimeout));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> acknowledgeCompletableFuture.thenApply(</span><br><span class="line">		(Acknowledge ignored) -&gt; <span class="keyword">new</span> JobSubmissionResult(jobGraph.getJobID()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<em>Dispatcher</em>是一个接收job，然后指派JobMaster去启动任务的类,我们可以看看它的类结构，有两个实现。在本地环境下启动的是<em>MiniDispatcher</em>，在集群上提交任务时，集群上启动的是<em>StandaloneDispatcher</em>。<br><img src="/img/image_1cenfj3p9fp110p0a8unn1mrh9.png" alt="image_1cenfj3p9fp110p0a8unn1mrh9.png-27.4kB"></p>
<p>那么这个Dispatcher又做了什么呢？它启动了一个<em>JobManagerRunner</em>（这里我要吐槽Flink的命名，这个东西应该叫做JobMasterRunner才对，flink里的JobMaster和JobManager不是一个东西），委托JobManagerRunner去启动该Job的<em>JobMaster</em>。我们看一下对应的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jobManagerRunner.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verifyJobSchedulingStatusAndStartJobManager</span><span class="params">(UUID leaderSessionId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; startFuture = jobMaster.start(<span class="keyword">new</span> JobMasterId(leaderSessionId), rpcTimeout);</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，JobMaster经过了一堆方法嵌套之后，执行到了这里：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleExecutionGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	checkState(jobStatusListener == <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">// register self as job status change listener</span></span><br><span class="line">	jobStatusListener = <span class="keyword">new</span> JobManagerJobStatusListener();</span><br><span class="line">	executionGraph.registerJobStatusListener(jobStatusListener);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//这里调用了ExecutionGraph的启动方法</span></span><br><span class="line">		executionGraph.scheduleForExecution();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		executionGraph.failGlobal(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，flink的框架里有三层图结构，其中ExecutionGraph就是真正被执行的那一层，所以到这里为止，一个任务从提交到真正执行的流程就走完了，我们再回顾一下（顺便提一下远程提交时的流程区别）：</p>
<ul>
<li>客户端代码的execute方法执行；</li>
<li>本地环境下，MiniCluster完成了大部分任务，直接把任务委派给了MiniDispatcher；</li>
<li>远程环境下，启动了一个<em>RestClusterClient</em>，这个类会以HTTP Rest的方式把用户代码提交到集群上；</li>
<li>远程环境下，请求发到集群上之后，必然有个handler去处理，在这里是<em>JobSubmitHandler</em>。这个类接手了请求后，委派<em>StandaloneDispatcher</em>启动job，到这里之后，本地提交和远程提交的逻辑往后又统一了；</li>
<li>Dispatcher接手job之后，会实例化一个<em>JobManagerRunner</em>，然后用这个runner启动job；</li>
<li>JobManagerRunner接下来把job交给了<em>JobMaster</em>去处理；</li>
<li>JobMaster使用<em>ExecutionGraph</em>的方法启动了整个执行图；整个任务就启动起来了。</li>
</ul>
<p>至此，第一部分就讲完了。</p>
]]></content>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>swing召回</title>
    <url>/2024/09/02/swing%E5%8F%AC%E5%9B%9E/</url>
    <content><![CDATA[<p>swing是阿里原创的i2i召回算法（论文具体参考附录[1]），在阿里内部的多个业务场景被验证是一种非常有效的召回方法。swing在工业界已得到比较广泛的使用，抖音，小红书，B站等推荐系统均使用了swing i2i</p>
<h2 id="传统icf算法"><a href="#传统icf算法" class="headerlink" title="传统icf算法"></a>传统icf算法</h2><p>在介绍swing之前，我们先简单回顾下传统的item-cf是如何计算物品之间的相似度。<br>最经典的item-cf算法基于余弦来计算相似度，下面是传统item-cf对于item $i$和$j$的相似度定义。</p>
<script type="math/tex; mode=display">s(i,j) = \frac{|U_i \bigcap U_j|}{\sqrt{|U_i|}\sqrt{|U_j|}}</script><p>$U_i$表示喜欢物品$i$的用户集合，$U_j$表示喜欢物品$j$的用户集合。分子是$U_i$和$U_j$的交集大小，也就是喜欢$i$又喜欢$j$的用户数量。分母是$U_i$和$U_j$模的平方根，可以避免热门item与多数item都有很高的相似度。</p>
<blockquote>
<p>传统item-cf背后的直觉是：如果大量用户同时喜欢两个物品，那么这两个物品之间应该有比较高的关联（相似）</p>
</blockquote>
<h2 id="swing算法"><a href="#swing算法" class="headerlink" title="swing算法"></a>swing算法</h2><p>与传统item-cf类似，swing也是用来衡量物品之间的相似度。swing相似度的定义如下：</p>
<script type="math/tex; mode=display">s(i,j)=\sum_{u \in U_i \bigcap U_j}\sum_{v \in U_i \bigcap U_j}\frac{1}{\alpha+|I_u \bigcap I_v|}</script><ul>
<li>$U_i$表示喜欢物品$i$的用户集合，$U_j$表示喜欢物品$j$的用户集合，$I_u$表示用户$u$喜欢的item集合，$I_v$表示用户$v$喜欢的item集合。</li>
<li>公式中有两个$\sum$求和符号，表示的是在同时喜欢物品$i$和$j$的用户集合内两两取$pair$，因此分子的1可以理解为表示一个用户$pair(u,v)$。</li>
<li>分母中的$I_u$和$I_v$交集的用来表示用户$u$和$v$之间的相似度，等于两个用户共同点击的item数量。这个值越高，说明两个用户的重合度越高，就要降低它的贡献度。</li>
<li>分母中的$\alpha$是一个平滑项，可以避免分母为零，可以取一个较小的正数，例如1。</li>
</ul>
<blockquote>
<p>swing的直觉来源是：如果大量用户同时喜欢两个物品，且这些用户之间的相关性低，那么这两个物品一定是强关联（相似）</p>
</blockquote>
<h2 id="传统icf与swing的异同点"><a href="#传统icf与swing的异同点" class="headerlink" title="传统icf与swing的异同点"></a>传统icf与swing的异同点</h2><p>比较传统icf和swing的相似度定义公式，可以看到，两者的共同点是都通过同时喜欢物品$i$和$j$的用户规模来表达相似度，共同喜欢两个物品的用户量越大，物品间的相似度越高。区别是，swing还考虑了用户之间的重合度，不仅希望用户交集的规模大，且要多样性好。<br>用一句话来分别概括传统icf和swing的特点：<br>传统icf：如果同时喜欢两个物品的用户越多，那么这两个物品间的相似度越高。<br>swing：如果同时喜欢两个物品的用户越多，且这些用户之间的重合度越低，那么这两个物品间的相似度越高。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><em><a href="/pdf/swing.pdf">[1]</a></em> <em style="font-size:14px">Large Scale Product Graph Construction for Recommendation in E-commerce</em></p>
]]></content>
      <tags>
        <tag>Recommend</tag>
      </tags>
  </entry>
  <entry>
    <title>AB实验基础</title>
    <url>/2024/08/30/AB%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>实验构建、指标计算、效果衡量都需要一些基础的统计学知识进行支撑</p>
<h2 id="总体和样本"><a href="#总体和样本" class="headerlink" title="总体和样本"></a>总体和样本</h2><p>假设我们对全国人民的身高感兴趣，身高是我们关心的指标，全国人民是总体。总体的身高有一个分布，例如正态分布，刻画一个分布的参数很多，例如均值、方差、中位数等等。</p>
<p>在身高问题上，去测量每个人的身高然后得出总体的身高分布太昂贵也没有必要。在统计里面，我们通常会从所有人里面随机抽取一定数量的人，测量他们的身高，然后用他们的身高分布去推断总体的身高分布。这些随机抽取的人就是样本，样本中人的数量就是样本量，用样本的身高分布去推断总计的身高分布就是统计推断的核心内容，例如我们可以用样本均值去估计总体均值。</p>
<h2 id="估计和假设检验"><a href="#估计和假设检验" class="headerlink" title="估计和假设检验"></a>估计和假设检验</h2><p>估计和假设检验是统计推断的两个主要的问题，统计推断都是针对总体参数的推断。为了简单起见，下面的描述都是针对总体均值这个参数。</p>
<p>估计包括点估计和区间估计。在身高问题中，假设样本的身高的平均值是$1.7m$，我们可以用$1.7m$去估计总体的身高的平均值，这就是点估计。样本的身高的平均值是从一个随机样本中计算出来的，因此它具有随机性，点估计不能体现出样本均值的随机性，因此我们通常也会对总体均值提供区间估计。区间估计通常伴随着统计的置信水平，例如95%。在身高问题中，我们可能计算出来的总体均值的95%的置信区间是$[1.68m， 1.72m]$。95%的置信区间可以这样理解，假设我们从总体中做了100次随机抽样，每次随机抽样我们都计算一个总体均值的95%的置信区间，这100个95%的置信区间有大概95个会包含总体均值。如果我们计算的是99%的置信区间，那么这100个99%的置信区间有大概99个会包含总体均值。直觉上，置信水平越高，置信区间越宽；给定置信水平，置信区间越宽，样本均值的随机性越大。</p>
<p>A/B实验的核心统计学理论是（双样本）假设检验。假设检验，即首先做出假设，然后运用数据来检验假设是否成立。需要注意的是 ，我们在检验假设时，逻辑上采用了反证法。通过A/B实验，我们实际上要验证的是一对相互对立的假设：原假设和备择假设。</p>
<ul>
<li>原假设（<em>Null Hypothesis</em> $H_0$）：是实验者想要收集证据予以反对的假设。A/B实验中的原假设就是指“新策略没有效果”。</li>
<li>备择假设（<em>Alternative Hypothesis</em> $H_1$）：是实验者想要收集证据予以支持的假设，与原假设互斥。A/B实验中的备择假设就是指“新策略有效果”。</li>
</ul>
<p>利用反证法来检验假设，意味着我们要利用现有的数据，通过一系列方法证明原假设是错误的（伪），并借此证明备择假设是正确的（真）。这一套方法在统计学上被称作原假设显著性检验 <strong>Null Hypothesis Significance Testing (NHST)</strong>。</p>
<p>在身高问题中，一对可能的假设可以是</p>
<ul>
<li>$H_0$: 总体身高均值是$1.7m$ VS $H_1$: 总体身高均值不是$1.7m$</li>
</ul>
<p>在频率统计里面，我们通常假设$H_0$是对的，构建一个统计量，再把统计量转化成$P$值，$P$值越小，$H_0$不成立的可能性就越大，我们就越应该拒绝$H_0$。在假设检验里面，我们会范两类错误：第一类错误是$H_0$是对的我们拒绝$H_0$；第二类错误是$H_0$是错的我们接受$H_0$。两类错误相互冲突，即它们通常是往相反的方向移动，我们通常是控制第一类错误的概率，优化第二类错误的概率。为了控制第一类错误概率，统计显著性水平会在假设检验之前事先确定，例如5%，如果P值小于设定的显著性水平，我们就拒绝$H_0$，这样第一类错误的概率就是设定的统计显著性水平。</p>
<p>假设检验和置信区间有非常紧密的联系。在上面的假设检验问题里面，我们可以通过选择5%的显著性水平来把第一类错误的概率控制在5%，另外一种做法是计算总体身高均值的95%的置信区间，如果这个置信区间包含1.7m，我们就接受$H_0$，反之则拒绝$H_0$。这种做法的第一类错误的概率也是5%，原因很简单，如果$H_0$成立，即总体身高均值为$1.7m$，那么我们计算的置信区间会有95%的概率包含$1.7m$，所以95%的置信区间会有5%的概率不包含$1.7m$，而我们的决策方案是当置信区间不包含$1.7m$的时候拒绝$H_0$，因此这种依靠置信区间来做决策的第一类错误的概率也是5%。这也是为什么在A/B Test里面当$H_0$是对照版本和实验版本的均值相等的时候，我们可以看两个版本的绝对差的置信区间是否包含0来做出是否拒绝$H_0$的原因。</p>
<h2 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h2><p><strong>显著性水平的理论依据便是中心极限定理。我们可以量化抽样误差的根基在于中心极限定理的存在。</strong></p>
<p>由于存在抽样误差，我们每次实验所得到的指标结果，都可能与我们期望得到的真正结果有误差。假设我们从总体中抽取样本，计算其指标的均值，每一次计算，样本均值都会受抽样误差影响。假如我们做无数多次实验，那么理论上，这无数多个样本均值中，总应该有一个是“真的”，不受抽样误差影响的，这个值在统计学里被称为“真值”。<br>中心极限定理定告诉我们，如果我们从总体流量里不断抽取样本，做无数次小流量实验，这无数次抽样所观测到的均值，近似呈现正态分布（就是下图这样的分布）。这个分布以真值为中心，均值越接近真值，出现的概率就越大；反之均值越偏离真值，出现的概率就越小。<br><img src="/img/中心极限定理.png" alt></p>
<p>为什么样本均值越接近真值，出现的概率越大？</p>
<ul>
<li>举个例子，如果从全中国人这个总体中，抽取很多很多次样本，计算很多很多次平均收入。<br>可以预见，我们会因为样本不同而得到很多个不同的平均收入值。这些数值确实有可能因为偶然抽到顶级富豪而偏高，或因为抽到极贫困的人口而偏低。但是，上述两种情况毕竟是少数（均值越偏离真值，出现的概率小）。随着抽样次数增多，我们会发现，平均收入落在大多数普通人收入范围内的次数，会显著增多（均值接近真值，出现的概率大）。并且，有了中心极限定理的帮助，我们可以知道每个均值出现的概率是多少。</li>
</ul>
<h2 id="P值和置信区间的计算"><a href="#P值和置信区间的计算" class="headerlink" title="P值和置信区间的计算"></a>P值和置信区间的计算</h2><p>下面我们以CTR（点击率）指标来说明P值和置信区间如何计算。</p>
<p>假设计算CTR的单个样本点是用户，即先计算用户级别的CTR，然后再对所有的用户取平均。经常提到的UV_CTR每个样本点就是一个用户，在UV_CTR中， 每个曝光的用户取值是0(没有点击)或者1(点击)；经常提到的PV_CTR每个样本点就不是一个用户，而是一次曝光，不同的曝光可能来自于同一个用户。为了把用户曝光的次数考虑进来，我们提出来计算UPV_CTR，即先对每个用户计算出一个CTR等于该用户的点击数除以曝光数，再取平均值。</p>
<p>下面的讨论围绕UPV_CTR进行，但是适用于任何单个样本点是用户的指标。</p>
<p>第二节里面的统计推断都是单样本的统计推断，在A/B Test里面，我们通常感兴趣的是实验版本和对照版本之间的比较，所以是两个样本的统计推断，好在大多数的情况下，实验版本和对照版本之间的样本是独立的，因此单样本的统计推断理清楚了，A/B Test里面的两个样本的统计推断自然也就清楚了。</p>
<p>假设对照版本和实验版本里面各有n个用户，假设对照版本里面n个用户CTR的值为 $x_1，…，x_n$；假设实验版本里面n个用户CTR的值为 $y_1，…，y_n$；用 $\mu_x$ 和 $\mu_y$ 分别代表对照版本和实验版本里面真实的UPV_CTR，在A/B Test里面我们通常关心两个参数：</p>
<ul>
<li>两个版本指标的绝对差：$\mu_y - \mu_x$</li>
<li>两个版本指标的相对差：$(\mu_y - \mu_x)/\mu_x$</li>
</ul>
<p>从假设检验的角度来说，不管关心哪个参数，$H_0$ 都是 $\mu_y = \mu_x$。从置信区间的角度来说，我们需要分别对绝对差和相对差提供区间估计。</p>
<p>在讲假设检验和区间估计的具体计算之前，定义如下的概念：</p>
<ul>
<li>对照版本的样本均值：$\bar{x} = \displaystyle\sum_{i=1}^n{x_i}/n$</li>
<li>实验版本的样本均值：$\bar{y} = \displaystyle\sum_{i=1}^n{y_i}/n$</li>
<li>对照版本的样本标准差：$sd(x) = \sqrt{\displaystyle\sum_{i=1}^n(x_i - \bar{x})^2/(n - 1)}$</li>
<li>实验版本的样本标准差：$sd(y) = \sqrt{\displaystyle\sum_{i=1}^n(y_i - \bar{y})^2/(n - 1)}$</li>
<li>对照版本的样本均值的标准误差：$se(\bar{x}) = sd(x)/\sqrt{n}$</li>
<li>实验版本的样本均值的标准误差：$se(\bar{y}) = sd(y)/\sqrt{n}$</li>
</ul>
<p>在假设检验中，定义t统计量为$(\bar{y} - \bar{x})/\sqrt{se(\bar{x})^2 + se(\bar{y})^2}$，再把$t$统计量通过与正态分布对比计算出$P$值。</p>
<p>在区间估计中，我们先设定好置信水平，通常为95%。绝对差的95%置信区间比较容易估计，具体的公式为：</p>
<script type="math/tex; mode=display">[\bar{y}-\bar{x} - 1.96  \sqrt{se(\bar{x})^2 + se(\bar{y})^2}， \bar{y}-\bar{x} + 1.96  \sqrt{se(\bar{x})^2 + se(\bar{y})^2}]</script><p>相对差的置信区间比较麻烦，因为相对差的点估计为$(\bar{y}-\bar{x})/\bar{x}$，这个点估计的分子和分母都是随机的，因此之前约定的是在计算相对差的置信区间时假设$\bar{x}$的随机性可以忽略，这样我们可以先计算出$\mu_y$的置信区间，再用这个置信区间的上下界除以$\bar{x}$再减去1得到相对差的置信区间的上下界。具体的公式为：</p>
<script type="math/tex; mode=display">[\bar{y}-1-1.96se(\bar{y})/\bar{x}， \bar{y}-1+1.96se(\bar{y})/\bar{x}]</script><p>如果考虑$\bar{x}$的随机性，相对差的置信区间应该如何计算呢?<br>此时需要更加严格的估计 $\bar{y}/\bar{x}$ 的方差：$\bar{y}/\bar{x}$ 更加严格的方差为: <script type="math/tex">se(\bar{y})^2/\bar{x}^2 + se(\bar{x})^2\bar{y}^2/\bar{x}^4</script>。<br>定义: <script type="math/tex">se(\bar{y}/\bar{x})=\sqrt{se(\bar{y})^2/\bar{x}^2 + se(\bar{x})^2\bar{y}^2/\bar{x}^4}</script>，<br>则相对差的95%的置信区间为: <script type="math/tex">[\bar{y}/\bar{x}-1-1.96se(\bar{y}/\bar{x})，\bar{y}/\bar{x}-1+1.96se(\bar{y}/\bar{x})]</script>。</p>
]]></content>
      <tags>
        <tag>ABTest</tag>
      </tags>
  </entry>
  <entry>
    <title>我看过的书</title>
    <url>/2019/09/21/book/</url>
    <content><![CDATA[<p>人总是善忘的，陆陆续续的看过很多书了，在这里记录一下。也是为了更好的督促自己，持续更新。</p>
<h4 id="2019年度"><a href="#2019年度" class="headerlink" title="2019年度"></a>2019年度</h4><h5 id="【文学-历史】"><a href="#【文学-历史】" class="headerlink" title="【文学/历史】"></a>【文学/历史】</h5><ol>
<li><strong>《一句顶一万句》</strong> 已看完 (注：人与人之间虽说来往不多，单并不孤独，与人对话的中国文化和浮生百姓，却因为极端注重现实和儒家传统，由于其社群、地位和利益不同，由于其人心难测和诚信缺失，能够说贴心话和温暖灵魂的朋友并不多，反倒生活在千年的孤独中 选自编者荐言）</li>
<li><strong>《浮生六记》</strong> 已看完 (注：如果有人问我爱情应该是什么样子？我会问答那就是沈复和芸娘的样子。林语堂先生说“他是中国文学里面最可爱的女子”）</li>
<li><strong>《了不起的盖茨比》</strong> 已看完 (注: “每当你想批评别人”，他告诉我“你都要记住，世人都没有你所拥有的又是”)</li>
</ol>
<h5 id="【数学-物理】"><a href="#【数学-物理】" class="headerlink" title="【数学/物理】"></a>【数学/物理】</h5><ol>
<li><strong>《数学之美》</strong> 已看完 (注：最早源自吴军博士在Google黑板报持续连载的文章，后来整理书籍出版，主要用通俗的语言讲解了目前主流的互联网技术如语音识别、搜索引擎、人工智能等背后的数学原理，带你领略数学的魔力）</li>
<li><strong>《你的灯亮着吗?》</strong> 待看</li>
<li><strong>《追寻记忆的痕迹》</strong> 待看</li>
<li><strong>《费马大定理》</strong> 已看完（注：一部波澜壮阔的数学史，智商上面的各种比拼，关于的数学界的爱恨情仇，纯粹的真理追求，总之这本书会改善你对数学的认知，说不定从此你就发现了数学的美，不能自拔）</li>
<li><strong>《数学的发现》</strong> 待看</li>
<li><strong>《怎样解题》</strong> 待看</li>
</ol>
<h5 id="【心理学】"><a href="#【心理学】" class="headerlink" title="【心理学】"></a>【心理学】</h5><ol>
<li><strong>《爱的艺术》</strong> 已看完</li>
<li><strong>《乌合之众》</strong> 已看完</li>
<li><strong>《人性的弱点》</strong> 已看完</li>
<li><strong>《荣格自传》</strong> 已看完</li>
<li><strong>《简捷启发式》</strong>（听说晦涩难懂）待看</li>
<li><strong>《找寻逝去的自我》</strong>待看</li>
<li><strong>《社会心理学》</strong>待看</li>
<li><strong>《别做正常的傻瓜》</strong>待看</li>
<li><strong>《决策与判断》</strong>（论文写法，难读）待看</li>
<li><strong>《幸福的方法》</strong>（泰勒本的积极心理学,看过公开课）待看</li>
<li><strong>《与“众”不同的心理学》</strong></li>
</ol>
<h5 id="【互联网】"><a href="#【互联网】" class="headerlink" title="【互联网】"></a>【互联网】</h5><ol>
<li><strong>《集体智慧编程》</strong> 待看</li>
</ol>
<h5 id="【其他】"><a href="#【其他】" class="headerlink" title="【其他】"></a>【其他】</h5><ol>
<li><strong>《态度》</strong> 吴军著 已看完</li>
<li><strong>《见识》</strong> 吴军著 已看完</li>
<li><strong>《你的第一本保险指南》</strong> 已看完</li>
</ol>
<hr>
<p align="center"><font color="blue">一分钟到底有多长？这要看你是蹲在厕所里面，还是等在厕所外面。</font></p>

<hr>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>三年之痒</title>
    <url>/2019/07/01/three/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>二零一九年阴历五月二十九日，己亥年己亥日，阳历七月一日。在中信书店细数着过去这的几年，猛地发现很多事情到今天确实该扎个结了。九十八年前的今天中国共产党成立、二十五年前的今天我来到了这个世界、三年前的今天我从大学毕业开始真正走入这个世界。在人生四分之一的时光里我不断和这个世界里面的人、物、事互相碰撞，产生的花火一次又一次的在黑暗照亮前方的道路，让自己没有迷失。</p>
<p>写这篇文章的时候瞅了瞅前面写的一年之痒，那个时候的自己刚从大学毕业，任性、天真、想的少，当然过的也很开心。现在看来却只想会心一笑，告别那个无忧无虑的自己。最开始我不是很明白有的人为什么会花一天的时间来写写总结，此刻大概懂了，这也许就是成长吧。接下来我会在每个重要的阶段写下这段时间我的思考，慢慢铺满自己心智成熟的道路。</p>
<h2 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h2><p>这个对我而言从来很少思考的名词却在毕业后不断走进我的心灵。从小一个人生活惯了就以为周围的人应该和自己一样吧，到了大学才发现，很多同学都是第一次离开家门。最开始的我不太能确定这样的差异那个好那个坏，看着自己有条不紊的安排学习而很多人却在游戏中放纵，那个时候心里很坚定的认为还是从小独立的好，却不知道那是自己埋在骨子里的自卑和做好一件事就有点自负的致命缺点，这个缺点后面在我面试、工作、交友过程中一次又一次的刺痛我。我开始去思考为什么自己会形成这样的性格，这也是我为什么开始去看一些心理学的科普书籍。从《少有人走过的路》和《亲密关系》中我有点明白了自己成年后的种种言语和行为或多或少都有一种阴影——在寻找童年中的缺失。著名心理学家阿德勒说过一句话：幸福的人一生都在被童年治愈，不幸的人一生都在治愈童年。我不能说这句话对每个人都适合，但是对于我却是很深刻。自己之前很在意别人对自己的看法，很怕周围的人不喜欢自己，内心不停的想得到周围人关注和认可。一旦做了某件事就想引起周围人的注意，这又从侧面反映了自己的不自信。慢慢的认识了自己这样的性格之后，我开始思考家庭重要性以及自己的家庭。孩子从小就在不停的学习，而这个学习的对象在很长一段时间来自家庭里面的父母，所以养不教、父之过也是有一定道理的。因此我认为现在的自我教养和成长在一定程度上也就是以后你孩子的模样。上一辈人有他们自己的观念，他们生活在那个年代的教育、经历、和条件决定了他们对教育孩子的认知程度，所以我从来没有觉得自己家庭很糟糕，虽然童年大部分时间一个人生活造成了某些性格上面的缺席，但是还是很感谢自己的父母让我一直接受教育，才有机会认识到自己、才有机会改正自己变的更好、才有机会去理解你们。</p>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>最近一年多的时间我一直在陌陌做推荐相关的工作，算是一个新的方向，但是使用的一些基础技术都没什么变化，总体还是以微服务为主。在饿了么的工作经历让我更多的关注在业务方面以及怎么快速有效的完成领导布置的任务。而在陌陌的这一年多成长很多，开始了一个人从头到尾的去负责一个项目，关注点不仅仅在单一的功能上面了，由最开始的各种性能优化、代码重构到整体的高可用和持续发展都做了不少探索，慢慢的开始从宏观的角度去思考一些东西，这也是自己目前主要的能力提升。从15年暑假来到北京实习开始如今已经四年了，真的要感概时间的流逝以及猝不及防的让你感觉和周围人拉开了差距。这些年给我的感受就是，比你优秀的人真的还比你更加努力，这就是现实。我们还没有到真正拼天赋的时候，有时候你只需要比大部分人稍微努力一点就可以超过很多人，这也是现实。很庆幸自己从小的习惯让我有持续学习的能力，加上赶上了互联网浪潮，才能让自己拥有还不错的工作。之前听马云说过这样的话：一个员工的离职无外乎两个原因，一个是心里委屈了，二是钱给的少了。其实在某些方面反应了员工的诉求，我考虑的点一个是目前这个团队能不能让你有晋升和学习的空间也就是常说的是不是瓶颈了，二是目前的工作强度和应得的报酬是否匹配。刚来到北京工作的时候我在想，自己大学选的专业还很正确嘛，毕业就找到不错的工作了。其实那个时候的认知还很肤浅，认为大学选个好的专业就OK了，殊不知在很多人认为选择好的专业只是恰巧这个专业刚好很流行罢了，这只是运气好。社会的快速发展，不知道明天谁又会被取代，十几年前肯定大学很少有人选择人工智能这个专业，在看看现在挤破头都想去。我觉得大学培养的一个能力特别重要，那就是自我学习能力，现在社会的医疗设施已经很完善了，很多人都能活到七八十岁，那么漫长的生涯你不可能只会大学里面学的那点专业，你或多或少会去学习其他的职业能力。还有这几年让我还有一些认识就是大学里面不用非得大部分的时间都放在学习专业知识上面，应该多去选修些人文课程。因为专业的知识在你毕业之后有大量的时间去学习，而公司也不太会看重你大学学了多少知识，最多在刚开始工作的时候有些许差距，时间一长几乎就没有了。毕业之后我们几乎不会在主动接受人文知识的熏陶和学习，所以大学四年是一个很好的机会，这些能让我们更好的了解这个社会，了解自己。</p>
<h2 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h2><p>如果要说人生当中有什么是比较难的事情，那么认识自己肯定当选。很早之前我们都是在父母和老师的教育下长大，要好好读书，将来好回报社会。我们也懵懵懂懂的经过了小学、初中、高中、大学，等到工作之后才会开始思考自己究竟想要什么的生活，有的人即使一生也没有想过，不过没关系。每个人都有自己的生活方式，有自己的选择，没有对错没有好坏。《了不起的盖茨比》中有一句话：每当你想批评别人，他告诉我，你都要记住，世人都没有你所有拥有的优势。这句话对我有了很深的影响，每当我的主观世界和客观世界碰撞的时候，我总会想起这句话，之前我很容易心里会想他怎么会这样，这样的事情怎么会发生在这样的人身上等等类似这样的事情，慢慢的我开始是接受每个人的不同，开始接受自己三观不断的重塑，不在固执己见，说白了就是和自己妥协了、和解了。对于我自己想要的生活，之前很明白现在又不明白了，我也不着急，这是一个长久的过程，刚毕业的时候我看了那个时候的状态，想要的生活也很简单，可是现在却变了，所以我现在不想信誓旦旦的写下我想要的生活，说不定不明天就变了。不过我比较清楚的一点是我知道自己想做的很多事情都需要钱来支持，所以我会努力的工作和学习，不断成长。最后我想用《爱的艺术中》中的一段话来结束：最后，整个已成熟的人走到这一步，他是自己的父母。他既有母亲的良心，也有父亲的品德。母亲的良心是说：“没有任何错误或罪恶可以剥夺我对你的爱以及我对你生命和幸福的期望。”父亲的良心是：“你错了，你就不能回避由你的错误行为所造成的后果，如果要我喜欢你，重要的是你必须改正错误。”</p>
<p>相信你会变的更好，二十五岁的你，生日快乐。</p>
<hr>
<p align="center"><font color="blue">众里寻他千百度。蓦然回首，那人却在，灯火阑珊处。</font></p><p align="right">——青玉案·元夕 辛弃疾</p>

<hr>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis GEO 详解</title>
    <url>/2019/06/25/RedisoGeo/</url>
    <content><![CDATA[<p>前段时间自己在做附近直播相关业务，其中有一个核心的点就是检索用户附近的主播，也是主要召回池。针对业务场景的特殊性，最后决定使用<strong>Redis</strong>的<strong>GEO</strong>技术来完成这个功能。主要考虑点在于每天在线直播的主播数量是固定的差不多一万这个量级，使用配置好一点的单机<strong>Redis</strong>单<strong>key</strong>存储是没问题的。数据操作主要有两个：一是主播开播的时候写入主播<strong>Id</strong>的经纬度，二是主播关播的时候删除主播<strong>Id</strong>元素。这样就维护了一个具有位置信息的在线主播集合提供给线上检索。下面详细介绍一下。</p>
<h5 id="Redis-GEO-命令"><a href="#Redis-GEO-命令" class="headerlink" title="Redis GEO 命令"></a>Redis GEO 命令</h5><p>【<strong>GEOADD key longitude latitude member</strong>】添加一个空间元素，这里具体业务就是 主播的经纬度和主播的Id。需要注意的是Redis的纬度有效范围不是<strong>[-90,90]</strong>而是<strong>[-85,85]</strong></p>
<p>【<strong>GEORADIUS key longitude latitude radius</strong>】以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。具体业务可以根据当前用户的用户的经纬度，搜索附近100km的主播。</p>
<p>再有就是删除操作，<strong>Redis GEO</strong>结构的数据类型没有提供删除操作。不过我们可以直接使用【<strong>ZREM key member</strong>】这里的<strong>member</strong>就是主播Id。可以这样操作的原因是<strong>Redis GEO</strong> 数据类型内部的存储是<strong>ZSet</strong>结构。</p>
<p>以上就是业务实现的主要操作。Redis更加详细的命令操作参考（<a href="http://redisdoc.com/geo/index.html）" target="_blank" rel="noopener">http://redisdoc.com/geo/index.html）</a><br>下面我们具体聊聊其中的原理。</p>
<h5 id="Redis-GEO-原理"><a href="#Redis-GEO-原理" class="headerlink" title="Redis GEO 原理"></a>Redis GEO 原理</h5><p>讲<strong>Redis GEO</strong>实现之前需要先明白一些关于空间索引的算法<strong>GEOHASH</strong>的知识。针对索引我们日常所见都是一维的字符，那么如何对三维空间里面的坐标点建立索引呢，直接点就是三维变二维，二维变一维。</p>
<p>地球纬度区间是<strong>[-90,90]</strong>,经度区间是<strong>[-180,180]</strong>。 将它展开想象成一个矩形。</p>
<p><img src="/img/rectangle.png" align="center" width="80%" height="80%"></p>
<p>通过上面的方法将地球的表面转换成二维空间的平面，那接下来就是如何将二维换行成一维了。我们先将平面切割成四个正方形，然后用简单的 01 编码来标识这个四个正方形，最后按照编码的大小将四个正方形连接起来，这样整个平面就转换成了一条Z曲线，变成了一维。我们递归对每个正方形做同样的操作，递归的层次越深，整个平面就逐渐被Z曲线填充。我们的点也会落在每个小正方形里面，小正方形越小，精度就越高。如下图所示:</p>
<p><img src="/img/z.png" alt></p>
<p>转成一维以后接下来就如何建立索引了。当我们拿到一个经纬度之后按照如下方式进行编码。</p>
<p><img src="/img/lat.jpg" align="center" height="90%"></p>
<p>从上面的图可以发现二分的次数越多就越接近经纬度的实际值，和前面提到的不断递归正方形是一个意思。按照上面的方式我们选定一个二分的深度（也就是精度）分别对经纬度进行编码。然后按照以<strong>奇数为纬度，偶数为经度</strong>组合成一个二进制序列，再将获取到的经纬度组合二进制序列以每5个数为一组，将每一组都进行转换成十进制数字，最后采用<strong>Base32</strong>对应编码规则进行转换可得到编码，也就是最后的索引。</p>
<p><img src="/img/combina.jpg" align="center" width="90%"></p>
<p>通过上面几个步骤介绍了一下<strong>GeoHash</strong>具体的流程、有了上面这个知识点，理解<strong>Redis GEO</strong>原理就很简单了，<strong>Redis</strong>使用<strong>ZSet</strong>的方式存储<strong>Geo</strong>类型的数据，有序集合里面的<strong>member</strong>是具体的业务对象，<strong>score</strong>就是该业务对象的经纬度进行<strong>GeoHash</strong>编码之后将二级制序列转成52位整数值数据。当我们想要获取某个经纬度附近的元素时候，先根据当前经纬度计算出对应的<strong>GeoHash</strong>块（52位整数值）,在根据半径计算出当前<strong>hash</strong>块周围的8个<strong>hash</strong>块，然后在根据score值获取这8个<strong>hash</strong>块范围内的元素返回。</p>
<h5 id="GEO-HASH-延伸"><a href="#GEO-HASH-延伸" class="headerlink" title="GEO HASH 延伸"></a>GEO HASH 延伸</h5><p>对于一个经纬度，如果我们编码的时候选择对经度二分3次（3位二进制），对维度二分2次（2位二进制），最后组合成一个5位的二级进序列，经过<strong>Base32</strong>编码得到一个字符。那么这个字符的一共有2^5=32个，这样就将地图划分为32个块。如下图所示</p>
<p><img src="/img/earth.jpg"></p>
<p><strong>GeoHash</strong>将每一个区域画成一块块矩形块，每个矩形块使用一个字符串表示，当我们需要查询附近的点时，通过自己的坐标计算出一个字符串，根据这个字符串定位到我们所在的矩形块，然后返回这个矩形块中的点。然后根据编码的深度来确定精度，或者根据Base32编码之后字符的长度来确定块的所表示的区域大小。</p>
<p><img src="/img/precision.jpg" align="center"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>length</th>
<th>width</th>
<th>height</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>5000km</td>
<td>5000km</td>
</tr>
<tr>
<td>2</td>
<td>1250km</td>
<td>625km</td>
</tr>
<tr>
<td>3</td>
<td>156km</td>
<td>156km</td>
</tr>
<tr>
<td>4</td>
<td>39.1km</td>
<td>19.5km</td>
</tr>
<tr>
<td>5</td>
<td>4.89km</td>
<td>4.89km</td>
</tr>
<tr>
<td>6</td>
<td>1.22km</td>
<td>0.61km</td>
</tr>
<tr>
<td>7</td>
<td>153m</td>
<td>153m</td>
</tr>
<tr>
<td>8</td>
<td>38.2m</td>
<td>19.1m</td>
</tr>
<tr>
<td>9</td>
<td>4.77m</td>
<td>4.77m</td>
</tr>
<tr>
<td>10</td>
<td>1.19m</td>
<td>0.596m</td>
</tr>
<tr>
<td>11</td>
<td>149mm</td>
<td>149mm</td>
</tr>
<tr>
<td>12</td>
<td>37.2mm</td>
<td>18.6mm</td>
</tr>
</tbody>
</table>
</div>
<p>对于这样的编码方式有一定的局限性：<strong>在拥有局部保序性的同时，具有突变性。导致一些邻近点真实并不是距离较近的点。</strong></p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="http://geohash.gofreerange.com/" target="_blank" rel="noopener">http://geohash.gofreerange.com/</a><br><a href="https://halfrost.com/go_spatial_search/" target="_blank" rel="noopener">https://halfrost.com/go_spatial_search/</a><br><a href="https://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">https://www.cnblogs.com/LBSer/p/3310455.html</a></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>协同过滤中的相似度</title>
    <url>/2019/06/19/recommendSimilar/</url>
    <content><![CDATA[<p>先不谈深奥难懂的机器学习，推荐系统核心问题是寻找相似的用户以及相似的物品，如何判断相似是这篇文章所要探讨的。</p>
<p>先用主观意识去思考一个问题，现实生活中我们是怎么判断某个人和自己很像。你会从他的日常行为、长相、穿着等方面去衡量。那怎么将这些主观的意识转换成计算机可理解的，我们可以把日常的行为、喜好当做不同的维度，比是否喜欢唱歌，是否爱看书这两个维度来衡量，那么我们就可以用向量的形式来表达(1,1)、(1,0)、(0,0)。那么问题就转化成怎么判断向量之间是相似的，转换成数学意义就是距离或者方向。距离越近越相似，方向越靠近约相似。</p>
<p>这样相似度的计算对象就是向量了，或者叫做高维空间下的坐标，然后表示向量数值的类型有两种，一个是实数值 一个是布尔值。下面根据不同的计算方式来理解二者的不同。</p>
<script type="math/tex; mode=display">p = (p_1,p_2,p_3,...,p_n)</script><script type="math/tex; mode=display">q = (q_1,q_2,q_3,...,q_n)</script><h5 id="欧式距离"><a href="#欧式距离" class="headerlink" title="欧式距离"></a>欧式距离</h5><p>欧式距离是一个欧式空间下度量距离的的方法。两个物体在同一空间下表示为两个点，假如叫做 p 和 q，分别都是 n 个坐标（即就是 n 维）。</p>
<script type="math/tex; mode=display">E(p,q) = \sqrt{\sum_{i=1}^{n}(p_i - q_i)^2}</script><p>显然，欧式距离得到的值是一个非负数，最大值是正无穷。一般相似度的度量结果希望是[-1,1] 或者 [0,1] 之间的，所以这个公式无法在正常的场景中使用，需要做个转换。</p>
<script type="math/tex; mode=display">similar = \frac{1}{1 + E(p,q)}</script><p>上面这个公式把 0 到正无穷的欧式距离转换成 0 到 1 的相似度。</p>
<p><strong>欧式距离度量的是空间两个点的绝对差异，适用于分析用户能力模型之间的差异，比如消费能力，贡献能力</strong>。</p>
<h5 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h5><p>余弦相似度度量的是两个向量之间的夹角，也就是夹角的余弦值。当两个向量的夹角为 0 度时，余弦值为 1，当夹角为 90 度时，余弦值为0，夹角为 180度时，余弦值为 -1。取值的范围为[-1,1]。</p>
<script type="math/tex; mode=display">cos(p,q) = \frac{\sum_{i}p_iq_i}{\sqrt{\sum_{i}p_i^2}\sqrt{\sum_{i}q_i^2}}</script><p>余弦相似度的特点：<strong>它和向量的长度无关，两个向量，只要方向一致，无论程度强弱，都可以认为是相似的</strong>。在协同过滤中，余弦相似度某种程度上更加依赖两个物品的共同评价用户数，而不是用户给予的评分多少，这就是余弦相似度被向量长度归一化后的结果。比如这样的一个例子，用户A对两部电影的评分分别是 1 分和 2分，用户B对同样的两部电影评分分别是 4 分和 5 分，通过余弦相似度计算的出来的结果达到0.98。这和实际的直觉不符合，明明用户A不喜欢这两部电影。针对这个问题，余弦相似度有个改进，就是先计算向量每个维度的均值，然后每个向量在各个维度都减去均值后在计算余弦值。</p>
<p><strong>余弦相似度在度量文本相似度、用户相似度、物品相似度的时候比较常用。</strong></p>
<h5 id="皮尔逊相关度"><a href="#皮尔逊相关度" class="headerlink" title="皮尔逊相关度"></a>皮尔逊相关度</h5><p>皮尔逊相关度本质上也是一种余弦相似度，不对是先对向量做了中心化，向量 p 和 q 各自减去向量的均值后，在计算余弦相似度。</p>
<script type="math/tex; mode=display">R(p,q) = \frac{\sum_{i=1}^{n}(p_i - \bar p)(q_i - \bar q)}{\sqrt{\sum_{i=1}^{n}(p_i-\bar p)^2}\sqrt{\sum_{i=1}^{n}(p_i-\bar p)^2}}</script><p>这里需要注意的是和上面的余弦相似度优化算法不一样的是<strong>前者是对列向量中心化，后者是对行向量中心化</strong>。皮尔逊相关度度量的是两个随机变量是不是在同增同减。变化趋势是否一致，所以不是适合用作计算布尔值向量之间的相关度，因为两个布尔值向量也就是对应两个0-1分布的随机变量，这样的随机变量的变化只有0和1两个值，也就没有变化趋势这一说。</p>
<h5 id="杰卡德（Jaccard）相似度"><a href="#杰卡德（Jaccard）相似度" class="headerlink" title="杰卡德（Jaccard）相似度"></a>杰卡德（Jaccard）相似度</h5><p>杰卡德相似度是两个集合的交接元素个数在并集中所占比例，非常实用与布尔值向量计算，比如用户之间的收藏行为。</p>
<script type="math/tex; mode=display">J(A,B) = \frac{|A \bigcap B|}{|A \bigcup B|}</script>]]></content>
      <tags>
        <tag>Recommend</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器之CMS</title>
    <url>/2018/11/17/CMS/</url>
    <content><![CDATA[<p>JVM CMS垃圾回收器探索</p>
<h2 id="CMS简介"><a href="#CMS简介" class="headerlink" title="CMS简介"></a>CMS简介</h2><p>&emsp;CMS垃圾回收器是针对<strong>老年代</strong>的回收方式、是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这个方式非常适合。在JVM启动参数上面加上 <em>XX:+UseConcMarkSweepGC</em> 表示老年代使用CMS的方式回收，CMS的回收算法是&ensp;<strong>标记-清除</strong></p>
<h2 id="CMS执行过程"><a href="#CMS执行过程" class="headerlink" title="CMS执行过程"></a>CMS执行过程</h2><h3 id="1-STW-initial-mark"><a href="#1-STW-initial-mark" class="headerlink" title="1.STW initial mark"></a>1.STW initial mark</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">46.066</span>+<span class="number">0800</span>: <span class="number">58424.191</span>: [GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: <span class="number">3636058</span>K(<span class="number">5592448</span>K)] <span class="number">3691980</span>K(<span class="number">7829376</span>K), <span class="number">0.0037087</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span>secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>初始标记：</strong> 这个阶段JVM停止正在执行的任务。从根对象开始扫描和root对象直接关联的对象。这个过程会很快。</p>
<h3 id="2-Concurrent-marking"><a href="#2-Concurrent-marking" class="headerlink" title="2.Concurrent marking"></a>2.Concurrent marking</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">46.070</span>+<span class="number">0800</span>: <span class="number">58424.195</span>: [CMS-concurrent-mark-start]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">46.122</span>+<span class="number">0800</span>: <span class="number">58424.247</span>: [CMS-concurrent-mark: <span class="number">0.051</span>/<span class="number">0.051</span> secs] [Times: user=<span class="number">0.57</span> sys=<span class="number">0.00</span>, real=<span class="number">0.05</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>并发标记：</strong> 这个阶段JVM标记线程和用户线程并发执行。在初始标记的基础上继续向下追溯扫描对象，这个过程不会停顿。</p>
<h3 id="emsp-Concurrent-precleaning"><a href="#emsp-Concurrent-precleaning" class="headerlink" title="&emsp;Concurrent precleaning"></a>&emsp;Concurrent precleaning</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">46.122</span>+<span class="number">0800</span>: <span class="number">58424.247</span>: [CMS-concurrent-preclean-start]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">46.143</span>+<span class="number">0800</span>: <span class="number">58424.268</span>: [CMS-concurrent-preclean: <span class="number">0.021</span>/<span class="number">0.021</span> secs] [Times: user=<span class="number">0.04</span> sys=<span class="number">0.01</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>并发预清理：</strong> 这个阶段JVM标记线程和用户线程并发执行。JVM查找在并发标记阶段新进入老年代的对象。通过从新扫描减少下一个阶段的工作，这个过程不会停顿。</p>
<h3 id="3-STW-remark"><a href="#3-STW-remark" class="headerlink" title="3.STW remark"></a>3.STW remark</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.486</span>+<span class="number">0800</span>: <span class="number">58425.611</span>: [GC (CMS Final Remark) [YG occupancy: <span class="number">1078027</span> K (<span class="number">2236928</span> K)]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.486</span>+<span class="number">0800</span>: <span class="number">58425.611</span>: [GC (CMS Final Remark)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.486</span>+<span class="number">0800</span>: <span class="number">58425.611</span>: [ParNew: <span class="number">1078027</span>K-&gt;<span class="number">40803</span>K(<span class="number">2236928</span>K), <span class="number">0.0066178</span> secs] <span class="number">4714086</span>K-&gt;<span class="number">3676908</span>K(<span class="number">7829376</span>K), <span class="number">0.0069331</span> secs] [Times: user=<span class="number">0.14</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.493</span>+<span class="number">0800</span>: <span class="number">58425.618</span>: [Rescan (non-parallel)</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.493</span>+<span class="number">0800</span>: <span class="number">58425.618</span>: [grey object rescan, <span class="number">0.0209332</span> secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.514</span>+<span class="number">0800</span>: <span class="number">58425.639</span>: [root rescan, <span class="number">0.0128484</span> secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.527</span>+<span class="number">0800</span>: <span class="number">58425.652</span>: [visit unhandled CLDs, <span class="number">0.0000249</span> secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.527</span>+<span class="number">0800</span>: <span class="number">58425.652</span>: [dirty klass scan, <span class="number">0.0011690</span> secs], <span class="number">0.0350621</span> secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.528</span>+<span class="number">0800</span>: <span class="number">58425.653</span>: [weak refs processing, <span class="number">0.0536894</span> secs]</span><br><span class="line">2018-11-21T11:41:47.582+0800: 58425.707: [class unloading, 0.0251479 secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.607</span>+<span class="number">0800</span>: <span class="number">58425.732</span>: [scrub symbol table, <span class="number">0.0052907</span> secs]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.613</span>+<span class="number">0800</span>: <span class="number">58425.737</span>: [scrub string table, <span class="number">0.0009897</span> secs][<span class="number">1</span> CMS-remark: <span class="number">3636104</span>K(<span class="number">5592448</span>K)] <span class="number">3676908</span>K(<span class="number">7829376</span>K), <span class="number">0.1292316</span> secs] [Times: user=<span class="number">0.25</span> sys=<span class="number">0.01</span>, real=<span class="number">0.13</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>重新标记：</strong> 这个阶段JVM停止正在执行的任务。最终确认老年代中存活的对象，因为之前的处理都是并发的，应用程序也在不停的分配对象。</p>
<h3 id="4-Concurrent-sweeping"><a href="#4-Concurrent-sweeping" class="headerlink" title="4.Concurrent sweeping"></a>4.Concurrent sweeping</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">47.616</span>+<span class="number">0800</span>: <span class="number">58425.741</span>: [CMS-concurrent-sweep-start]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">50.523</span>+<span class="number">0800</span>: <span class="number">58428.648</span>: [CMS-concurrent-sweep: <span class="number">2.889</span>/<span class="number">2.908</span> secs] [Times: user=<span class="number">5.07</span> sys=<span class="number">0.13</span>, real=<span class="number">2.91</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>并发清理：</strong> 这个阶段JVM清理线程和用户线程并发执行，清理死亡对象。</p>
<h3 id="5-Concurrent-reset"><a href="#5-Concurrent-reset" class="headerlink" title="5.Concurrent reset"></a>5.Concurrent reset</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">50.524</span>+<span class="number">0800</span>: <span class="number">58428.649</span>: [CMS-concurrent-reset-start]</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T11:<span class="number">41</span>:<span class="number">50.537</span>+<span class="number">0800</span>: <span class="number">58428.662</span>: [CMS-concurrent-reset: <span class="number">0.014</span>/<span class="number">0.014</span> secs] [Times: user=<span class="number">0.03</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br></pre></td></tr></table></figure>
<p>&emsp;<strong>并发重置：</strong> 重置CMS收集器数据结构，等待下一次回收。</p>
<h2 id="CMS参数优化"><a href="#CMS参数优化" class="headerlink" title="CMS参数优化"></a>CMS参数优化</h2><ol>
<li>由于CMS垃圾回收器使用的是标记-清除回收算法，随着GC的执行老年代会逐渐产生内存碎片,可以使用 <em>-XX:+UseCMSCompactAtFullCollection</em> 这个参数在每次执行CMS GC之后进行一次压缩处理。可以根据自己的应用老年代对象的情况调整 <em>-XX:CMSFullGCsBeforeCompaction=1</em> 这个参数来控制每隔几次GC之后进行压缩操作。</li>
<li>CMS在垃圾回收的过程当中，会不停的有新对象在老年代分配，在CMS回收之前必须留有一部分空间，所以CMS不会在老年代满了的时候开始回收，使用 <em>-XX:CMSInitiatingOccupancyFraction=65 -XX:+UseCMSInitiatingOccupancyOnly</em> 这个两个参数来配置老年代空间到达什么阈值之后开始回收。特别注意的是如果不配置第二个参数，CMS只会在第一次回收的按照设置的阈值，后面CMS会根据情况动态调整阈值参数。</li>
<li>由CMS回收的过程中我们可以知道，在初始标记和重新标记两个阶段会STW，所以为了使得这两个阶段尽可能快一点执行完成，可以使用 <em>-XX:+CMSParallelInitialMarkEnabled -XX:+CMSParallelRemarkEnabled</em> 这个参数来开启并行标记。</li>
<li>在CMS回收的过程中，耗时最长的是重新标记阶段，可以使用 <em>-XX:+CMSScavengeBeforeRemark</em> 这个参数在重新标记之前执行一次Young GC。这样Young区待标记的对象就会减少很多，重新标记阶段的工作量就会少很多。因为执行Young GC也有一定的耗时，所以这个参数需要自己做一个权衡。</li>
</ol>
<hr>
<p align="center"><font color="blue">人间有味是清欢</font></p>

<hr>
]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>CMS Failed</title>
    <url>/2018/11/17/GC/</url>
    <content><![CDATA[<p>CMS 日志Promotion Failed 和 Concurrent Model Failed 错误分析</p>
<h5 id="Promotion-Failed"><a href="#Promotion-Failed" class="headerlink" title="Promotion Failed"></a>Promotion Failed</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">内存情况</span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">40</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">70</span></span><br><span class="line">   MaxHeapSize              = <span class="number">8589934592</span> (<span class="number">8192.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">2863267840</span> (<span class="number">2730.625</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">2863267840</span> (<span class="number">2730.625</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">5726666752</span> (<span class="number">5461.375</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">3</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">错误日志</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">15</span>T09:<span class="number">01</span>:<span class="number">50.794</span>+<span class="number">0800</span>: <span class="number">51454.418</span>: [GC (Allocation Failure) <span class="number">2018</span>-<span class="number">11</span>-<span class="number">15</span>T09:<span class="number">01</span>:<span class="number">50.794</span>+<span class="number">0800</span>: <span class="number">51454.419</span>: [ParNew (promotion failed): <span class="number">1782424</span>K-&gt;<span class="number">1769555</span>K(<span class="number">2236928</span>K), <span class="number">0.8356030</span> secs]<span class="number">2018</span>-<span class="number">11</span>-<span class="number">15</span>T09:<span class="number">01</span>:<span class="number">51.630</span>+<span class="number">0800</span>: <span class="number">51455.254</span>: [CMS: <span class="number">3509138</span>K-&gt;<span class="number">874891</span>K(<span class="number">5592448</span>K), <span class="number">4.5982825</span> secs] <span class="number">5290213</span>K-&gt;<span class="number">874891</span>K(<span class="number">7829376</span>K), [Metaspace: <span class="number">56929</span>K-&gt;<span class="number">56929</span>K(<span class="number">1101824</span>K)], <span class="number">5.4344311</span> secs] [Times: user=<span class="number">3.61</span> sys=<span class="number">2.44</span>, real=<span class="number">5.43</span> secs]</span><br></pre></td></tr></table></figure>
<p>上面是一次GC日志、从错误信息来看是Eden区的对象晋升失败了。从日志我们看出来Young GC的时候只回收了（178242-176955）12869k对象、剩下176955k(1.68G)存活对象需要放入到Survivor区、由上面的配置我们推算出Survivor区只有546M的大小、这个时候肯定需要放入Old区了。而此时的Old区剩余（5290213k-3509138k）1.69G的内存、需要放入（1.68G-546M）1.14G大小的对象。这里是不是觉得应该放的下。其实CMS使用的标记清理的内存回收算法，随着时间的迁移会逐渐产生内存碎片。此时如果存活对象中有大对象而且内存碎片不足以分配就会发生上面日志中的那种情况。这个时候CMS会执行GC回收Old区然后放存活的对象。由于整个过程是在ParNew阶段，所以整个过程是STW的。后果可想而知。<br>其实问题的核心是Young GG的时候为什么有那么多存活的对象。这个问题就要根据自己当时的具体情况去分析了。</p>
<h5 id="Concurrent-Model-Failed"><a href="#Concurrent-Model-Failed" class="headerlink" title="Concurrent Model Failed"></a>Concurrent Model Failed</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T20:<span class="number">22</span>:<span class="number">38.029</span>+<span class="number">0800</span>: <span class="number">447086.973</span>: [GC (Allocation Failure) <span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T20:<span class="number">22</span>:<span class="number">38.029</span>+<span class="number">0800</span>: <span class="number">447086.973</span>: [ParNew: <span class="number">559232</span>K-&gt;<span class="number">559232</span>K(<span class="number">559232</span>K), <span class="number">0.0000426</span> secs]<span class="number">2018</span>-<span class="number">11</span>-<span class="number">21</span>T20:<span class="number">22</span>:<span class="number">38.029</span>+<span class="number">0800</span>: <span class="number">447086.973</span>: [CMS2018-<span class="number">11</span>-<span class="number">21</span>T20:<span class="number">22</span>:<span class="number">38.482</span>+<span class="number">0800</span>: <span class="number">447087.426</span>: [CMS-concurrent-sweep: <span class="number">0.442</span>/<span class="number">0.467</span> secs] [Times: user=<span class="number">0.48</span> sys=<span class="number">0.03</span>, real=<span class="number">0.47</span> secs]</span><br><span class="line">(concurrent mode failure): <span class="number">1205455</span>K-&gt;<span class="number">965029</span>K(<span class="number">1398144</span>K), <span class="number">2.3149339</span> secs] <span class="number">1764687</span>K-&gt;<span class="number">965029</span>K(<span class="number">1957376</span>K), [Metaspace: <span class="number">54873</span>K-&gt;<span class="number">54873</span>K(<span class="number">1099776</span>K)], <span class="number">2.3157339</span> secs] [Times: user=<span class="number">2.15</span> sys=<span class="number">0.17</span>, real=<span class="number">2.31</span> secs]</span><br></pre></td></tr></table></figure>
<p>CMS GC的执行过程中，由于是并发执行，在回收的过程中会不断有新的对象分配。如果回收的速度赶不上新对象在老年代的分配速度会导致在GC的过程中老年代已经满了，这个时候会STW，执行一次老年代的回收。(这个错误会发生在CMS GC三个并发阶段的任一阶段)。遇到这个错误可以尝试调整堆空间。或者根据具体情况调整CMS GC开始回收的阈值。</p>
]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>IdeaVim</title>
    <url>/2018/09/26/IdeaVim/</url>
    <content><![CDATA[<h2 id="IdaeVim-配置文件-ideavimrc"><a href="#IdaeVim-配置文件-ideavimrc" class="headerlink" title="IdaeVim 配置文件 .ideavimrc"></a>IdaeVim 配置文件 .ideavimrc</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">let</span> mapleader=<span class="string">' '</span></span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="built_in">set</span> ignorecase</span><br><span class="line"><span class="built_in">set</span> smartcase</span><br><span class="line"><span class="built_in">set</span> showmode</span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="built_in">set</span> scrolloff=8</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">history</span>=100000</span><br><span class="line"><span class="built_in">set</span> clipboard=unnamed</span><br><span class="line"></span><br><span class="line"><span class="string">" clear the highlighted search result</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;sc :nohlsearch&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;fs :w&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Quit normal mode</span><br><span class="line">nnoremap &lt;Leader&gt;q  :q&lt;CR&gt;</span><br><span class="line">nnoremap &lt;Leader&gt;Q  :qa!&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" Move half page faster</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Insert mode shortcut</span><br><span class="line">inoremap &lt;C-h&gt; &lt;Left&gt;</span><br><span class="line">inoremap &lt;C-j&gt; &lt;Down&gt;</span><br><span class="line">inoremap &lt;C-k&gt; &lt;Up&gt;</span><br><span class="line">inoremap &lt;C<span class="_">-l</span>&gt; &lt;Right&gt;</span><br><span class="line">inoremap &lt;C<span class="_">-a</span>&gt; &lt;Home&gt;</span><br><span class="line">inoremap &lt;C<span class="_">-e</span>&gt; &lt;End&gt;</span><br><span class="line">inoremap &lt;C<span class="_">-d</span>&gt; &lt;Delete&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" Quit insert mode</span></span><br><span class="line"><span class="string">inoremap jj &lt;Esc&gt;</span></span><br><span class="line"><span class="string">inoremap jk &lt;Esc&gt;</span></span><br><span class="line"><span class="string">inoremap kk &lt;Esc&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Quit visual mode</span><br><span class="line">vnoremap v &lt;Esc&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" Move to the start of line</span></span><br><span class="line"><span class="string">nnoremap H ^</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Move to the end of line</span><br><span class="line">nnoremap L $</span><br><span class="line"></span><br><span class="line"><span class="string">" Redo</span></span><br><span class="line"><span class="string">nnoremap U &lt;C-r&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Yank to the end of line</span><br><span class="line">nnoremap Y y$</span><br><span class="line"></span><br><span class="line"><span class="string">" Window operation</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;ww &lt;C-W&gt;w</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;wd &lt;C-W&gt;c</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;wj &lt;C-W&gt;j</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;wk &lt;C-W&gt;k</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;wh &lt;C-W&gt;h</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;wl &lt;C-W&gt;l</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;ws &lt;C-W&gt;s</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;w- &lt;C-W&gt;s</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;wv &lt;C-W&gt;v</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;w\| &lt;C-W&gt;v</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> Tab operation</span><br><span class="line">nnoremap tn gt</span><br><span class="line">nnoremap tp gT</span><br><span class="line"></span><br><span class="line"><span class="string">" ==================================================</span></span><br><span class="line"><span class="string">"</span> Show all the provided actions via `:actionlist`</span><br><span class="line"><span class="string">" ==================================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"</span> built <span class="keyword">in</span> search looks better</span><br><span class="line">nnoremap / :action Find&lt;CR&gt;</span><br><span class="line"><span class="string">" but preserve ideavim search</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;/ /</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;;; :action CommentByLineComment&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;bb :action ToggleLineBreakpoint&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;br :action ViewBreakpoints&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap cv :action ChangeView&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;cd :action ChooseDebugConfiguration&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap ga :action GotoAction&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gc :action GotoClass&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gd :action GotoDeclaration&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gf :action GotoFile&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gi :action GotoImplementation&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gs :action GotoSymbol&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gt :action GotoTest&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap go :action OptimizeImports&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap fp :action ShowFilePath&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap fu :action FindUsages&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap mv :action ActivateMavenProjectsToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap rc :action ChooseRunConfiguration&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap re :action RenameElement&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap rf :action RenameFile&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nnoremap se :action FindInPath&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap su :action ShowUsages&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gb :action Back&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap gn :action Generate&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;tc  :action CloseActiveTab&lt;CR&gt;</span></span><br><span class="line"><span class="string">nnoremap &lt;Leader&gt;tl Vy&lt;CR&gt;:action ActivateTerminalToolWindow&lt;CR&gt;</span></span><br><span class="line"><span class="string">vnoremap &lt;Leader&gt;tl y&lt;CR&gt;:action ActivateTerminalToolWindow&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="VIM-配置文件"><a href="#VIM-配置文件" class="headerlink" title="VIM 配置文件"></a>VIM 配置文件</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="string">" Configuration file for vim</span></span><br><span class="line"><span class="string">set modelines=0		"</span> CVE-2007-2438</span><br><span class="line"></span><br><span class="line"><span class="string">" Normally we use vim-extensions. If you want true vi-compatibility</span></span><br><span class="line"><span class="string">"</span> remove change the following statements</span><br><span class="line"><span class="built_in">set</span> nocompatible	<span class="string">" Use Vim defaults instead of 100% vi compatibility</span></span><br><span class="line"><span class="string">set backspace=2		"</span> more powerful backspacing</span><br><span class="line"></span><br><span class="line"><span class="string">" Don't write backup file if vim is being called by "</span>crontab -e<span class="string">"</span></span><br><span class="line"><span class="string">au BufWrite /private/tmp/crontab.* set nowritebackup nobackup</span></span><br><span class="line"><span class="string">"</span> Don<span class="string">'t write backup file if vim is being called by "chpass"</span></span><br><span class="line"><span class="string">au BufWrite /private/etc/pw.* set nowritebackup nobackup</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let skip_defaults_vim=1</span></span><br><span class="line"><span class="string">set nu</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set shortmess=atI</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">inoremap jj &lt;Esc&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">noremap H ^</span></span><br><span class="line"><span class="string">noremap L $</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set clipboard=unnamed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set scrolloff=5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set nobackup</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set confirm</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set mouse=a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set expandtab</span></span><br><span class="line"><span class="string">set smarttab</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set autoread</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set cindent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set autoindent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set smartindent</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set cursorline</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set hlsearch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set background=dark</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set showmatch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set ruler</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set nocompatible</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fdm=syntax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fdm=manual</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set novisualbell</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set laststatus=2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">autocmd InsertLeave * se nocul</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">autocmd InsertEnter * se cul</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set showcmd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fillchars=vert:/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fillchars=stl:/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fillchars=stlnc:/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if $TERM_PROGRAM =~ "iTerm"</span></span><br><span class="line"><span class="string">let &amp;t_SI = "\&lt;Esc&gt;]50;CursorShape=1\x7" " Vertical bar in insert mode</span></span><br><span class="line"><span class="string">let &amp;t_EI = "\&lt;Esc&gt;]50;CursorShape=0\x7" " Block in normal mode</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">call pathogen#infect()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"自动开启Nerdtree</span></span><br><span class="line"><span class="string">autocmd vimenter * NERDTree  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"设定 NERDTree 视窗大小</span></span><br><span class="line"><span class="string">let g:NERDTreeWinSize = 35</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"开启/关闭nerdtree快捷键</span></span><br><span class="line"><span class="string">map &lt;C-f&gt; :NERDTreeToggle&lt;CR&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"开启Nerdtree时自动显示Bookmarks</span></span><br><span class="line"><span class="string">let NERDTreeShowBookmarks=1   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"打开vim时如果没有文件自动打开NERDTree</span></span><br><span class="line"><span class="string">autocmd vimenter * if !argc()|NERDTree|endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"当NERDTree为剩下的唯一窗口时自动关闭</span></span><br><span class="line"><span class="string">autocmd bufenter * if (winnr("$") == 1 &amp;&amp; exists("b:NERDTree") &amp;&amp; b:NERDTree.isTabTree()) | q | endif</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"设置树的显示图标</span></span><br><span class="line"><span class="string">let g:NERDTreeDirArrowExpandable = '</span>▸<span class="string">'</span></span><br><span class="line"><span class="string">let g:NERDTreeDirArrowCollapsible = '</span>▾<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"过滤所有.pyc文件不显示</span></span><br><span class="line"><span class="string">let NERDTreeIgnore = ['</span>\.pyc$<span class="string">']  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"是否显示行号</span></span><br><span class="line"><span class="string">let g:NERDTreeShowLineNumbers=1   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"不显示隐藏文件</span></span><br><span class="line"><span class="string">let g:NERDTreeHidden=0     </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"Making it prettier</span></span><br><span class="line"><span class="string">let NERDTreeMinimalUI = 1</span></span><br><span class="line"><span class="string">let NERDTreeDirArrows = 1</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Zookeeper分布式锁</title>
    <url>/2018/06/01/zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>基于Zookeeper的分布式锁</p>
<h5 id="锁流程"><a href="#锁流程" class="headerlink" title="锁流程"></a>锁流程</h5><p><img src="/img/lock.png" alt></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>Curator框架已经实现了基于Zookeeper的可重入的分布式锁 InterProcessMutex</p>
<h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> client client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path   the path to lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(client, path, <span class="keyword">new</span> StandardLockInternalsDriver());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> client client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path   the path to lock</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> driver lock driver</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path, LockInternalsDriver driver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(client, path, LOCK_NAME, <span class="number">1</span>, driver);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InterProcessMutex(CuratorFramework client, String path, String lockName, <span class="keyword">int</span> maxLeases, LockInternalsDriver driver)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//锁节点路径</span></span><br><span class="line">    basePath = PathUtils.validatePath(path);</span><br><span class="line">    <span class="comment">//主要通过LockInternals类实现锁的功能</span></span><br><span class="line">    internals = <span class="keyword">new</span> LockInternals(client, driver, path, lockName, maxLeases);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="获取锁实现-InterProcessMutex-acquire"><a href="#获取锁实现-InterProcessMutex-acquire" class="headerlink" title="获取锁实现 InterProcessMutex.acquire"></a>获取锁实现 InterProcessMutex.acquire</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquire the mutex - blocking until it's available. Note: the same thread</span></span><br><span class="line"><span class="comment">* can call acquire re-entrantly. Each call to acquire must be balanced by a call</span></span><br><span class="line"><span class="comment">* to &#123;<span class="doctag">@link</span> #release()&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception ZK errors, connection interruptions</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//阻塞获取锁 调用internalLock方法</span></span><br><span class="line">    <span class="keyword">if</span> ( !internalLock(-<span class="number">1</span>, <span class="keyword">null</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Lost connection while trying to acquire lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquire the mutex - blocks until it's available or the given time expires. Note: the same thread</span></span><br><span class="line"><span class="comment">* can call acquire re-entrantly. Each call to acquire that returns true must be balanced by a call</span></span><br><span class="line"><span class="comment">* to &#123;<span class="doctag">@link</span> #release()&#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> time time to wait</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> unit time unit</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true if the mutex was acquired, false if not</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> Exception ZK errors, connection interruptions</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在规定的时间内获取锁 调用internalLock方法</span></span><br><span class="line">    <span class="keyword">return</span> internalLock(time, unit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Note on concurrency: a given lockData instance</span></span><br><span class="line"><span class="comment">       can be only acted on by a single thread so locking isn't necessary</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前线程持有的锁</span></span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData != <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// re-entering</span></span><br><span class="line">        <span class="comment">//如果持有锁 再次获取锁 重入</span></span><br><span class="line">        lockData.lockCount.incrementAndGet();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过LockInternals.attemptLock获取锁</span></span><br><span class="line">    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());</span><br><span class="line">    <span class="keyword">if</span> ( lockPath != <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        LockData newLockData = <span class="keyword">new</span> LockData(currentThread, lockPath);</span><br><span class="line">        <span class="comment">//保存当前获取的锁信息</span></span><br><span class="line">        threadData.put(currentThread, newLockData);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">attemptLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit, <span class="keyword">byte</span>[] lockNodeBytes)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span>      startMillis = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> Long      millisToWait = (unit != <span class="keyword">null</span>) ? unit.toMillis(time) : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="keyword">null</span>) ? <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>] : lockNodeBytes;</span><br><span class="line">        <span class="keyword">int</span>             retryCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        String          ourPath = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span>         hasTheLock = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>         isDone = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> ( !isDone )</span><br><span class="line">        &#123;</span><br><span class="line">            isDone = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//先创建临时顺序节点,任何线程获取锁都会先创建临时的顺序节点</span></span><br><span class="line">                <span class="comment">//&#123;basePath&#125;/lock-&#123;sequenceNodeName&#125;</span></span><br><span class="line">                <span class="comment">//basePath 是我们构造方法传入的</span></span><br><span class="line">                <span class="comment">//这个sequenceNodeName是客户端自动生成加上的 客户端能保证每次请求的逐渐增大的</span></span><br><span class="line">                ourPath = driver.createsTheLock(client, path, localLockNodeBytes);</span><br><span class="line">                <span class="comment">//调用internalLockLoop方法获取锁</span></span><br><span class="line">                hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// gets thrown by StandardLockInternalsDriver when it can't find the lock node</span></span><br><span class="line">                <span class="comment">// this can happen when the session expires, etc. So, if the retry allows, just try it all again</span></span><br><span class="line">                <span class="keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )</span><br><span class="line">                &#123;</span><br><span class="line">                    isDone = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( hasTheLock )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ourPath;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">internalLockLoop</span><span class="params">(<span class="keyword">long</span> startMillis, Long millisToWait, String ourPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>     haveTheLock = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>     doDelete = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( revocable.get() != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ( (client.getState() == CuratorFrameworkState.STARTED) &amp;&amp; !haveTheLock )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取锁节点路径下的子节点,并且从小到大排序</span></span><br><span class="line">            List&lt;String&gt;        children = getSortedChildren();</span><br><span class="line">            <span class="comment">//本次需要获取的锁的节点 sequenceNodeName</span></span><br><span class="line">            String              sequenceNodeName = ourPath.substring(basePath.length() + <span class="number">1</span>); <span class="comment">// +1 to include the slash</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取锁</span></span><br><span class="line">            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);</span><br><span class="line">            <span class="keyword">if</span> ( predicateResults.getsTheLock() )</span><br><span class="line">            &#123;</span><br><span class="line">                haveTheLock = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//没有获取到锁 监听前一个node. 锁的实现是公平的，按照获取锁的顺序排列。所以只需要监听前一个node</span></span><br><span class="line">                <span class="comment">//变化 看是否被删除</span></span><br><span class="line">                String  previousSequencePath = basePath + <span class="string">"/"</span> + predicateResults.getPathToWatch();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="keyword">this</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">try</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</span></span><br><span class="line">                        client.getData().usingWatcher(watcher).forPath(previousSequencePath);</span><br><span class="line">                        <span class="keyword">if</span> ( millisToWait != <span class="keyword">null</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                            millisToWait -= (System.currentTimeMillis() - startMillis);</span><br><span class="line">                            startMillis = System.currentTimeMillis();</span><br><span class="line">                            <span class="keyword">if</span> ( millisToWait &lt;= <span class="number">0</span> )</span><br><span class="line">                            &#123;</span><br><span class="line">                                doDelete = <span class="keyword">true</span>;    <span class="comment">// timed out - delete our node</span></span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//在没有获取锁的时候，在规定的时间等待、如果监听到node节点变化则会 notify开始获取锁</span></span><br><span class="line">                            wait(millisToWait);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//死等 直到获取到锁</span></span><br><span class="line">                            wait();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> ( KeeperException.NoNodeException e )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// it has been deleted (i.e. lock released). Try to acquire again</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> ( Exception e )</span><br><span class="line">    &#123;</span><br><span class="line">        doDelete = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果处理异常了 则删除node放弃获取锁</span></span><br><span class="line">        <span class="keyword">if</span> ( doDelete )</span><br><span class="line">        &#123;</span><br><span class="line">            deleteOurPath(ourPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haveTheLock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StandardLockInternalsDriver<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">PredicateResults</span> <span class="title">getsTheLock</span>(<span class="title">CuratorFramework</span> <span class="title">client</span>, <span class="title">List</span>&lt;<span class="title">String</span>&gt; <span class="title">children</span>, <span class="title">String</span> <span class="title">sequenceNodeName</span>, <span class="title">int</span> <span class="title">maxLeases</span>) <span class="title">throws</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>             ourIndex = children.indexOf(sequenceNodeName);</span><br><span class="line">        validateOurIndex(sequenceNodeName, ourIndex);</span><br><span class="line">        <span class="comment">//这里的maxLease初始化是1 这个属性可以理解为临界资源默认是1 只允许一个。</span></span><br><span class="line">        <span class="comment">//只有ourIndex=0的时候成立。获取到锁</span></span><br><span class="line">        <span class="keyword">boolean</span>         getsTheLock = ourIndex &lt; maxLeases;</span><br><span class="line">        <span class="comment">//没有获取到锁的话 则返回前一个node的path</span></span><br><span class="line">        String          pathToWatch = getsTheLock ? <span class="keyword">null</span> : children.get(ourIndex - maxLeases);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PredicateResults(pathToWatch, getsTheLock);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="释放锁-InterProcessMutex-release"><a href="#释放锁-InterProcessMutex-release" class="headerlink" title="释放锁 InterProcessMutex.release"></a>释放锁 InterProcessMutex.release</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Perform one release of the mutex if the calling thread is the same thread that acquired it. If the</span></span><br><span class="line"><span class="comment"> * thread had made multiple calls to acquire, the mutex will still be held when this method returns.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception ZK errors, interruptions, current thread does not own the lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Note on concurrency: a given lockData instance</span></span><br><span class="line"><span class="comment">        can be only acted on by a single thread so locking isn't necessary</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    Thread currentThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取当前线程的锁数据</span></span><br><span class="line">    LockData lockData = threadData.get(currentThread);</span><br><span class="line">    <span class="keyword">if</span> ( lockData == <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"You do not own the lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//锁的数量减一</span></span><br><span class="line">    <span class="keyword">int</span> newLockCount = lockData.lockCount.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> ( newLockCount &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//重入锁 直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( newLockCount &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(<span class="string">"Lock count has gone negative for lock: "</span> + basePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用 LockInternals.releaseLock释放锁</span></span><br><span class="line">        internals.releaseLock(lockData.lockPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//删除锁的信息</span></span><br><span class="line">        threadData.remove(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">(String lockPath)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        revocable.set(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//直接删除node节点 释放锁</span></span><br><span class="line">        deleteOurPath(lockPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h5><ol>
<li><p>Curator的InterProcessMutex提供了多种锁机制，互斥锁，读写锁，以及可定时数的互斥锁。</p>
</li>
<li><p>所有申请锁都会创建临时顺序节点，保证了都能够有机会去获取锁。</p>
</li>
<li><p>内部用了线程的wait()和notifyAll()这种等待机制，可以及时的唤醒最渴望得到锁的线程。避免常规利用Thread.sleep()这种无用的间隔等待机制。</p>
</li>
<li><p>使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p>
</li>
<li><p>使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</p>
</li>
<li><p>使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</p>
</li>
<li><p>使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 分布式存储</title>
    <url>/2018/05/29/redis-store/</url>
    <content><![CDATA[<p>Redis 分布式路由中间件</p>
<p>入职公司不久、发现各种业务强依赖Redis以至于公司研发了Redis分布式存储路由中间件、经过一段时间的源码学习总结一下。</p>
<p>先来一张大的思维导图（PS:思维导图真的对我们理解总结很有帮助）</p>
<p><img src="/img/Redis分布式.png" alt></p>
<h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>Redis-Store是基于客户端的分布式存储路由中间件。本地从zookeeper配置中拉取和监听Redis配置信息、根据策略自动路由。</p>
<h5 id="节点类型设计"><a href="#节点类型设计" class="headerlink" title="节点类型设计"></a>节点类型设计</h5><p><img src="/img/zknode.jpg" alt></p>
<ul>
<li>Cluster:  集群名称（对应业务名称）、每一个业务是一个独立的Cluster结构。zk根节点是[/clusters]。</li>
<li>Node:     数据的逻辑分区、可以理解为分片。</li>
<li>Instance：实际的Redis实例、由一小组主从结构构成。</li>
</ul>
<h5 id="节点数据设计"><a href="#节点数据设计" class="headerlink" title="节点数据设计"></a>节点数据设计</h5><p><img src="/img/cluster.jpg" alt></p>
<h5 id="路由流程设计"><a href="#路由流程设计" class="headerlink" title="路由流程设计"></a>路由流程设计</h5><p><img src="/img/flow.jpg" alt></p>
<p>客户端请求的如何落到具体的实例上面。针对原有的Redis客户端、将所有的方法的第一个参数设置为hashKey、后续的处理的根据hash选择Node、根据读写策略获取Master实例还是Slave实例进行具体的读写。比如一个简单的场景，我们初始化了10个分片也就是10个Node节点，每个节点下面一主两从实例。配置Cluster的Hash策略为简单的取模运算。当我们以用户的Id为haskKey进行路由的话，根据用户Id的最后一位数字能确定我们的请求到具体哪个Node，在进行写入的操作的时候请求落到Master实例上面，在进行读操作的时候请求会落到Slave实例上面（当然这是简单的读写策略）。</p>
<p>上面流程中第一步是根据hashKey获取Node。也就是根据hash算法得到我们的请求应该分配到那个分片上面。这个根据不同的业务场景会有不同的设计、有简单的取模哈希、有适应分布式的一致性哈希、有区域哈希、有前缀哈希等等。不能说那种算法最好，使用适合自己业务的。</p>
<p>上面流程中第二步是根据读写策略获取具体的Instance了。一个Node下面是一个小的实例集群，根据自己的业务的需求可以自定义，一般的都是一主两从。如果是写入操作的话获取Master实例、如果是读操作的可以Master读、可以Slave读、可以随机读等等。</p>
<h5 id="集群节点变更设计"><a href="#集群节点变更设计" class="headerlink" title="集群节点变更设计"></a>集群节点变更设计</h5><p><img src="/img/rehash.jpg" alt></p>
<ul>
<li>集群信息变更两个阶段的提交ACK和FINISH</li>
<li>减少集群变更对数据一致性的影响</li>
<li>集群状态SYN REHASH NORMAL</li>
</ul>
<h5 id="扩容设计"><a href="#扩容设计" class="headerlink" title="扩容设计"></a>扩容设计</h5><ul>
<li>在业务设计的时候尽量预估好容量</li>
<li>如果使用一致性哈希算法直接添加节点</li>
<li>对于取模哈希或者区域哈希等其他的算法由于局限性可按倍扩容</li>
<li>扩容之后节点的旧数据需要人工处理删除</li>
</ul>
]]></content>
      <tags>
        <tag>Redis</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2018/04/10/mergeSort/</url>
    <content><![CDATA[<p>归并排序</p>
<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>  归并排序是分治法的运用、所谓分治法就是将一个大问题分成一个个小的具有相同性质的问题。在归并排序中对于一个无序数组我们可以将数组先从中间分成两个数组然后对这两个数组进行排序。排序好了之后再将这两个有序的数组合并在一起。这个时候对于两个数组的排序就可以复用我们刚才的思想。</p>
<h3 id="分的思想"><a href="#分的思想" class="headerlink" title="分的思想"></a>分的思想</h3><p><img src="/img/mergeSort-1.png" alt></p>
<h3 id="治的思想"><a href="#治的思想" class="headerlink" title="治的思想"></a>治的思想</h3><p><img src="/img/mergeSort-2.png" alt><br><img src="/img/mergeSort-3.png" alt></p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []arr = &#123;<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> []temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];<span class="comment">//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间</span></span><br><span class="line">        sort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> []temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            sort(arr,left,mid,temp);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">            sort(arr,mid+<span class="number">1</span>,right,temp);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">            merge(arr,left,mid,right,temp);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right,<span class="keyword">int</span>[] temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left;<span class="comment">//左序列指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;<span class="comment">//右序列指针</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//临时数组指针</span></span><br><span class="line">        <span class="keyword">while</span> (i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">                temp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">//将左边剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">//将右序列剩余元素填充进temp中</span></span><br><span class="line">            temp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将temp中的元素全部拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            arr[left++] = temp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  归并排序是一种稳定的排序、时间复杂度为O(nlogn)。在Java中我们常用Arrays.sort()内部使用的是TimeSort的排序方式。TimeSort是对归并排序的一种优化。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://bubkoo.com/2014/01/15/sort-algorithm/merge-sort/" target="_blank" rel="noopener">http://bubkoo.com/2014/01/15/sort-algorithm/merge-sort/</a></p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/p/6194356.html</a></p>
]]></content>
      <tags>
        <tag>Arithmetic</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux远程登录</title>
    <url>/2017/08/21/Linux%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>Linux 远程登录 免密码</p>
<h5 id="第一步-将本地的-id-rsa-pub-文件上传到远程服务器"><a href="#第一步-将本地的-id-rsa-pub-文件上传到远程服务器" class="headerlink" title="第一步 将本地的 id_rsa.pub 文件上传到远程服务器"></a>第一步 将本地的 id_rsa.pub 文件上传到远程服务器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scp /Users/LTY/.ssh/id_rsa.pub userName@Host:~/</span><br><span class="line"></span><br><span class="line">#输入密码 回车</span><br></pre></td></tr></table></figure>
<h5 id="第二步-登录远程服务器"><a href="#第二步-登录远程服务器" class="headerlink" title="第二步 登录远程服务器"></a>第二步 登录远程服务器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh usreName@Host</span><br><span class="line"></span><br><span class="line">#输入远程服务器密码 回车</span><br></pre></td></tr></table></figure>
<h5 id="第三步-生成秘钥-如果远程服务器存在-用户目录下存在-ssh-可以跳过"><a href="#第三步-生成秘钥-如果远程服务器存在-用户目录下存在-ssh-可以跳过" class="headerlink" title="第三步 生成秘钥(如果远程服务器存在 用户目录下存在.ssh 可以跳过)"></a>第三步 生成秘钥(如果远程服务器存在 用户目录下存在.ssh 可以跳过)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line">#一直回车</span><br></pre></td></tr></table></figure>
<h5 id="第四步-将第一步上传的本地秘钥复制到-ssh-authorized-keys"><a href="#第四步-将第一步上传的本地秘钥复制到-ssh-authorized-keys" class="headerlink" title="第四步 将第一步上传的本地秘钥复制到 .ssh/authorized_keys"></a>第四步 将第一步上传的本地秘钥复制到 .ssh/authorized_keys</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; .ssh/authorized_keys</span><br><span class="line"></span><br><span class="line">###如果 authorized_keys 文件不存在 新建一个</span><br></pre></td></tr></table></figure>
<h5 id="第五步-修改authorized-keys-文件权限-为600"><a href="#第五步-修改authorized-keys-文件权限-为600" class="headerlink" title="第五步 修改authorized_keys 文件权限 为600"></a>第五步 修改authorized_keys 文件权限 为600</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h5 id="第六步-删除你的本地-秘钥-然后退出服务器-再次登录"><a href="#第六步-删除你的本地-秘钥-然后退出服务器-再次登录" class="headerlink" title="第六步 删除你的本地 秘钥 然后退出服务器 再次登录"></a>第六步 删除你的本地 秘钥 然后退出服务器 再次登录</h5>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2017/08/21/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux 常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexdump -C binfile | less   查看二进制文件</span><br><span class="line">sudo tcpdump -i eth0 -Xlnps0 port 10000 抓包</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------查看文件---------</span><br><span class="line">ls -lt  查看目录中文件按照时间顺序排序</span><br><span class="line">ls -ltr 查看目录中文件按照时间顺序倒序排序</span><br><span class="line">ls -Slh 查看目录中文件按照大小排序</span><br><span class="line">ls -Slhr  查看目录中文件按照大小倒序排序</span><br><span class="line">df -lh  查看当前磁盘的使用情况</span><br><span class="line">du -sh  查看当前文件夹的大小</span><br><span class="line"></span><br><span class="line">----------解压---------</span><br><span class="line">ls -lt  查看目录中文件按照时间顺序排序</span><br><span class="line">tar -czvf fileName.tar dirName  tar压缩包</span><br><span class="line">tar -zxvf fileName.tar  tar解压</span><br><span class="line">jar xvf 解压jai包和war包</span><br><span class="line">jar tvf 查看jar包内容</span><br><span class="line">zipinfo -1  查看zip包中的文件</span><br><span class="line"></span><br><span class="line">scp usreName@Host:remoteDir localDir  从远程下载文件到本地</span><br><span class="line">scp localDir userName@Host:remoteDir  上传本地文件到远程</span><br><span class="line"></span><br><span class="line">----------JVM---------</span><br><span class="line">jmap -dump:format=b,,file=fileNaem.bin &lt;pid&gt;  导出java dump文件</span><br><span class="line">jstat -gcutil &lt;pid&gt; 1s  监控jvm gc情况</span><br><span class="line">jmap -heap &lt;pid&gt; 打印java heap情况</span><br><span class="line"></span><br><span class="line">----------VIM---------</span><br><span class="line">:set fileencoding 显示文件编码</span><br><span class="line">:set encoding=utf-8 设置文件编码</span><br><span class="line">:set number 显示行号</span><br><span class="line">:set nonumber 不显示行号</span><br><span class="line"></span><br><span class="line">---------MAC---------</span><br><span class="line">sudo spctl --master-disable MAC高版本允许任何来源安装</span><br><span class="line"></span><br><span class="line">---------LOG---------</span><br><span class="line">tail -f recommend.log | grep -Eo &quot;LHot-1500-[0-9]&#123;1,2&#125;&quot; 输出grep匹配内容</span><br><span class="line">cat /proc/63/status | grep &quot;Threads&quot; 查看进程63的线程数量</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet</title>
    <url>/2017/03/13/HashSet/</url>
    <content><![CDATA[<p>HashSet 源码解析</p>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><p>HashSet是一个实现非常简单的类，为什么这么说呢？因为它的实现基本都依赖于HashMap，可以先来看一下初始化的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span></span><br><span class="line"><span class="comment">   * default initial capacity (16) and load factor (0.75).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码就可以知道，HashSet依赖于HashMap的存储，HashSet是一个不允许重复数据放入集合，他的实现依赖于HashMap得key，把对象放入到key里面，按照HashMap的特性，Key是不允许重复的，那么依照这种特性，完全可以使用key去存储。</p>
<h2 id="2-操作"><a href="#2-操作" class="headerlink" title="2 操作"></a>2 操作</h2><p>按照上面说的思路来说，其实添加和删除，无非是对HashMap的key进行一个操作而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the specified element from this set if it is present.</span></span><br><span class="line"><span class="comment"> * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment"> * if this set contains such an element.  Returns &lt;tt&gt;true&lt;/tt&gt; if</span></span><br><span class="line"><span class="comment"> * this set contained the element (or equivalently, if this set</span></span><br><span class="line"><span class="comment"> * changed as a result of the call).  (This set will not contain the</span></span><br><span class="line"><span class="comment"> * element once the call returns.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> o object to be removed from this set, if present</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList</title>
    <url>/2017/03/13/LinkedList/</url>
    <content><![CDATA[<p>LinkedList 源码解析</p>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><p>LinkedList也实现了List接口，说明了也具备了插入和删除功能,基于链表，插入和删除比ArrayList快，但是随机访问能力差，这个基础数据结构已经说明了，不再重复。其次LinkedList具备了双端队列的功能，实现了Deque接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基本字段如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pointer to first node.</span></span><br><span class="line"><span class="comment">  * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">  *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Pointer to last node.</span></span><br><span class="line"><span class="comment">  * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment">  *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs an empty list.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>主要是通过两个节点来操作链表的，first节点和last节点。size用来存储当前节点的大小。</p>
<h2 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2 插入数据"></a>2 插入数据</h2><p>LinkedList 可以往链表前面和链表后面插入数据，这样也具备了双端队列的功能<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method is equivalent to &#123;<span class="doctag">@link</span> #add&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面两个方法演示了往链表的前和后插入节点，基本都很简单，跟书上数据结构的方式一样<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//节点f指向first节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">//新建一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">//first指向新节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果f节点是null，那么就把last节点指向新节点，</span></span><br><span class="line">    <span class="comment">//如果不是null那么f节点的prev节点指向了新节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links e as last element.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-随机访问数据"><a href="#3-随机访问数据" class="headerlink" title="3 随机访问数据"></a>3 随机访问数据</h2><p>下面代码是LinkedList随机访问节点的流程，这里做了个优化，查找的时候不是全部遍历节点，而是判断了下index的位置是上半部分还是下半部分。从这里可以看出来，链表的随机访问效率低下的地方，因为需要遍历节点，而不是跟顺序表一样，可以通过下标进行访问<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">    <span class="comment">//判断index是否小于size的50%，如果是那么从first节点开始遍历，否则从last开始遍历</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4 删除数据"></a>4 删除数据</h2><p>删除节点这里逻辑也非常清晰，跟普通的链表操作一致，从链表头部开始删除。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">    <span class="comment">//拿到f节点的对象</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">//拿到f节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">//置为空</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    把first节点置为next节点</span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList</title>
    <url>/2017/03/13/ArrayList/</url>
    <content><![CDATA[<p>ArrayList 源码解析</p>
<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1 初始化"></a>1 初始化</h2><p>ArrayList类定义，通过类定义可以分析出ArrayList具备了RandomAccess（支持随机访问）、Cloneable（可以被复制）、Serializable（序列化）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化类属性,DEFAULT_CAPACITY(默认容量大小)、EMPTY_ELEMENTDATA(用来置空数组的)、DEFAULTCAPACITY_EMPTY_ELEMENTDATA(初始化时候的数组，根据下面代码看来，初始化的时候elementData默认指向DEFAULTCAPACITY_EMPTY_ELEMENTDATA)、elementData(存放元素)、size(当前数组大小)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>ArrayList通过add方法来进行添加元素,<code>ensureCapacityInternal</code>这个方法比较复杂，稍后进行讲解，其实ArrayList底部还是数组，添加元素无非是给指定下标指向e到对象而已，然后size＋＋。从这里看来ArrayList是非线程安全的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看<code>ensureCapacityInternal</code>这个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//判断是不是空元素，如果是空就把minCapacity置为DEFAULT_CAPACITY和minCapacity中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//判断是否需要增加集合大小，如果minCapacity值大于elementData.length那么就调用grow方法</span></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来看看关键性的grow方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//获取到当前集合的大小</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//确定新集合的大小，是当前集合大小＋oldCapacity左移位运算类似除于2</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果最新集合大小如果比minCapacity小，那么增加的大小就用minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//如果newCapacity的值大于MAX_ARRAY_SIZE</span></span><br><span class="line">        <span class="comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8,那么调用hugeCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        <span class="comment">//原生方法进行数组复制</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最大值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法主要是当数组长度不够时，自动增长数组的长度，增长因子是当前长度的二分之一。也就是说增长后＝oldLength＋oldLength&gt;&gt;1</p>
<h4 id="添加元素到指定位置"><a href="#添加元素到指定位置" class="headerlink" title="添加元素到指定位置"></a>添加元素到指定位置</h4><p>添加元素到指定位置，这个方法效率比较低，需要进行对元素的大量移动操作<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否超过当前数组大小</span></span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//index开始的元素后移一位</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除某个位置的元素"><a href="#删除某个位置的元素" class="headerlink" title="删除某个位置的元素"></a>删除某个位置的元素</h4><p>基本跟add(int index, E element)这个方法没有太大区别，一个是数组向后移动，一个是向前移动<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="删除某个元素"><a href="#删除某个元素" class="headerlink" title="删除某个元素"></a>删除某个元素</h4><p>删除某个元素的时候，主要是根据equals方法去判断是否是同一个对象的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//移除null对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//主要是调用equals方法判断是否是同一个对象</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line"></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 <em>ArrayList</em> 中删除和添加都使用到了 <em>System.arraycopy</em> 这个方法。这个方法是一<br>个 <em>native</em> 的方法。如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  <span class="keyword">int</span>  srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Object dest, <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>@src — 这是源数组 @srcPos — 这是源数组中的起始位置 @dest — 这是目标数组 @destPos — 这是目标数据中的起始位置  @length — 这是一个要复制的数组元素的数目</p>
<p>比如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[] = &#123;<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">System.arraycopy(arr1,<span class="number">0</span>,arr2,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">arr2 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br></pre></td></tr></table></figure></p>
<p><em>System.arraycopy</em> 方法的实现使用C++实现的，实现原理就是直接操作内存地址操作。因为数组是一段连续的内存地址。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedHashMap</title>
    <url>/2017/03/13/LinkedHashMap/</url>
    <content><![CDATA[<p>LinkedHashMap 源码解析</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>众所周知HashMap里面元素是无序的，而LinkedHashMap说直接点就是元素有序的HashMap。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>LinkedHashMap的构造方法调用的父类HashMap的父类方法。然后新增了一个accessOrder这个参数。根据英文注释。当accessOrder为true时，元素按照访问顺序排列，为false的时候,元素按照插入顺序排列，默认值为false。我们后面会介绍这个参数的具体在哪里用到。</p>
<h2 id="如何做到有序"><a href="#如何做到有序" class="headerlink" title="如何做到有序"></a>如何做到有序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       Entry&lt;K,V&gt; before, after;</span><br><span class="line">       Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到集合中具体的元素对象Entry中多了两个成员变量before ， after。由名称就可以猜出来，每个元素具有指向前一个元素和后一个元素的引用，所以LinkedHashMap元素是用双向链表实现的，并且还有指向头元素和尾元素的引用。我们可以从LinkedHashMap的成员变量中看到，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>LinkedHashMap的没有复写父类的put方法（具体的put方法请看HashMap解析），而是直接调用父类的方法。但是复写了父类put方法中的几个子方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p); <span class="comment">//将添加的元素插入到末尾</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;(hash, key, value, next);</span><br><span class="line">    linkNodeLast(p); <span class="comment">//将添加的元素插入到末尾</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JDK1.8中对对解决hash冲突做的很全面，最开始遇到冲突是用链表的形式也就是Entry对象，当链表具有一定的长度后会转换成红黑树也就是TreeNode对象。上面代码中可以看到当我们添加完一个元素后会调用linkNodeList（）把元素插入到末尾。具体代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">        tail = p;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;ava</span><br></pre></td></tr></table></figure></p>
<p>由此我们可以知道，每当我们put一个元素的时候，会讲该元素插入到双向链表的末尾。遍历的时候会按照插入的顺序查找。</p>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>LinkedHashMap复写了父类的get方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)  <span class="comment">//访问顺序控制</span></span><br><span class="line">           afterNodeAccess(e);</span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>方法中我们可以看到具体的获取元素仍然是调用父类的getNode方法（具体解析请看HashMap）。当我们获取到元素后，判断accessOrder的值，也就是我们初始化的传入的值，如果为true。会调用afterNodeAccess方法。下面我们看这个方法干了什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                last = b;</span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = p;</span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码仔细看一下还是能看懂,把访问到的元素移动到链表的末尾。这样就可以做到根据访问的顺序排列。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>根据LinkedHashMap可以根据访问顺序排序这一特性，我们可以基于它实现LRU缓存。LRU（Last Recently Used）最近最少使用的缓存。每当我们获取元素的时候会将该元素移动到链表的末尾。当我们内存已满的时候，链表最前面的元素即就是长时间没有被访问的，然后就可以释放了。以此来做到LRU。</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2017/03/13/HashMap/</url>
    <content><![CDATA[<p>HashMap 源码解析</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HashMap 是一个集合对象，存储key-value类型的数据。内部主要使用哈希表的结构去实现。至于哈希表的的结构我们在此不做详细介绍，可自行脑补。下面的源码基于JDK1.8，由于进行了很多优化，代码会有点复杂。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ---------------- Fields -------------- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> * 保存元素的数组对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> * 集合中实际的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="comment">// 集合所能保存元素个数的最大值，当保存元素的个数超过这个值得时候，会进行扩容操作，一般threshold = tables.length * loadFactor 。其中length为tables的长度，默认为16</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> * 负载因子 默认是0.75，负载因子大小会影响到threshold的大小，0.75是对空间和时间的平衡选择，建议不要修改。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>
<h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>实际调用的putVal方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//首先判断table是否为空，如果为空则进行扩容操作。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//根据hash值与table取模得到桶的下标，获取值后赋值给p，并且判断是否为空。</span></span><br><span class="line">    <span class="comment">//如果为空说明当前位置没有值，既没有发现hash碰撞，新建一个Node插入即可。</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;   <span class="comment">//进入这里说明发生了hash碰撞</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//判断hash值和key是否相同，如果相同则直接覆盖就好了。</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;     </span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果key不相同，判断p是否是TreeNode对象（红黑树实现）。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树插入值</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//key不相同，也不是TreeNode对象（红黑树），说明就是普通的链表，然后会遍历链表。</span></span><br><span class="line">            <span class="comment">//并且用binCount 记录链表的长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果为空说明遍历到链表的末尾了，然后进行链表插入操作，然后退出循环</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//插入完之后判断一下链表的长度是否超过8，如果超过8则会将链表转换成红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                         <span class="comment">//转换红黑树（红黑树比较复杂，有兴趣的自己研究）</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在遍历的过程中，发现key值相同的话 直接覆盖。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不为空，表示遇到相同的key，则覆盖原来的值,并且直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//onlyIfAbsent这个变量表示是否改变原来的值，如果为true是不改变。false则改变，在HashMap中的put方法内部传入的false。</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//这个方法在HashMap中是个空方法，主要是给LinkedHashMap复写用来调用的，可以不用关注。</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断大小是否到了阀值。</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">     <span class="comment">//这个方法在HashMap中是个空方法，主要是给LinkedHashMap复写用来调用的，可以不用关注。</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>实际调用的getNode方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//判断table是否为空，以及根据hash值取得对应的Node对象，并且赋值给first。</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果hash和key都相同，则说明找到了直接返回first</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果key不相同，则在红黑树或者链表中查找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//在红黑树中查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//遍历链表查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hash方法"><a href="#hash方法" class="headerlink" title="hash方法"></a>hash方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们put或者get的时候都会通过hash方法获取key对应的哈希值。当key为空的时候直接返回0，这样后面就无需再判读key是否为空，按照正常的hash处理就可以了。当key不为空是首先调用key自己的hashCode方法然后在进行移位运算。至于为什么这样做是处于多方面的考虑，比如速度，功效，质量等。</p>
<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>这个方法是比较重要的方法，主要用来初始化和扩容HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果超过最大容量，则不扩容。</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有则扩充为原来的2倍。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算新的resize的阀门</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//把每个Node对象放入到新的tables中去</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                     <span class="comment">//没有hash碰撞的元素处理</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//红黑树元素处理</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// preserve order 链表元素处理 没怎么看懂</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedBlockingQueue</title>
    <url>/2017/03/13/LinkedBlockingQueue/</url>
    <content><![CDATA[<p>LinkedBlockingQueue 源码分析</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedBlockingQueue 是线程安全的阻塞队列。</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Linked list node class</span></span><br><span class="line"><span class="comment"> * 队列结点类型Node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * One of:</span></span><br><span class="line"><span class="comment">     * - the real successor Node</span></span><br><span class="line"><span class="comment">     * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">     * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span></span><br><span class="line"><span class="comment">//队列的的大小，初始化的时候设置，如果没有传入默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Current number of elements */</span></span><br><span class="line"><span class="comment">//队列中元素的个数，由于多线程访问修改，使用了线程安全的AtomicInteger类。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: head.item == null</span></span><br><span class="line"><span class="comment"> * 队列的头结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> * 队列的尾节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
<p>以下成员变量是锁的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="comment">//删除元素时候，要加的takeLock锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="comment">//获取元素是若队列为空，线程阻塞，直至notEmpty条件满足</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="comment">//插入元素时，要加putLock锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="comment">//插入时候，若队列已满，线程阻塞，直至notFull条件满足</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p><strong>ReentrantLock</strong> 是一个可重入的互斥锁对象。即就是同一时刻在多线程的环境下，只有一个线程能获得锁。但是多个线程都可以调用lock方法，只有一个会成功，其他的线程将会被阻塞，直达该锁被释放。<strong>可重入</strong> 的意思是说一个线程获取锁以后，在执行方法过程中需要再次获取当前锁，此时lock方法不会阻塞。可再次进入。（如需要对ReentrantLock的实现和深入了解，请看后续文章）。</p>
<p><strong>Condition</strong> 是竞态条件对象，和ReentrantLock绑定使用。提供了线程间的通信方式（类似信号量），使用基本上和Object的wait，notify相同。（如需要对Condition深入了解，请看后续文章）。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with the given (fixed) capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> capacity the capacity of this queue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> capacity&#125; is not greater</span></span><br><span class="line"><span class="comment"> *         than zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//初始化队列大小</span></span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    <span class="comment">//初始化链表</span></span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> LinkedBlockingQueue&#125; with a capacity of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认为Integer.MAX_VALUE 可认为无限大</span></span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><p>LinkedBlocking入队的方法有两种</p>
<ul>
<li>put（）方法，为阻塞方法，队列有空余的时候才能加入新的元素，否则一直阻塞</li>
<li>offer（）方法，为非阻塞方法，如果队列满了，立即返回或者等待一会而在返回，通过返回的ture或者false，标记本次本次入队操作是成功。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the tail of this queue, waiting if</span></span><br><span class="line"><span class="comment">     * necessary for space to become available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">        <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//新建入队结点</span></span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="comment">//获取入队锁，这里调用的lockInterruptibly（）方法，</span></span><br><span class="line">        <span class="comment">//而不是lock（）方法，是为了更友好。lock（）方法在没有成功获取到锁的的时</span></span><br><span class="line">        <span class="comment">//候会一直block，打死不回头。而lockInterruptibly（）方法在阻塞的时候</span></span><br><span class="line">        <span class="comment">//如果被中断，线程会被唤醒并且处理中断异常，选择是继续阻塞还是返回了。</span></span><br><span class="line">        <span class="comment">//（ ReentrantLock对象中还有tryLock()方法，这个方法是，不会阻塞马上返</span></span><br><span class="line">        <span class="comment">//回，拿到锁后就返回true否则返回false，比较潇洒。tryLock（time）方法是</span></span><br><span class="line">        <span class="comment">//拿不到锁的时候，会阻塞time时间，超时就返回false，比较友好。）</span></span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">             * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">             * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">             * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">             * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">             * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="comment">//如果容量满了 就一直阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入队操作（后面会讲到）</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">//队列的元素个数加一，并且返回队列元素个数（注意getAndIncrement返回的是旧值）</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">//如果链表没有满，则发出通知 ，唤醒一个等待入队的线程</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果入队之前队列是空的，那么现在可以唤醒一个等待出队的线程</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the tail of this queue, waiting if</span></span><br><span class="line"><span class="comment">     * necessary up to the specified wait time for space to become available.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful, or &#123;<span class="doctag">@code</span> false&#125; if</span></span><br><span class="line"><span class="comment">     *         the specified waiting time elapses before space is available</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//将时间转换成纳秒</span></span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        putLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">                <span class="comment">//容量满了 然后判断有没有传入等待时间</span></span><br><span class="line">                <span class="comment">//小于0的（即就是没有配置等待时间）不需要阻塞直接返回，失败</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//等待一定时间，返回0或者小于0的一个值</span></span><br><span class="line">                nanos = notFull.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            signalNotEmpty();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>入队的链表操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Links node at end of queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    <span class="comment">//其实相当于两步</span></span><br><span class="line">    <span class="comment">// last.next = node 将last的下个结点指向新结点</span></span><br><span class="line">    <span class="comment">// last = last.next 将last重新指向新节点</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><p>LinkedBlockingQueue的出队列的方式有两种</p>
<ul>
<li>take() 方法，阻塞方法，队列有元素的时候才能出队，否则一直阻塞。</li>
<li>poll() 方法，非阻塞方法，队列没有元素的时候，立即返回或者等待一定的时间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *可以对比着put方法来看。LinkedBlockingQueue的出队和入队是对称的。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       E x;</span><br><span class="line">       <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">       <span class="comment">//通过takeLock获取锁，并且支持线程中断</span></span><br><span class="line">       takeLock.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//当队列为空时，则让当前线程处于等待</span></span><br><span class="line">               notEmpty.await();</span><br><span class="line">           &#125;</span><br><span class="line">           x = dequeue();</span><br><span class="line">           <span class="comment">//队列元素个数完成原子化操作-1,可以看到count元素会</span></span><br><span class="line">           <span class="comment">//在插入元素的线程和获取元素的线程进行并发修改操作。</span></span><br><span class="line">           c = count.getAndDecrement();</span><br><span class="line">           <span class="comment">//当一个元素出队列之后，队列的大小依旧大于1时</span></span><br><span class="line">           <span class="comment">//当前线程会唤醒其他执行元素出队列的线程,让它们也</span></span><br><span class="line">           <span class="comment">//可以执行元素的获取</span></span><br><span class="line">           <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">               notEmpty.signal();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           takeLock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//当c==capaitcy时，即在获取当前元素之前，队列已经满了，</span></span><br><span class="line">       <span class="comment">//而此时获取元素之后，队列就会空出一个位置，故当前线程会</span></span><br><span class="line">       <span class="comment">//唤醒执行插入操作的线程通知其他中的一个可以进行插入操作。</span></span><br><span class="line">       <span class="keyword">if</span> (c == capacity)</span><br><span class="line">           signalNotFull();</span><br><span class="line">       <span class="keyword">return</span> x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//和offer方法几乎是一样的。注释就不写了。大家都能看懂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        E x = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">        takeLock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            takeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == capacity)</span><br><span class="line">            signalNotFull();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体的出队操作</span></span><br><span class="line"><span class="comment">//LinkedBlockingQueue队列中的head结点只是一个指向，具体的值是null的，队列中第一个元素是head-&gt;next</span></span><br><span class="line"><span class="comment">//出队操作就是将head指向head-&gt;next,然后将head-&gt;next的值设置为null</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;E&gt; h = head;</span><br><span class="line">        Node&lt;E&gt; first = h.next;</span><br><span class="line">        h.next = h; <span class="comment">// 帮助GC回收</span></span><br><span class="line">        head = first;</span><br><span class="line">        E x = first.item;</span><br><span class="line">        first.item = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们看了LinkedBlockingQueue的出队和入队操作。我们现在来对比一下。</p>
<h4 id="三种入队对比"><a href="#三种入队对比" class="headerlink" title="三种入队对比"></a>三种入队对比</h4><blockquote>
<ul>
<li>offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false—&gt;不阻塞</li>
<li>put(E e)：如果队列满了，一直阻塞，直到队列不满了或者线程被中断—&gt;阻塞</li>
<li><p>offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果队列已满，则进入等待，直到出现以下三种情况：—&gt;阻塞</p>
<p>1.被唤醒</p>
<p>2.等待时间超时</p>
<p>3.当前线程被中断</p>
</li>
</ul>
</blockquote>
<h4 id="三种出队对比"><a href="#三种出队对比" class="headerlink" title="三种出队对比"></a>三种出队对比</h4><blockquote>
<ul>
<li>take()：如果队列空了，一直阻塞，直到队列不为空或者线程被中断—&gt;阻塞</li>
<li>poll()：如果没有元素，直接返回null；如果有元素，出队—&gt;不阻塞</li>
<li><p>poll(long timeout, TimeUnit unit)：如果队列不空，出队；如果队列已空且已经超时，返回null；如果队列已空且时间未超时，则进入等待，直到出现以下三种情况：</p>
<p>1.被唤醒</p>
<p>2.等待时间超时</p>
<p>3.当前线程被中断</p>
</li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Callable Future</title>
    <url>/2017/01/05/callable/</url>
    <content><![CDATA[<p>Java Callable Future使用详解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//取消任务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">//任务是否取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//任务是否完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得任务结果</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">   <span class="comment">//获得任务结果，并指定一定时间内，如果unit时间没有返回，抛出异常</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;Java线程池中执行的任务的最小单位可以是实现Runnable接口的，也可以是Callable接口，二者唯一的不同就是Callable能返回任务执行的结果。而Runnable则不可以。Runnable接口执行的run方法，Callable接口执行的call方法。我们使用Callable的时候同时，需要配合Future使用，Future可以理解为一个任务的执行周期，比如是否执行完成，执行完成后的结果是什么，执行过程中的异常是什么，取消任务等等。下面我们看代码来理解这二者的配合使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">        <span class="comment">//工厂方法创建一个线程池</span></span><br><span class="line">       ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">       <span class="comment">//这里通过java8 表达式创建了一个Callable任务，并返回任务的Future对象</span></span><br><span class="line">       Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"task interrupted"</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//获取任务的值 这里返回123</span></span><br><span class="line">       future.get();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面的代码就是很简单的Callable和Future的配合使用。我们下面来看看源码走一下流程，加深印象。首先是submit方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">//这里将我们我们传入的Callable对象封装成RunnableFuture对象去执行</span></span><br><span class="line">     RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">     execute(ftask);</span><br><span class="line">     <span class="keyword">return</span> ftask;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里返回的FutureTask对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//将Callable复制给成员变量</span></span><br><span class="line">        <span class="keyword">this</span>.callable = callable;</span><br><span class="line">        <span class="comment">//设置任务的状态为新建</span></span><br><span class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面几步我们知道了，线程池在submit一个Callable的时候首先将Callable封装成了RunnableFuture对象，这个是一个接口，代码中我们可以看到使用的具体实现的FutureTask这个实现类。初始化的的时候设置任务需要具体执行的Callable以及设置了任务的状态为新建。下面的代码是任务的所有状态。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>; <span class="comment">//新建任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>; <span class="comment">//任务完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>; <span class="comment">//任务正常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>; <span class="comment">//任务异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>; <span class="comment">//任务取消</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; <span class="comment">//任务中断中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>; <span class="comment">//任务已中断</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;构建RunnableFuture对象后就去执行了，看对象的名字就知道该接口实现了Runnable接口，所以执行任务肯定是指行run方法，这里我们去看FutureTask的run方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先判断任务的状态是不是新建</span></span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里的callable是上面初始化的赋值过的，这里又赋值给v</span></span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//去执行具体的任务，并将结果放在临时result里面</span></span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">//如果抛异常了，这里会将异常封装 具体看后面</span></span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果正常执行完任务，设置结果 具体看后面</span></span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务正常执行情况</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//跟新任务状态为完成</span></span><br><span class="line">  <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">      <span class="comment">//将结果赋值给成员变量outcome</span></span><br><span class="line">      outcome = v;</span><br><span class="line">      <span class="comment">//更新状态为正常</span></span><br><span class="line">      UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">      finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//任务异常</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//更新任务状态为完成</span></span><br><span class="line">   <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">       <span class="comment">//将异常对象赋值给成员变量outcome</span></span><br><span class="line">       outcome = t;</span><br><span class="line">       <span class="comment">//更新任务状态为异常</span></span><br><span class="line">       UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></span><br><span class="line">       finishCompletion();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面就是执行任务的过程，流程很清晰，下面我们看FutureTask的get方法，获取任务的执行结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = state;</span><br><span class="line">  <span class="comment">//如果任务没有完成，则一直阻塞等待，直到任务完成</span></span><br><span class="line">  <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">      s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">  <span class="comment">//返回结果</span></span><br><span class="line">  <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//将结果赋值给x 这里可能是正常返回值，也可能是异常信息</span></span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="comment">//这里状态如果是正常的话直接将结果返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">//如果取消了任务就抛出取消异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="comment">//这里就是执行任务的时候有异常，线程池将异常封装成ExecutionException抛出。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;这样我们看了这个流程，应该会加深我们对Callable和Future的认识。</p>
]]></content>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>React 学习笔记</title>
    <url>/2016/12/19/React-learn/</url>
    <content><![CDATA[<p>学习官方文档的一些总结和笔记</p>
<h3 id="一-基础语法"><a href="#一-基础语法" class="headerlink" title="一 基础语法"></a>一 基础语法</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">      ReactDOM.render(</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>,</span></span><br><span class="line">        document.getElementById('root')</span><br><span class="line">      );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">      var names = ['react', 'javascript', 'html'];</span><br><span class="line">      ReactDOM.render(</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#123;</span><br><span class="line">          names.map(function (name) &#123;</span><br><span class="line"><span class="xml">            return <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line">        document.getElementById('root')</span><br><span class="line">      );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面就是简单的<code>JSX</code>语法。其实就是将<code>html</code>语法和和<code>JavaScript</code>语法混合在一起。解析器解析的时候遇见 <code>&lt;</code> 开头的就用html规则解析，遇到代码块 <code>{}</code> 就用<code>JavaScript</code> 规则解析。<code>React</code> 官方推荐我们使用<code>JSX</code>语法，只是推荐，我们也可以使用纯的<code>JavaScript</code>代码写也是可以的，代码如下，只是使用<code>JSX</code>语法，组件的结构和组件的关系看上去比较清楚。使用<code>JSX</code>的时候需要指定<code>type</code>为<code>text/babel</code>，详细的<code>JSX</code>语法可以参考官方文档 <code>https://facebook.github.io/react/docs/introducing-jsx.html</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--不使用JSX语法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"root"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">    class Hello extends React.Component &#123;</span><br><span class="line">      render() &#123;</span><br><span class="line">        return React.createElement('div', null, `Hello $&#123;this.props.toWhat&#125;`);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">      React.createElement(Hello, &#123;toWhat: 'World'&#125;, null),</span><br><span class="line">      document.getElementById('root')</span><br><span class="line">    );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="二-Component"><a href="#二-Component" class="headerlink" title="二 Component"></a>二 Component</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">     //通过React.createClass创建自定义组件</span><br><span class="line">      var HelloWord = React.createClass(&#123;</span><br><span class="line">        render: function() &#123;</span><br><span class="line">          //只能包含一个顶层标签</span><br><span class="line"><span class="xml">          return <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      ReactDOM.render(</span><br><span class="line">        //把组件渲染到页面中</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">HelloWord</span> <span class="attr">name</span>=<span class="string">"Word"</span> /&gt;</span>,</span></span><br><span class="line">        document.getElementById('root')</span><br><span class="line">      );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面就是一个<code>React</code>简单的组件。<code>HelloWord</code>是一个组件类，<font color="red">组件类的名称首字母必须大写</font>,自定义的组件必须通过<code>React.render</code>方法进行解析，在其他<code>html</code>标签中使用是没有效果的。<code>this.props</code> 是获取当前自定义组件的属性名称，获取对应的值就是加上对应的属性名称，比如<code>this.props.name</code> 。有一点例外就是 <code>this.props.children</code> 这个不是获取属性名称为children的值，它是获取组件里面的所有子节点对象。具体怎么使用可以查看官网的API <code>https://facebook.github.io/react/docs/react-api.html#react.children</code>我们使用组件属性的时候和普通的<code>html</code>标签没有什么区别。但是我们的属性可以指定任意类型。代码如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">      var data = 1106;</span><br><span class="line">      var CustomButton = React.createClass(&#123;</span><br><span class="line">        //设置属性的类型</span><br><span class="line">        propTypes: &#123;</span><br><span class="line">          title: React.PropTypes.string,</span><br><span class="line">        &#125;,</span><br><span class="line">        //设置属性的默认值</span><br><span class="line">        getDefaultProps : function () &#123;</span><br><span class="line">          return &#123;</span><br><span class="line">            title : 'Hello World'</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        render: function() &#123;</span><br><span class="line"><span class="xml">          return <span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      ReactDOM.render(</span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">CustomButton</span> <span class="attr">title</span>=<span class="string">&#123;data&#125;</span> /&gt;</span>,</span></span><br><span class="line">        document.getElementById('root')</span><br><span class="line">      );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码我们给自己的组件<code>CustomButton</code>类定义了<code>propTypes</code>,指定属性名称<code>title</code>的类型为<code>string</code>，然后我们传入一个<code>int</code>类型的值给<code>title</code>，这样我们的<code>console</code>会提醒你 <em>Warning: Failed propType: Invalid prop <code>title</code> of type <code>number</code> supplied to <code>CustomButton</code>, expected <code>string</code>.</em>  这样就验证了属性的类型，在着我们可以指定<code>React.PropTypes.string.isRequired</code>来要求我们<code>title</code>这个属性是必须的，没有值的话会报错。以此来达到一些限制。我们制定了属性的类型之后，也可以设置属性的默认值，通过<code>getDefaultProps</code> 去设置。更多的具体属性类型可以看官方文档 <code>https://facebook.github.io/react/docs/react-api.html#typechecking-with-proptypes</code></p>
<h3 id="三-Component-State"><a href="#三-Component-State" class="headerlink" title="三 Component State"></a>三 Component State</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">    var CustomButton = React.createClass(&#123;</span><br><span class="line">      //初始化myKey状态的值</span><br><span class="line">      getInitialState: function() &#123;</span><br><span class="line">        return &#123;myKey: false&#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      //定义组件的点击事件</span><br><span class="line">      handleClick: function(event) &#123;</span><br><span class="line">        //设置状态liked的值</span><br><span class="line">        this.setState(&#123;myKey: !this.state.myKey&#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      render: function() &#123;</span><br><span class="line">        var text = this.state.myKey ? 'myKey' : 'haven\'t myKey';</span><br><span class="line">        return (</span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line">            You &#123;text&#125; this. Click to toggle.</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">CustomButton</span> /&gt;</span>,</span></span><br><span class="line">      document.getElementById('root')</span><br><span class="line">    );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码就是一个简单的组件状态的用法。在点击文本的时候设置不同的状态值进而渲染出不同的内容。只要执行<code>setState</code>的时候<code>React</code>会去重新计算<code>DOM</code>，渲染变化的值。除非在<code>shouldComponentUpdate</code>方法中返回<code>false</code>，个人觉得React最好的地方就是这个状态的转换，用户之间的交互更加流畅。<font color="red">还有就是<code>setState</code>是异步的，<code>this.setState</code>会调用<code>render</code>方法，但并不会立即改变<code>state</code>的值，<code>state</code>是在render方法中赋值的。所以执行this.setState()后立即获取state的值是不变的。同样的直接赋值<code>state</code>并不会出发更新，因为没有调用render函数。</font>还有就是关于定义组件事件的，<font color="red">React中绑定事件处理器是使用驼峰命名法的方式。</font></p>
<h3 id="四-Component-Form"><a href="#四-Component-Form" class="headerlink" title="四 Component Form"></a>四 Component Form</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">    //自定义组件也可以继承React.Component</span><br><span class="line">    class NameForm extends React.Component &#123;</span><br><span class="line">      constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        //构造方法初始化状态值</span><br><span class="line">        this.state = &#123;value: ''&#125;;</span><br><span class="line">        //绑定事件的回调函数，这里是必须的。不然运行的时候会undefined</span><br><span class="line">        this.handleChange = this.handleChange.bind(this);</span><br><span class="line">        this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">      &#125;</span><br><span class="line">      //定义组件事件</span><br><span class="line">      handleChange(event) &#123;</span><br><span class="line">        this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      //定义组件事件</span><br><span class="line">      handleSubmit(event) &#123;</span><br><span class="line">        alert('A name was submitted: ' + this.state.value);</span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line">              Name:</span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">NameForm</span> /&gt;</span>,</span></span><br><span class="line">      document.getElementById('root')</span><br><span class="line">    );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码是<code>React</code>处理表单，<code>React</code>认为表单的数据变化是用户和组件的一种交互，随着用户的输入，属性值是变化的，所以我们不能简单的用<code>this.props</code>去获取表单的值，因为<code>this.props</code>的值定义好了之后是不能变化的，而<code>React</code>做法是注册一个<code>onChange</code>事件的回调函数，通过实时的改变状态的值，进而获取和设置表单的值。而且 <code>textarea tags</code> 和 <code>select tag</code> 也是这种情况。具体可以参考官方文档 <code>https://facebook.github.io/react/docs/forms.html</code></p>
<h3 id="五-Component-Lifecycle"><a href="#五-Component-Lifecycle" class="headerlink" title="五 Component Lifecycle"></a>五 Component Lifecycle</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">    var HelloLifecycle = React.createClass(</span><br><span class="line">    &#123;</span><br><span class="line">          //初始化属性默认值,只调用一次，实例之间共享引用</span><br><span class="line">          getDefaultProps:function() &#123;</span><br><span class="line">              console.log('getDefaultProps,1');</span><br><span class="line">              return &#123;</span><br><span class="line">                  name1 : 'name1',</span><br><span class="line">                  name2 : 'name2'</span><br><span class="line">              &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">          // 初始化每个实例特有的状态</span><br><span class="line">          getInitialState:function() &#123;</span><br><span class="line">              console.log('getInitialState,2');</span><br><span class="line">              return null;</span><br><span class="line">          &#125;,</span><br><span class="line">          //组件渲染之前调用</span><br><span class="line">          componentWillMount:function() &#123;</span><br><span class="line">              console.log('componentWillMount,3');</span><br><span class="line">          &#125;,</span><br><span class="line">          //只能访问this.props和this.state,只有一个顶层组件，不允许修改状态和DOM输出</span><br><span class="line">          render: function() &#123;</span><br><span class="line">              console.log('component render 4');</span><br><span class="line"><span class="xml">              return <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello ,&#123;this.props.name1 + " " + this.props.name2&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          //成功render并渲染完成真实DOM之后触发，可以修改DOM</span><br><span class="line">          componentDidMount:function() &#123;</span><br><span class="line">              console.log('componentDidMount,5');</span><br><span class="line">          &#125;,</span><br><span class="line"></span><br><span class="line">          //运行中的函数</span><br><span class="line">          //父组件修改属性触发，可以修改新属性、修改状态</span><br><span class="line">          //obj为接收到修改了属性的对象，对象包含了修改后的属性在里边</span><br><span class="line">          componentWillReceiveProps:function(obj) &#123;</span><br><span class="line">              console.log("运行中：1");</span><br><span class="line">              console.log(obj);</span><br><span class="line">          &#125;,</span><br><span class="line">          //组件判断是否重新渲染时调用</span><br><span class="line">          shouldComponentUpdate: function() &#123;</span><br><span class="line">              console.log("运行中：2");</span><br><span class="line">              return true;</span><br><span class="line">          &#125;,</span><br><span class="line">          //组件更新前调用，不能修改属性和状态</span><br><span class="line">          componentWillUpdate: function() &#123;</span><br><span class="line">              console.log("运行中：3");</span><br><span class="line"></span><br><span class="line">          &#125;,</span><br><span class="line">          //组件更新后调用</span><br><span class="line">          //可以修改DOM</span><br><span class="line">          componentDidUpdate:function() &#123;</span><br><span class="line">              console.log("运行中：5");</span><br><span class="line">          &#125;,</span><br><span class="line">          //销毁阶段，即把这个组件移出后执行的回调函数</span><br><span class="line">          //在删除组件之前进行清理操作，比如计时器和事件监听器</span><br><span class="line">          componentWillUnmount: function() &#123;</span><br><span class="line">              alert('销毁，我是组件');</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">HelloLifecycle</span> /&gt;</span>,</span></span><br><span class="line">      document.getElementById('root')</span><br><span class="line">    );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行上面的代码可以看到<code>console</code>打印出了了</p>
<ol>
<li>getDefaultProps,1</li>
<li>getInitialState,2</li>
<li>componentWillMount,3</li>
<li>component render,4</li>
<li>componentDidMount,5</li>
</ol>
<p>这个是初始化时候的生命周期。运行时候的生命周期主要就是两部分 <code>update</code> <code>Unmount</code>,分别有组件更新前，组件更新后，组件销毁前，组件销毁后。其实总的来说分三种</p>
<ol>
<li>Mounting  加载组件</li>
<li>Updating  重新记载组件</li>
<li>Unmounting  移除组件</li>
</ol>
<p>针对这三种状态，<code>React</code>每种状态设置了<code>will</code>和<code>did</code>回调函数。分别代表前和后。具体的生命周期内容可以参考官方文档 <code>https://facebook.github.io/react/docs/react-component.html</code></p>
<h3 id="六-Refs-and-the-DOM"><a href="#六-Refs-and-the-DOM" class="headerlink" title="六 Refs and the DOM"></a>六 Refs and the DOM</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span></span><br><span class="line">    class CustomTextInput extends React.Component &#123;</span><br><span class="line">      constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        //绑定focus回调函数</span><br><span class="line">        this.focus = this.focus.bind(this);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      focus() &#123;</span><br><span class="line">        // 获取输入框的焦点</span><br><span class="line">        this.textInput.focus();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        return (</span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line">            &lt;input</span><br><span class="line">              type="text"</span><br><span class="line">              ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">            &lt;input</span><br><span class="line">              type="button"</span><br><span class="line">              value="Focus the text input"</span><br><span class="line">              onClick=&#123;this.focus&#125;</span><br><span class="line">            /&gt;</span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ReactDOM.render(</span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">CustomTextInput</span> /&gt;</span>,</span></span><br><span class="line">      document.getElementById('root')</span><br><span class="line">    );</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>React</code>中是基于数据流的，<code>props</code>是父组件和子组件交互的唯一方式，但是在某些情况下，我们需要在数据流之外强制修改子组件，子组件可以使<code>React</code>的实例，也可以是<code>DOM</code>元素。针对这种情况，可以使用<code>refs</code>属性。当组件装载的时候，<code>React</code>将会使用真实的<code>DOM</code>元素调用<code>ref</code>回调函数，当组件卸载的时候，会用<code>null</code>对象来回调，在上面的代码中，<code>CustomTextInput</code>组件装载后，<code>React</code>会调用<code>ref</code>的回调函数，将真实的<code>input</code>元素，复制给组件里面的<code>textInput</code>。当我们点击<code>button</code>的时候，调用<code>focus</code>回调，获取输入框的焦点。其实<code>React</code>也可以通过<code>this.refs.myRefName</code>来获取真实的<code>DOM</code>对象，官方建议我们使用事件回调的给属性赋值的方式，因为<code>this.refs.myRefName</code>必须在组件加载好了之后才能获取到真实的<code>DOM</code>，为了使用更加的友好，应该抛弃这种方式。再者&lt;/font color=’red’&gt;不可以在自定义的组件中使用ref属性，因为组件是没有具体的实例的&lt;/font&gt;</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><code>React</code>是基于状态驱使的。在整个<code>React</code>开发中，体会到，组件的状态贯穿着一切，一切都是基于状态驱使开发的。</li>
<li>仅仅只要表达出应用程序在任一个时间点应该长的样子，然后当底层的数据变了，<code>React</code>会自动处理所有用户界面的更新。</li>
<li><code>React</code>中数据流是单向的，从父节点传递到子节点，因而组件是简单且易于把握的，组件只需要从父节点获取<code>props</code>渲染即可。如果顶层组件的某   个<code>prop</code>改变了，<code>React</code>会递归地向下遍历整棵组件树，重新渲染所有使用这个属性的组件。</li>
<li>可以通过 <code>this.props</code> 来访问组件的 <code>props</code> ，但不能通过这种方式修改它，一个组件绝对不可以自己修改自己的 <code>props</code> 。 <code>props</code> 可以是字符串，对象，事件处理器等。可以使用 <code>PropTypes</code> 来验证 <code>props</code> 的类型，推荐使用。</li>
<li>每一个<code>React</code>组件都可以拥有自己的<code>state</code>，其与<code>props</code>的区别是，<code>state</code>只存在于组件内部,<code>state</code> 的值应该通过 <code>this.setState()</code>修改，只要该状态被修改， <code>render</code> 方法就会被调用，然后导致之后的一系列变化。状态总是让组件变得更加复杂，把状态针对不同的组件独立开来，能更有利于调试。</li>
</ol>
]]></content>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>一年之痒</title>
    <url>/2016/12/01/zongjie-1/</url>
    <content><![CDATA[<p>说说我来北京的一年</p>
<p>&emsp;&emsp;小洋生于甲戌年辛未月甲午日，属木狗之命。至于是那个时辰我也不知道，得要问我爷爷他们了。一生顺风顺水没有什么大风大浪，大四一开始，大家都陆陆续续的都出去实习，小洋也没有什么规划，没有什么想法，去年七月底就来到了帝都。开始了传说中的北漂之旅。比一些人幸运的是，小洋有学长的招待，不至于一开始就睡大街。有了安顿之地，然后开始疯狂的投简历，面试，投简历，面试。可结果并不是很理想，面对北京这个IT人才满大街的地方，自己简直就是可有可无的存在。没有好的学历，没有突出的技术能力，再加上互联网寒冬，小洋一度想要放弃。后来几经周转去了创新工场的一家创业公司 盒子鱼 ，是面对初高中的在线英语教育的。长那么大也是第一次进入公司，进入社会。小洋体验完第一天上班后，已经不想在去了，气氛压抑，办事效率低下，对自己不看重，这些让小洋心灰意冷，虽然是实习，不能抱怨这抱怨那的，但是小洋待着不开心，这就不行。也许是年轻，刚入职就开始筹备的着下一家。一边上着班一边寻找着机会。一次偶然的机会我去参加了e代驾的现场宣讲和招聘会，经过一番笔试和面试，小洋有幸进入了一个核心的部门。心里有了着落就在盒子鱼干了一个月，就请假回学校了。之后就没有之后了。离职了。</p>
<p>&emsp;&emsp;回到学校呆了一周，处理了一些琐碎的小事之后，去年九月初就直接去e代驾上班了。入职第一天就满满的都是感动，leader亲自给我讲解项目代码，问我以后想做哪方面的东西，之后中午带着我去大吃了一顿，认识了当时团队的人员，大家都很有趣。下午的时候leader让一个妹子给我讲解了公司办公需要的账号，给我开通各种权限。真的效率很高。基本上没要几天小洋就熟悉了公司的流程和项目的一些事情。后来每周定期老大还有技术培训，分分钟捕获小洋的心。小洋这里主要是做Android开发的。就这样开开心心的实习、上班。但是好景不长，去年十一月初由于公司原因，内部开始裁员了。然后就拥抱变化。公司给了一个月时间，这一个月可以不用上班，去面试找工作。工资照发。其实就相当给了一个月的补助。毕竟在公司呆的很开心，也没有什么抱怨的，倒是有点舍不得。就这样我又开始了大规模的面试，那个时候雪下的很大，真的是寒冬了。不经一番寒彻骨，怎得梅花扑鼻香嘛。小洋都冻的不行了。一周的奔波下来，最后于去年十一月三十号入职了饿了么，主要做Java研发。</p>
<p>&emsp;&emsp;从去年十一月三十号到昨天，刚刚好一年的时间。小洋在大学里面Android和Java服务端开发都接触过，也做过一些外包项目。所以实习的时候还不确定自己想做什么。不过进入饿了么之后就想好了，以后还是走Java服务端吧。饿了么算是一个比较大一点的公司，可是小洋入职的是北京研发中心，刚刚组建不久，上班的时间和任务都比较轻松。比较自由。不过制度，代码，上线，管理什么还是很正规的，在饿了么的这一年里面说实话没有做什么复杂的项目，倒是由于开发自由，学习了不少东西。学习了公司的SOA框架，了解了Rpc的原理以及微服务的一些概念，这个算是我最大的收获吧。小洋的项目架构师使用一个比较新的数据库持久化框架 JOOQ，又多学习了一些技术。还有就是对Spring、Maven、Git等技术有了加深。总之有得有失，但是得大于失。希望小洋能不断努力，时刻保持一颗学习的心。</p>
<p>&emsp;&emsp;来北京的一年，没有太大的感受，因为没有什么变化很大的事情，也许小洋的命运就这样，一生没有大风大浪，安安静静。小洋没有多么大的技术追求，只是每天学习一点，小洋没有多大的生活的追求，只是每天知足常乐。古人闲来垂钓碧溪上，小洋不会钓鱼，只会看看书，写写字。这样、挺好。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql杂谈</title>
    <url>/2016/11/19/MySql%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>MySQL 闲杂知识点</p>
<h2 id="1-MySQL-concat"><a href="#1-MySQL-concat" class="headerlink" title="1. MySQL concat"></a>1. MySQL concat</h2><p>我们使用MySQL中的concat链接字符串函数的时候，如果链接的字段中有一个NULL值的话，我们最后出来的结果就是NULL，显然这不是我们想要的。我们可以使用coalesce函数来对NULL值初始化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`atfcapi`</span>.<span class="string">`tb_api_trace`</span>.<span class="string">`git_version`</span>,</span><br><span class="line">       <span class="keyword">concat</span>(<span class="string">'Request: '</span>,<span class="keyword">coalesce</span>(<span class="string">`atfcapi`</span>.<span class="string">`tb_api_trace`</span>.<span class="string">`parameters_change_list`</span>,<span class="string">''</span>),<span class="string">'\nResponse: '</span>,<span class="keyword">coalesce</span>(<span class="string">`atfcapi`</span>.<span class="string">`tb_api_trace`</span>.<span class="string">`responses_change_list`</span>,<span class="string">''</span>)) <span class="keyword">AS</span> <span class="string">`change`</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`atfcapi`</span>.<span class="string">`tb_api_trace`</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="string">`atfcapi`</span>.<span class="string">`tb_api_trace`</span>.<span class="string">`tb_pathid`</span> = <span class="number">4217</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">`atfcapi`</span>.<span class="string">`tb_api_trace`</span>.<span class="string">`updated_at`</span> <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>
<p>具体可以参考 <a href="http://stackoverflow.com/questions/8530632/concat-values-in-mysql-queryto-handle-null-values" target="_blank" rel="noopener">http://stackoverflow.com/questions/8530632/concat-values-in-mysql-queryto-handle-null-values</a></p>
<h2 id="2-MySQL-查询当天数据"><a href="#2-MySQL-查询当天数据" class="headerlink" title="2. MySQL 查询当天数据"></a>2. MySQL 查询当天数据</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">date</span>(<span class="built_in">TIME</span>) = <span class="keyword">curdate</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(<span class="built_in">TIME</span>) = <span class="keyword">TO_DAYS</span>(<span class="keyword">NOW</span>())</span><br></pre></td></tr></table></figure>
<h2 id="3-MySQL-count-count-1-count-列名"><a href="#3-MySQL-count-count-1-count-列名" class="headerlink" title="3. MySQL count(*) count(1) count([列名])"></a>3. MySQL count(*) count(1) count([列名])</h2><p>Count(1)和Count(*)实际上的意思是，评估Count（）中的表达式是否为NULL，如果为NULL则不计数，而非NULL则会计数。比如我们看如下代码所示，在Count中指定NULL（优化器不允许显式指定NULL，因此需要赋值给变量才能指定）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> @x3x <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">SET</span> @x3x=<span class="literal">NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(@x3x) <span class="keyword">FROM</span> TableName</span><br></pre></td></tr></table></figure>
<p>因此当你指定Count(*） 或者Count（1）或者无论Count(‘anything’)时结果都会一样，因为这些值都不为NULL。对于Count（列）来说，同样适用于上面规则，评估列中每一行的值是否为NULL，如果为NULL则不计数，不为NULL则计数。因此Count（列）会计算列或这列的组合不为空的计数。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm Classloader</title>
    <url>/2016/11/16/Jvm-Classloader/</url>
    <content><![CDATA[<p>Java 类加载机制</p>
<h3 id="说在前面的话"><a href="#说在前面的话" class="headerlink" title="说在前面的话"></a>说在前面的话</h3><p>JVM的相关知识很多,其实主要我们在平时接触到就三个部分一个是内存模型，一个是类加载，在一个就是垃圾回收，要看具体的内容可以去看《深入理解Java虚拟机》这本书,慢慢品味会有不少的收获，记得自己刚开始面试那会前面几章看了好多遍，奈何当时只是应付面试,里面好多东西都不是很理解,现在在来复习一下说说自己的见解。</p>
<p>谈到Java的类加载机制，首先我们要知道类加载到底加载的是什么，其实好多人看网上的文章说的什么双亲委派模型啊，一些基础的都没有说明白。<strong>Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能。</strong> 这是比较官方的说法，我的理解是这样的，Java中我们可以对一切相同属性的东西抽象一个父类。比如宝马，奔驰，奥迪，他们都有四个轮子，有发动机等等，我们就可以抽象出一个汽车类。在Java中，进行装载的是一系列class文件，这些class文件都有构造函数，成员属性，成员方法等，所以Java就将这些抽象出来了Class对象。<strong>一个class文件进行加载了之后，只会有一个Class对象，之后再次加载的时候，会去检查是否加载了。</strong></p>
<p>上面说完了类加载加载的是什么东西，在说说Java类加载的一个流程，<strong>虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong> 这些过程具体讲起来就很多了，本文就不做过多的详述了，具体大家去看看书本的知识。</p>
<h3 id="Java类加载的双亲委派模型"><a href="#Java类加载的双亲委派模型" class="headerlink" title="Java类加载的双亲委派模型"></a>Java类加载的双亲委派模型</h3><blockquote>
<ol>
<li><strong>Bootstrap ClassLoader</strong>。将存放于<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用</java_home></li>
<li><strong>Extension ClassLoader</strong> : 将<java_home>\lib\ext目录下的，或者被java.ext.dirs系统变量所指定的路径中的所有类库加载。开发者可以直接使用扩展类加载器。     </java_home></li>
<li><strong> Application ClassLoader</strong> : 负责加载用户类路径(ClassPath)上所指定的类库,开发者可直接使用。</li>
</ol>
</blockquote>
<p>上面是Java里面的三个类加载器。从上到下分别是由父到子。其中Bootstrap ClassLoader是由C++编写的。我们在Java代码中是看不到的。</p>
<p>如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。这就是Java的双亲委派模型。要理解这个模型我们可以去看ClassLoader这个类，其实又回到了刚开始的抽象，Java中三个类加载器可以抽象出来一个对象。我们可以去看这个这对象的源码查看到相关的原理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java.lang.ClassLoader</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//我看的Java8的代码，这里给改成了同步代码块，以前的版本是同步方法</span></span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            <span class="comment">//检查是否被加载了，验证了一个类的Class对象永远只用一个</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//交给父类去加载</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果没有父类就交给BootstrapClass去加载</span></span><br><span class="line">                        <span class="comment">//这个方法是Native的方法。</span></span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    <span class="comment">//上面父类如果没有找到则交给你自己去加载。</span></span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的双亲委派模型我们看代码已经很清楚了，再来看看AppClassLoader和ExClassLoader。这两个类在sun.misc.Launcher类中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.misc.Launcher类部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Launcher.ExtClassLoader var1;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//初始化ExtClassLoader</span></span><br><span class="line">            var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//初始化AppClassLoader，并且将ExtClassLoader传入，作为父加载器</span></span><br><span class="line">            <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ExtClassLoader是Launcher的静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//这里指定了ExtClassLoader加载的类路径，</span></span><br><span class="line">            <span class="keyword">final</span> File[] var0 = getExtDirs();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction() &#123;</span><br><span class="line">                    <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var2 = <span class="number">0</span>; var2 &lt; var1; ++var2) &#123;</span><br><span class="line">                            MetaIndex.registerDirectory(var0[var2]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//返回具体的ExtClassLoader对象，看下面构造方法</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var0);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException var2) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException)var2.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">            <span class="comment">//这里是java扩展包路径。</span></span><br><span class="line">            String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">            File[] var1;</span><br><span class="line">            <span class="keyword">if</span>(var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">                <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">                var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">                    var1[var4] = <span class="keyword">new</span> File(var2.nextToken());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                var1 = <span class="keyword">new</span> File[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ExtClassLoader</span><span class="params">(File[] var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//这里的第二参数是父加载器，这里是null。在Java里面，ExtClassLoader</span></span><br><span class="line">            <span class="comment">//是没有父加载器。我们在看ClassLoader的源码的时候，当没有父类加载器的时候</span></span><br><span class="line">            <span class="comment">//交给Bootstrap去加载的。所以我们可以认为ExtClassLoader的父类加载器是Bootstrap</span></span><br><span class="line">            <span class="keyword">super</span>(getExtURLs(var1), (ClassLoader)<span class="keyword">null</span>, Launcher.factory);</span><br><span class="line">            SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>).initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .....</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">      <span class="comment">//AppClassLoader也是Launcher的静态内部类</span></span><br><span class="line">      <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> URLClassPath ucp = SharedSecrets.getJavaNetAccess().getURLClassPath(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="comment">//这里指定了类加载加载class文件目录。这里说明了AppClassLoader是加载classath下面的jar包。</span></span><br><span class="line">            <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">            <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span>?<span class="keyword">new</span> File[<span class="number">0</span>]:Launcher.getClassPath(var1);</span><br><span class="line">            <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    URL[] var1x = var1 == <span class="keyword">null</span>?<span class="keyword">new</span> URL[<span class="number">0</span>]:Launcher.pathToURLs(var2);</span><br><span class="line">                    <span class="comment">//这里返回具体的AppClassLoader对象，看下面构造方法</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        AppClassLoader(URL[] var1, ClassLoader var2) &#123;</span><br><span class="line">            <span class="comment">//这里的第二个参数是指定父类加载器，我们最开始看见的传入的是ExtClassLoader</span></span><br><span class="line">            <span class="keyword">super</span>(var1, var2, Launcher.factory);</span><br><span class="line">            <span class="keyword">this</span>.ucp.initLookupCache(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ....</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>上面我们看到了Java类加载器的初始化，Lanuncher类是rt.jar包中的类，在lib目录下，启动的时候就会加载初始化。由于BootstrapClassLoader是C++编写，我们在Java中是看到不的，由此Java的类加载器初始化完了，然后就可以去加载自己对应目录的下的class文件了。在这里大家可能又一个疑问。Java中的类加载器都是继承ClassLoader的，那ClassLoader是由什么加载的呢。其实ClassLoader对象和Class对象一样，他们的初始化是由Native方法去初始化的，Java层面我们是看不到的。由于我没有看C++代码对此也不敢乱下结论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么要用双亲委派模型"><a href="#为什么要用双亲委派模型" class="headerlink" title="为什么要用双亲委派模型"></a>为什么要用双亲委派模型</h3><p>因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。</p>
<p>这里推荐一篇博客写的很好 <a href="http://blog.csdn.net/xyang81/article/details/7292380" target="_blank" rel="noopener">http://blog.csdn.net/xyang81/article/details/7292380</a></p>
]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>Classloader</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring MVC Exception</title>
    <url>/2016/11/14/Spring-MVC-Exception/</url>
    <content><![CDATA[<p>Spring MVC 全局异常处理</p>
<p>&emsp;&emsp;当我们用Sping MVC的时候,可以对Controller层的接口进行全局异常处理。那样就不用每个接口try catch了。只需要继承这个类就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> Log LOGGER = LogFactory.getLog(BaseExceptionHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(NoHandlerFoundException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">NOT_FOUND</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handle404Error</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Throwable</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        LOGGER.error(<span class="string">"@NoHandlerFound Path [&#123;&#125;]  &#123;&#125;"</span>,request.getRequestURI(),e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="string">"400"</span>,e.getMessage(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(ServerException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span> <span class="title">handleError</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>,<span class="title">Throwable</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        LOGGER.error(<span class="string">"@Controller Path [&#123;&#125;]  Method [&#123;&#125;]"</span>,request.getRequestURI(),request.getMethod());</span><br><span class="line">        LOGGER.error(<span class="string">"@Error - "</span>,e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="string">"4001"</span>,<span class="string">"处理错误 | 错误原因 "</span>+e.getMessage(),<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(value = &#123;MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>, <span class="title">BindException</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">ResponseEntity</span> <span class="title">handleMethodArgumentNotValidException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>) </span>&#123;</span><br><span class="line">        String message = <span class="string">"参数异常,"</span>;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">            MethodArgumentNotValidException exception = (MethodArgumentNotValidException) e;</span><br><span class="line">            message = message + exception.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">            BindException exception = (BindException) e;</span><br><span class="line">            message = message + exception.getBindingResult().getFieldError().getDefaultMessage();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.error(<span class="string">"Controller Check Argument ErrorMsg:[&#123;&#125;] Path:[&#123;&#125;]"</span>, message, request.getRequestURI());</span><br><span class="line">        LOGGER.error(<span class="string">"Controller Check Argument Error - "</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="string">"4001"</span>, message, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">INTERNAL_SERVER_ERROR</span>)</span></span><br><span class="line"><span class="class">    <span class="title">ResponseEntity</span> <span class="title">handleControllerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Throwable</span> <span class="title">th</span>) </span>&#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Controller Path:[&#123;&#125;]"</span>, request.getRequestURI());</span><br><span class="line">        LOGGER.error(<span class="string">"Controller Error - "</span>, th);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(<span class="string">"500"</span>, <span class="string">"操作错误,请稍后再试"</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p align="center"><font color="blue">没有人不爱惜他的生命，但很少人珍视他的时间。</font></p><p align="right">——梁实秋</p>

<hr>
]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Reflect-Proxy</title>
    <url>/2016/11/14/Reflect-Proxy/</url>
    <content><![CDATA[<p>反射和动态代理</p>
<p>反射在java中是一个高级特性。它的用处很广泛，通过反射API可以获取程序在运行时刻的内部结构。本文不对反射基本API做详细的讲解。主要讲解反射在动态代理中应用。</p>
<h2 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h2><p> 为某个对象提供一个代理，以控制对这个对象的访问。 代理类和委托类有共同的父类或父接口，这样在任何使用委托类对象的地方都可以用代理对象替代。代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>   由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 代理接口。处理给定名字的任务。</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行给定名字的任务。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskName 任务名</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealTask</span><span class="params">(String taskName)</span></span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正执行任务的类，实现了代理接口。</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行给定名字的任务。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> taskName  </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealTask</span><span class="params">(String taskName)</span> </span>&#123;  </span><br><span class="line">      System.out.println(<span class="string">"正在执行任务："</span>+taskName);  </span><br><span class="line">      doSomething...</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *　代理类，实现了代理接口。</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line"> <span class="comment">//代理类持有一个委托类的对象引用  </span></span><br><span class="line"> <span class="keyword">private</span> Subject delegate;  </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ProxySubject</span><span class="params">(Subject delegate)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.delegate = delegate;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将请求分派给委托类执行，记录任务执行前后的时间，时间差即为任务的处理时间</span></span><br><span class="line"><span class="comment">  *  </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> taskName</span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line"> <span class="meta">@Override</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealTask</span><span class="params">(String taskName)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">long</span> stime = System.currentTimeMillis();   </span><br><span class="line">  <span class="comment">//将请求分派给委托类处理  </span></span><br><span class="line">  delegate.dealTask(taskName);  </span><br><span class="line">  <span class="keyword">long</span> ftime = System.currentTimeMillis();   </span><br><span class="line">  System.out.println(<span class="string">"执行任务耗时"</span>+(ftime - stime)+<span class="string">"毫秒"</span>);  </span><br><span class="line"></span><br><span class="line"> &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是一个简单的静态代理模式，我们获取到代理类ProxySubject可以操作相关接口。然后由具体的实现类执行。进而在真正执行方法前后做一些处理。很明显在代码运行前，相关类就已经确定。而我们针对每个接口类都需要实现代理类，增加新的接口方法，相关代理类也需要修改。代码不易维护。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>  顾名思义动态代理类的源码是在程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 代理接口。处理给定名字的任务。 (和静态代理一样没有什么变化)</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行给定名字的任务。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> taskName 任务名</span></span><br><span class="line"><span class="comment">   */</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealTask</span><span class="params">(String taskName)</span></span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 真正执行任务的类，实现了代理接口。 (和静态代理没有什么变化)</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 执行给定名字的任务。</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> taskName  </span></span><br><span class="line"><span class="comment">  */</span>  </span><br><span class="line">   <span class="meta">@Override</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dealTask</span><span class="params">(String taskName)</span> </span>&#123;  </span><br><span class="line">      System.out.println(<span class="string">"正在执行任务："</span>+taskName);  </span><br><span class="line">      doSomething...</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * InvocationHandlerImple实现InvocationHandler接口，覆写invoke()方法</span></span><br><span class="line"><span class="comment">   * 代理主题的业务写在invoke()方法中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvocationHandlerImpl</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//需要代理的对象</span></span><br><span class="line">     <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">InvocationHandlerImpl</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.target = target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">         <span class="keyword">long</span> stime = System.currentTimeMillis();   </span><br><span class="line">         Object obj = method.invoke(target, args);</span><br><span class="line">         <span class="keyword">long</span> ftime = System.currentTimeMillis();   </span><br><span class="line">         System.out.println(<span class="string">"执行任务耗时"</span>+(ftime - stime)+<span class="string">"毫秒"</span>);</span><br><span class="line">         <span class="keyword">return</span> obj;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用方法</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynProxyFactory</span> </span>&#123;    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line">   <span class="comment">//委托类，这里可以是很多个接口。</span></span><br><span class="line">   Subject delegate = <span class="keyword">new</span> RealSubject();  </span><br><span class="line">   InvocationHandler handler = InvocationHandlerImpl(delegate);  </span><br><span class="line">   Subject proxy = (Subject)Proxy.newProxyInstance(delegate.getClass().getClassLoader(),   delegate.getClass().getInterfaces(),   handler);  </span><br><span class="line">   proxy.dealTask(<span class="string">"Proxy Task"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可以看出来，动态代理用到了InvocationHandler类和Proxy类。其基本模式就是将自己的方法功能实现交给InvocationHandler角色，外界Proxy角色中的每个方法的调用，Proxy角色都会交给InvocationHandler来处理，而InvocationHandler则调用具体的对象角色的方法。这样我们的代理类动态生成的，不需要像静态代理那样针对每个接口实现自己的代理类。那么Proxy是如何生成的代理类呢？我接下来看源码分析（很多，很枯燥）。</p>
<h3 id="JDK动态代理实现"><a href="#JDK动态代理实现" class="headerlink" title="JDK动态代理实现"></a>JDK动态代理实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         * 具体的获取代理类Class对象调用方法，传入classloder和接口类也就是上面的Subject</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//反射获取构造方法</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="comment">//一句没用的代码，ih都没有用</span></span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="comment">//反射设置访问权限</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过反射调用构造方法直接返回实例对象，h是我们的传入的InvocationHandler实例。</span></span><br><span class="line">            <span class="comment">//这里是动态生成是实现Subject接口的代理类，后面我会给大家看看这个类里面的东东</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">    * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">    * 动态生成代理类Class对象调用方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">       <span class="comment">//接口类数组的长度小于65535，65535是计算机16位二进制最大数，如果大于就会内存溢出.</span></span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">       <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">       <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">       <span class="comment">//调用get方法,这里proxyClassCache对象是一个WeakCache（弱引用，用作缓存）对象。具体的get看下面。</span></span><br><span class="line">       <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里 key是classLoader P 是interfaces</span></span><br><span class="line">        <span class="comment">//判断是否为null</span></span><br><span class="line">        Objects.requireNonNull(parameter);</span><br><span class="line"></span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        <span class="comment">//将key转换成cacheKey</span></span><br><span class="line">        Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">        <span class="comment">//第一次进来才初始化valuseMap保存代理类和代理的接口</span></span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">                = map.putIfAbsent(cacheKey,</span><br><span class="line">                                  valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">            <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                valuesMap = oldValuesMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">        <span class="comment">// subKey from valuesMap</span></span><br><span class="line">        <span class="comment">//这一步获取代理类,调用BiFunction.apply方法,具体看下面</span></span><br><span class="line">        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">        <span class="comment">//从valuesMap中获取代理类，第一次或者新的classloder肯定为空</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//不为空的话直接取出来返回</span></span><br><span class="line">            <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">                V value = supplier.get();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else no supplier in cache</span></span><br><span class="line">            <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">            <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// lazily construct a Factory</span></span><br><span class="line">            <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">                factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为空的时候将上面生成的代理类放到valuesMap中</span></span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">                <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// successfully installed Factory</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else retry with winning supplier</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                    <span class="comment">// successfully replaced</span></span><br><span class="line">                    <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                    <span class="comment">// with our Factory</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// retry with current supplier</span></span><br><span class="line">                    supplier = valuesMap.get(subKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">       <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">           <span class="comment">//IdentityHashMap是一个key可以重复的的Map，这里jdk当做set来用</span></span><br><span class="line">           Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">                * interface to the same Class object.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//反射获得接口类的实例</span></span><br><span class="line">                   interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">                * interface.</span></span><br><span class="line"><span class="comment">                * 验证是否为接口 jdk动态代理只能代理接口</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">//将interfaceClass放入到interfaceSet，这里interfaceSet是IdentityHashMap</span></span><br><span class="line">                <span class="comment">//当我们put的时候发现已经有key了会添加后返回这个以前的key对应的value值，</span></span><br><span class="line">                <span class="comment">//这里来判读interface是否重复。</span></span><br><span class="line">               <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                       <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">           <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">            * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">            * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">            * 若为非公有接口则需要记录包名且判断必须为同一包</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">               <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">               <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                   accessFlags = Modifier.FINAL;</span><br><span class="line">                   String name = intf.getName();</span><br><span class="line">                   <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                   String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                   <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       proxyPkg = pkg;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                           <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">               <span class="comment">//无非公有接口则默认为com.sun.proxy package</span></span><br><span class="line">               proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">            * 选择一个代理类名称 第一为$Proxy0 以后类推。num生成是线程安全的</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">           String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">            * 生成class二进制文件，具体看下面</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//这个方法是native方法，加载class二进制</span></span><br><span class="line">               <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                   proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">               <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">                * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">                * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">                * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">                * exceeded).</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">        ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">        <span class="comment">//具体调用ProxyGenerator.generateClassFile方法生成class二进制文件，具体看下面</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">        <span class="comment">//如果saveGeneratedFiles为true，将会把class文件保存到项目com/sun/proxy下,即就是上面的默认包名目录</span></span><br><span class="line">        <span class="keyword">if</span>(saveGeneratedFiles) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                        Path var2;</span><br><span class="line">                        <span class="keyword">if</span>(var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar), <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                            Files.createDirectories(var3, <span class="keyword">new</span> FileAttribute[<span class="number">0</span>]);</span><br><span class="line">                            var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            var2 = Paths.get(var0 + <span class="string">".class"</span>, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加Object三个方法</span></span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(hashCodeMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(equalsMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">this</span>.addProxyMethod(toStringMethod, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Class[] var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">        <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> var3;</span><br><span class="line">        Class var4;</span><br><span class="line">        <span class="comment">//添加所有所有接口中的方法,idea源码直接把变量替换了</span></span><br><span class="line">        <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">            var4 = var1[var3];</span><br><span class="line">            Method[] var5 = var4.getMethods();</span><br><span class="line">            <span class="keyword">int</span> var6 = var5.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> var7 = <span class="number">0</span>; var7 &lt; var6; ++var7) &#123;</span><br><span class="line">                Method var8 = var5[var7];</span><br><span class="line">                <span class="keyword">this</span>.addProxyMethod(var8, var4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">        List var12;</span><br><span class="line">        <span class="comment">//处理重载的方法</span></span><br><span class="line">        <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">            var12 = (List)var11.next();</span><br><span class="line">            checkReturnTypes(var12);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var15;</span><br><span class="line">        <span class="comment">//组装 FieldInfo 和 MethodInfo</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateConstructor());</span><br><span class="line">            var11 = <span class="keyword">this</span>.proxyMethods.values().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(var11.hasNext()) &#123;</span><br><span class="line">                var12 = (List)var11.next();</span><br><span class="line">                var15 = var12.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();</span><br><span class="line">                    <span class="keyword">this</span>.fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(var16.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, <span class="number">10</span>));</span><br><span class="line">                    <span class="keyword">this</span>.methods.add(var16.generateMethod());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.methods.add(<span class="keyword">this</span>.generateStaticInitializer());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var10);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始写数据了 能力有限看不懂了</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.methods.size() &gt; <span class="string">'\uffff'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"method limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.fields.size() &gt; <span class="string">'\uffff'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"field limit exceeded"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className));</span><br><span class="line">            <span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>);</span><br><span class="line">            var1 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">            var2 = var1.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                var4 = var1[var3];</span><br><span class="line">                <span class="keyword">this</span>.cp.getClass(dotToSlash(var4.getName()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.cp.setReadOnly();</span><br><span class="line">            ByteArrayOutputStream var13 = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            DataOutputStream var14 = <span class="keyword">new</span> DataOutputStream(var13);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var14.writeInt(-<span class="number">889275714</span>);</span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                var14.writeShort(<span class="number">49</span>);</span><br><span class="line">                <span class="keyword">this</span>.cp.write(var14);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.accessFlags);</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(<span class="keyword">this</span>.className)));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.cp.getClass(<span class="string">"java/lang/reflect/Proxy"</span>));</span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.interfaces.length);</span><br><span class="line">                Class[] var17 = <span class="keyword">this</span>.interfaces;</span><br><span class="line">                <span class="keyword">int</span> var18 = var17.length;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var19 = <span class="number">0</span>; var19 &lt; var18; ++var19) &#123;</span><br><span class="line">                    Class var22 = var17[var19];</span><br><span class="line">                    var14.writeShort(<span class="keyword">this</span>.cp.getClass(dotToSlash(var22.getName())));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.fields.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.fields.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();</span><br><span class="line">                    var20.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="keyword">this</span>.methods.size());</span><br><span class="line">                var15 = <span class="keyword">this</span>.methods.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(var15.hasNext()) &#123;</span><br><span class="line">                    ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();</span><br><span class="line">                    var21.write(var14);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                var14.writeShort(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> var13.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"unexpected I/O Exception"</span>, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何查看生成的代理类"><a href="#如何查看生成的代理类" class="headerlink" title="如何查看生成的代理类"></a>如何查看生成的代理类</h3><p>我们在上面的代码中可以知道当ProxyGenerator类中saveGeneratedFiles属性值为true时候会把生成的class保存在项目根目录com/sun/proxy目录下。但是一般saveGeneratedFiles的值是false。我们可以在方法调用前修改这个值为true。在项目根目录下新建com/sun/proxy这个目录。运行就可以看见生成的class文件了。拿如何设置这个值呢 ？？请看下面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ProxyGenerator类中的saveGeneratedFiles属性值，是通过GetBooleanAction这个类获取的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>))).booleanValue();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> sun.security.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetBooleanAction</span> <span class="keyword">implements</span> <span class="title">PrivilegedAction</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String theProp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GetBooleanAction</span><span class="params">(String var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theProp = var1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里通过getBoolean获取“sun.misc.ProxyGenerator.saveGeneratedFiles”这个值</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.valueOf(Boolean.getBoolean(<span class="keyword">this</span>.theProp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//这里我们知道直接从System里面获取的值。</span></span><br><span class="line">          result = parseBoolean(System.getProperty(name));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException | NullPointerException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>到这里我们知道了<em>saveGeneratedFiles</em>这个属性值是通过<em>System.getProptery()</em>初始化的。我们可以在调用Proxy的方法前设置一下就好了。在我们使用代理类的时候可以这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用方法</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynProxyFactory</span> </span>&#123;    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;  </span><br><span class="line"> <span class="comment">//设置系统属性，为了能看见动态生成的class文件  </span></span><br><span class="line">  System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br><span class="line">   <span class="comment">//委托类，这里可以是很多个接口。</span></span><br><span class="line">   Subject delegate = <span class="keyword">new</span> RealSubject();  </span><br><span class="line">   InvocationHandler handler = InvocationHandlerImpl(delegate);  </span><br><span class="line">   Subject proxy = (Subject)Proxy.newProxyInstance(delegate.getClass().getClassLoader(),   delegate.getClass().getInterfaces(),   handler);  </span><br><span class="line">   proxy.dealTask(<span class="string">"Proxy Task"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成的class文件如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lty.rpc.api.Subject;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;)).booleanValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dealTask</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ((Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>)).intValue();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.Object"</span>)&#125;);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.lty.rpc.api.Subject"</span>).getMethod(<span class="string">"dealTask"</span>, <span class="keyword">new</span> Class[]&#123;Class.forName(<span class="string">"java.lang.String"</span>)&#125;);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从中我们可以看出动态生成的代理类是以$Proxy为类名前缀，继承自Proxy，并且实现了Proxy.newProxyInstance(…)第二个参数传入的所有接口的类。如果代理类实现的接口中存在非 public 接口，则其包名为该接口的包名，否则为com.sun.proxy。其中的dealTeask()函数都是直接交给h去处理，h在父类Proxy中定义为protected InvocationHandler h;即为Proxy.newProxyInstance(…)第三个参数。所以InvocationHandler的子类 C 连接代理类 A 和委托类 B，它是代理类 A 的委托类，委托类 B 的代理类。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><p>本想仔细分析一下 generateClassFile 的实现，但直接生成 class 文件这种方式确实较为复杂，我就简单说一下其原理吧。有一种比较土的生成 class 文件的方法就是直接使用源码的字符串，用 JavaCompiler 动态编译生成。这样就可以通过所需实现的接口运用反射获得其方法信息，方法实现则直接调用 InvocationHandler 实现类的 invoke 方法，拼出整个代理类的源码，编译生成。而直接组装 class 文件的这种方式更为直接，根据 JVM 规范所定义的 class 文件的格式，省去了组装源码的步骤，使用输出流直接按格式生成 class 文件，相当于自己实现了 JVM 的功能。这样生成 class 后通过 classloader 加载类，反射调用构造方法进行实例化，就可以得到代理类对象了。上面的代码（还有一部分没贴）就是组装 class 文件的过程，奈何我对其也不是很懂</p>
<hr>
<p align="center"><font color="blue">先相信自己，然后别人才会相信你。</font></p><p align="right">——罗曼·罗兰</p>

<hr>
]]></content>
      <tags>
        <tag>反射</tag>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Serializable</title>
    <url>/2016/11/14/Serializable/</url>
    <content><![CDATA[<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>&emsp;&emsp;Java的序列化很简单，只需要实现Serializable接口，然后就可以用ObjectInpuStream、ObjectOutputSteam进行序列化和反序列化了。下面简单演示一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">"LTY"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"password"</span>);</span><br><span class="line">        <span class="keyword">try</span>(ObjectOutputStream outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>)))&#123;</span><br><span class="line">            outputStream.writeObject(user);</span><br><span class="line">            System.out.println(<span class="string">"Write User "</span>+user.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>(ObjectInputStream inputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"tempFile"</span>)))&#123;</span><br><span class="line">            User read = (User) inputStream.readObject();</span><br><span class="line">            System.out.println(<span class="string">"Read User "</span>+read.toString());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">//Write User User&#123;userName='LTY', password='password'&#125;</span></span><br><span class="line">    <span class="comment">//Read User User&#123;userName='LTY', password='password'&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面就是简单的，序列化和反序列化的过程。默认情况下Java是序列化所有成员变量的，除了静态变量。很好理解，静态变量并不属于某一个具体的对象。在有就是Transient关键字可以控制成员变量的序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String userName;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//Write User User&#123;userName='LTY', password='password'&#125;</span></span><br><span class="line"><span class="comment">//Read User User&#123;userName='LTY', password='null'&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;刚才的代码，我在password变量前面加上transient关键字，可以看到反序列化出来的结果为空。<br>&emsp;&emsp;Java序列化是将对象转换成的二进制写入文件，并且是可逆的。如果我们在进行Rpc调用的时候，会将这样的二进制格式的数据进行传输。这样是不安全的。对此我们可以自定义序列化和反序列化的一些策略。对一些敏感数据（比如password）进行模糊化。示例如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    password = password +<span class="string">"decode"</span>;  <span class="comment">//模拟加密,模糊数据</span></span><br><span class="line">    stream.defaultWriteObject();</span><br><span class="line">    stream.writeObject(password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    stream.defaultReadObject();</span><br><span class="line">    password = (String) stream.readObject();</span><br><span class="line">    password = password.substring(<span class="number">0</span>,password.lastIndexOf(<span class="string">"decode"</span>)); <span class="comment">//模拟解密,还原数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">//Write User User&#123;userName='LTY', password='passworddecode'&#125;</span></span><br><span class="line"><span class="comment">//Read User User&#123;userName='LTY', password='password'&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面代码我们在User类中加入了两个方法。这两个方法会在写和读的时候调用，我们可以用这样的方式来自定义序列化和反序列号策略。代码中我们看出，我们在password变量前面加了transient关键字,但是结果仍然反序列化出来了结果。就是因为我自定义了序列化。有兴趣的人可以去看看ArrayList的源码,其中的自定义序列化策略代码很有参考性。所以知识不是死板的我们要知道其中缘由。上面就是我们知道的一些Java序列化的一些用法。知道了怎么用我们在来看看一些实现。为什么我只需要实现了Serializable这个接口就可以序列化以及上面的writeObject和readObject方法是什么时候执行的，代码中我们并没有显示的去调用。那就的看源码了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ObjectOutputStream</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) &#123;</span><br><span class="line">            writeObjectOverride(obj);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写对象，我们进去看看</span></span><br><span class="line">            writeObject0(obj, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) &#123;</span><br><span class="line">                writeFatalException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//writeObject0方法部分代码</span></span><br><span class="line">          <span class="comment">// remaining cases</span></span><br><span class="line">           <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">               writeString((String) obj, unshared);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">               writeArray(obj, desc, unshared);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">               writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">               <span class="comment">//判断了对象的类型，(Enum、Array和Serializable)如果没有实现Serializable,则会抛出异常。</span></span><br><span class="line">               <span class="comment">//进入具体的写方法</span></span><br><span class="line">               writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">                       cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeOrdinaryObject</span><span class="params">(Object obj,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ObjectStreamClass desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">boolean</span> unshared)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            debugInfoStack.push(</span><br><span class="line">                (depth == <span class="number">1</span> ? <span class="string">"root "</span> : <span class="string">""</span>) + <span class="string">"object (class \""</span> +</span><br><span class="line">                obj.getClass().getName() + <span class="string">"\", "</span> + obj.toString() + <span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            desc.checkSerialize();</span><br><span class="line"></span><br><span class="line">            bout.writeByte(TC_OBJECT);</span><br><span class="line">            writeClassDesc(desc, <span class="keyword">false</span>);</span><br><span class="line">            handles.assign(unshared ? <span class="keyword">null</span> : obj);</span><br><span class="line">            <span class="comment">//判断类型。Externalizable 后面我会讲到。</span></span><br><span class="line">            <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">                writeExternalData((Externalizable) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//序列化数据</span></span><br><span class="line">                writeSerialData(obj, desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">                debugInfoStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//writeSerialData方法中调用了invoke</span></span><br><span class="line"><span class="comment">/** class-defined writeObject method, or null if none */</span></span><br><span class="line"><span class="keyword">private</span> Method writeObjectMethod;</span><br><span class="line"><span class="comment">/** class-defined readObject method, or null if none */</span></span><br><span class="line"><span class="keyword">private</span> Method readObjectMethod;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//这里的writeObjectMethod变量就是反射需要调用的方法</span></span><br><span class="line">        <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">                Throwable th = ex.getTargetException();</span><br><span class="line">                <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    throwMiscException(th);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">                <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面我们走了一遍写数据的流程。读数据的流程是一样的这就不说了。在写数据的时候通过instanceof来限制是否实现了Serializable接口，然后通过反射的方式调用了writeObject和readObject方法。<br>&emsp;&emsp;看源码的时候我们发现了一个Externalizable，其实我们实现序列化不止一种方法。Serializable接口只是最方便的，不需要我们写过多的代码。下面我们看看怎么用Externalizable实现序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Externalizable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                    <span class="string">"userName='"</span> + userName + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">", password='"</span> + password + <span class="string">'\''</span> +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            out.writeObject(userName);</span><br><span class="line">            out.writeObject(password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            userName = (String) in.readObject();</span><br><span class="line">            password = (String) in.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//output:</span></span><br><span class="line">    <span class="comment">//Write User User&#123;userName='LTY', password='password'&#125;</span></span><br><span class="line">    <span class="comment">//Read User User&#123;userName='LTY', password='password'&#125;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;我们通过实现Externalizable接口，并且必须复写writeExternal和readExter方法来实现序列化和反序列化。上面我们看源码的时候发现对Serializable和Externalizable做了判断。做不同处理。使用Externalizable意味着我们不能自动的序列化变量，需要将自己需要序列化的变量一个一个的写入到流当中,反序列的化的时候需要一个一个的读取,给成员变量进行初始化。还有使用Externalizable接口必须有有个无惨构造函数。</p>
<p>&emsp;&emsp;序列化的一些知识我们回顾的差不多了。然后我们谈谈Rpc中的序列化,在Rpc中我们的接口调用很频繁,要求我们在序列化方面需要很好的性能,如果使用Java原生的这种序列化方式那会很糟糕的,现在一些主流的Rpc框架早已经抛弃了。本人所在的公司用的自己研发的一个Rpc框架,他们没有使用二进制之类的序列化方法,为了从业务的考虑直接用的Json的序列化方法,这样我们可以方便开发人员的调试。后端技术已经很成熟了,比较好的一些序列化技术有Kryo,FST等针对Java语言的,还有一些跨语言的。比如Protostuff,ProtoBuf,Thrift等.当我们累个半死知道了Java的序列化之后,发现主流的一些技术已经把它抛弃了有时候我也不得不感觉郁闷啊。不过学无止境.</p>
<hr>
<p><font color="blue">人生犹如一本书，愚蠢者草草翻过，聪明人细细阅读。为何如此 . 因为他们只能读它一次。</font></p><p align="right">——保罗</p>

<hr>
]]></content>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>Cross Domin</title>
    <url>/2016/11/09/cross-domain/</url>
    <content><![CDATA[<p>一次跨域之旅</p>
<p>&emsp;&emsp;小洋前几天帮同学写了一个短信验证码的H5页面，应对他的奇葩需求，小洋在页面里面用Jquery直接调用的第三方的发短信的接口。当点击发送的时候，发现jQuery进入的是Error，但是一看手机已经收到验证码了。小洋也是相当的郁闷。然后F12一番，跨域了。小洋闭目三思，本地ajax请求第三方肯定跨域了，可是收到验证码了说明请求成功了啊。小洋以前有需求的时候戏玩Js。然不知其所以然，这次看了看jQuery的ajax部分的源码。才恍然大悟。</p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>&emsp;&emsp;跨域这个概念就不多说了，网上一大堆。说白了就是协议、域名、端口有任何一个不同，都被当做是不同的域。比如我本地<a href="http://localhost:8080/index.html" target="_blank" rel="noopener">http://localhost:8080/index.html</a> 中通过ajax去请求 <a href="http://localhost:9999/example" target="_blank" rel="noopener">http://localhost:9999/example</a> 是不允许的，因为端口不同，是不同的域。这就是跨域访问。</p>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>&emsp;&emsp;解决跨域的方法有很多。本文只是针对我上面提的问题说说 <em>jQuery</em> 中用到的 <em>JSONP</em>。大家不要胡乱猜想 <em>JSONP</em> 和 <em>JSON</em> 是两完全不一样的东西。<em>JSON</em> 是一种数据交互的格式。而JSONP是根据开发人员想出来非官方的一种跨域数据交互协议。其实我理解为是利用了html标签的一个小漏洞。那么为什么 <em>JSONP</em> 能跨域呢。我们知道【script】 【img】 【iframe】这个几个标签是是可以指定src属性从任何地方获取资源的。下面演示一下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">  var localHandler = function(data)&#123;</span><br><span class="line">      alert('我是本地函数，可以被跨域调用，远程带来的数据是：' + data.result);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"http://remoteserver.com/data"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;远程服务端返回的数据是这样的，就是一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localHandler(&#123;&quot;result&quot;:&quot;我是远程js带来的数据&quot;&#125;);</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面我们可以知道当我们加载页面的时候回去请求<a href="http://remoteserver.com/data" target="_blank" rel="noopener">http://remoteserver.com/data</a> 这个接口，接口返回了一段js代码。然后浏览器就会执行这段js代码。看的出来，服务端返回的js代码调用了我们的localHandler方法，并且传入数据。这个数据就是我们正常服务端接口返回的数据。现在要支持 <em>JSONP</em> 跨域。服务端需要将数据进行一下包装。类似上面那样的。这就是 <em>JSONP</em> 跨域的原理。</p>
<p>&emsp;&emsp;那么问题来了，服务端是怎么知道我本地需要调用那个JS方法的。针对这个问题我们可以动态的生成【script】标签，演示如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">    // 得到航班信息查询结果后的回调函数</span><br><span class="line">    var flightHandler = function(data)&#123;</span><br><span class="line">        alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');</span><br><span class="line">    &#125;;</span><br><span class="line">    // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</span><br><span class="line">    var url = "http://remoteserver.com/jsonp/data?code=CA1998&amp;callback=flightHandler";</span><br><span class="line">    // 创建script标签，设置其属性</span><br><span class="line">    var script = document.createElement('script');</span><br><span class="line">    script.setAttribute('src', url);</span><br><span class="line">    // 把script标签加入head，此时调用开始</span><br><span class="line">    document.getElementsByTagName('head')[0].appendChild(script);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面我们通过动态的生成【script】标签，并且将本地的调用方法以callback参数传给后台。后台需要获取这个参数组装js代码。其实JQuery内部实现原理都大同小异。它帮你做了很多事情。</p>
<h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>&emsp;&emsp;Jquery 中的ajax使用了jsonp这样的技术，最开始上面的问题，由于我用了Jquery的ajax去请求第三方发短信接口，Jquery发现是跨域请求就默认使用了jsonp的方式并且使用的默认的回调方法，由于第三方接口没有配合jsonp的使用，返回的不是可调用的js代码，Jquery就是处理的时候进入到了error回调。这就是为啥接口调用成功了但是进入的error的回调。知道了jsonp的原理，我们可以很容易的看出这样只能支持GET请求，对于POST请求时无能为力的。这也是jsonp的一个限制吧。在Jquery的高版本中，会将跨域的POST请求，自动转换成GET请求。如果发现自己method写的POST然后发现成功了，不要惊讶，打开浏览器F12查看一下你就会发现其实是GET请求了。<font color="red">再有使用jsonp一定要服务端的配合使用，不要自己在前端写写就觉得可以实现跨域了。</font>现在基本上都用Nginx做反向代理来解决跨域问题，很方便。</p>
<p>&emsp;&emsp;通过这次小洋知道了跨域的一系列原理，文章内容不入法眼，只是提醒一下自己，凡是要知其所以然才能随心所欲。</p>
<hr>
<p align="center"><font color="blue">与其临渊羡鱼,不如退而结网</font></p><p align="right">--《史记·汉书·董仲舒传》</p>

<hr>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>JOOQ Start</title>
    <url>/2016/11/07/JOOQ-start/</url>
    <content><![CDATA[<p>JOOQ 简单的使用</p>
<p>毕业以后进入的公司数据库持久层用的JOOQ，流式的API敲起来很爽。这里记录一下。具体的用法可以直接查看官网文档 <em><a href="http://www.jooq.org/" target="_blank" rel="noopener">http://www.jooq.org/</a></em></p>
<h3 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h3><p>JOOQ是根据数据库自动生成的表对象。这里我们使用maven的插件来生成。官方的maven配置<em> <a href="http://www.jooq.org/doc/3.8/manual-single-page/#codegen-configuration" target="_blank" rel="noopener">http://www.jooq.org/doc/3.8/manual-single-page/#codegen-configuration</a></em></p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Specify the maven code generator plugin --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;version&gt;$&#123;jooq.version&#125;&lt;/version&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- The plugin should hook into the generate goal --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>generate-mysql<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-sources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Manage the plugin's dependency. In this example, we'll use a MySQL database --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.37<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Specify the plugin configuration.</span></span><br><span class="line"><span class="comment">    The configuration format is the same as for the standalone code generator --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- JDBC connection parameters --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">driver</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">driver</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">user</span>&gt;</span>root<span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">password</span>&gt;</span>root<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Generator parameters --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">generator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">database</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>org.jooq.util.mysql.MySQLDatabase<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span>.*<span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inputSchema</span>&gt;</span>test<span class="tag">&lt;/<span class="name">inputSchema</span>&gt;</span>  <span class="comment">&lt;!--database name--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">database</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">packageName</span>&gt;</span>me.lty.data<span class="tag">&lt;/<span class="name">packageName</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后我们导入JOOQ的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jooq.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="简单的代码"><a href="#简单的代码" class="headerlink" title="简单的代码"></a>简单的代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这使用jOOQ默认的配置</span></span><br><span class="line"><span class="comment">//或者 DSLContext create = new DefaultDSLContext(SQLDialect.MYSQL);</span></span><br><span class="line">DSLContext create = DSL.using(<span class="keyword">new</span> DefaultConfiguration().derive(SQLDialect.MYSQL));</span><br><span class="line"><span class="comment">//这里就是简单的根据ID获取的操作。更多的用法请查看官方文档</span></span><br><span class="line">MainRecord record  = create.selectFrom(MAIN).where(MAIN.NUMBER.eq(id)).fetchOne();</span><br></pre></td></tr></table></figure>
<hr>
<p align="center"><font color="blue">书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。</font></p><p align="right">——史美尔斯</p>

<hr>
]]></content>
      <tags>
        <tag>JOOQ</tag>
      </tags>
  </entry>
</search>
